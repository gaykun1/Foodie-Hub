{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/encryption-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n"],"names":["arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","name","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","normalizeAppPath","serverActionsManifestSingleton","InvariantError","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","route","rawKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAYgBA,mBAAmB,EAAA;eAAnBA;;IA0CAC,OAAO,EAAA;eAAPA;;IAXAC,OAAO,EAAA;eAAPA;;IA6HMC,sBAAsB,EAAA;eAAtBA;;IAxCNC,gCAAgC,EAAA;eAAhCA;;IApBAC,kBAAkB,EAAA;eAAlBA;;IAnCAC,8BAA8B,EAAA;eAA9BA;;IAzCAC,kBAAkB,EAAA;eAAlBA;;;gCA1Be;0BACE;0CACA;AAEjC,IAAIC;AAEG,SAASR,oBACdS,MAAiD;IAEjD,MAAMC,QAAQ,IAAIC,WAAWF;IAC7B,MAAMG,MAAMF,MAAMG,UAAU;IAE5B,6DAA6D;IAC7D,mCAAmC;IACnC,4EAA4E;IAC5E,IAAID,MAAM,OAAO;QACf,OAAOE,OAAOC,YAAY,CAACC,KAAK,CAAC,MAAMN;IACzC;IAEA,IAAIO,SAAS;IACb,IAAK,IAAIC,IAAI,GAAGA,IAAIN,KAAKM,IAAK;QAC5BD,UAAUH,OAAOC,YAAY,CAACL,KAAK,CAACQ,EAAE;IACxC;IACA,OAAOD;AACT;AAEO,SAASV,mBAAmBU,MAAc;IAC/C,MAAML,MAAMK,OAAOE,MAAM;IACzB,MAAMC,MAAM,IAAIT,WAAWC;IAE3B,IAAK,IAAIM,IAAI,GAAGA,IAAIN,KAAKM,IAAK;QAC5BE,GAAG,CAACF,EAAE,GAAGD,OAAOI,UAAU,CAACH;IAC7B;IAEA,OAAOE;AACT;AAEO,SAASlB,QAAQoB,GAAc,EAAEC,EAAc,EAAEC,IAAgB;IACtE,OAAOC,OAAOC,MAAM,CAACxB,OAAO,CAC1B;QACEyB,MAAM;QACNJ;IACF,GACAD,KACAE;AAEJ;AAEO,SAASvB,QAAQqB,GAAc,EAAEC,EAAc,EAAEC,IAAgB;IACtE,OAAOC,OAAOC,MAAM,CAACzB,OAAO,CAC1B;QACE0B,MAAM;QACNJ;IACF,GACAD,KACAE;AAEJ;AAEA,sFAAsF;AACtF,wFAAwF;AACxF,4FAA4F;AAC5F,cAAc;AACd,MAAMI,oCAAoCC,OAAOC,GAAG,CAClD;AAGK,SAASxB,+BAA+B,EAC7CyB,IAAI,EACJC,uBAAuB,EACvBC,qBAAqB,EACrBC,eAAe,EAYhB;QAEyCC;IADxC,mBAAmB;IACnB,MAAMC,kCAAAA,CAAkCD,gDAAAA,UAAU,CAChDP,kCACD,KAAA,OAAA,KAAA,IAFuCO,8CAErCC,+BAA+B;IAIlC,mBAAmB;IACnBD,UAAU,CAACP,kCAAkC,GAAG;QAC9CQ,iCAAiC;YAC/B,GAAGA,+BAA+B;YAClC,CAACC,CAAAA,GAAAA,UAAAA,gBAAgB,EAACN,MAAM,EAAEC;QAC5B;QACAC;QACAC;IACF;AACF;AAEO,SAAS7B;IACd,MAAMiC,iCAAkCH,UAAkB,CACxDP,kCACD;IAUD,IAAI,CAACU,gCAAgC;QACnC,MAAM,OAAA,cAA0D,CAA1D,IAAIC,gBAAAA,cAAc,CAAC,yCAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAAyD;IACjE;IAEA,OAAOD,+BAA+BJ,eAAe;AACvD;AAEO,SAAS9B;IACd,MAAMkC,iCAAkCH,UAAkB,CACxDP,kCACD;IAMD,IAAI,CAACU,gCAAgC;QACnC,MAAM,OAAA,cAA0D,CAA1D,IAAIC,gBAAAA,cAAc,CAAC,yCAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAAyD;IACjE;IAEA,MAAM,EAAEH,+BAA+B,EAAE,GAAGE;IAC5C,MAAME,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;IAE3C,IAAI,CAACF,WAAW;QACd,0EAA0E;QAC1E,uEAAuE;QACvE,mEAAmE;QACnE,yEAAyE;QACzE,yEAAyE;QACzE,2EAA2E;QAC3E,2EAA2E;QAC3E,aAAa;QACb,OAAOG,8BAA8BP;IACvC;IAEA,MAAMJ,0BACJI,+BAA+B,CAACI,UAAUI,KAAK,CAAC;IAElD,IAAI,CAACZ,yBAAyB;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIO,gBAAAA,cAAc,CACtB,CAAC,sCAAsC,EAAEC,UAAUI,KAAK,CAAC,CAAC,CAAC,GADvD,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAOZ;AACT;AAEO,eAAe7B;IACpB,IAAIK,0BAA0B;QAC5B,OAAOA;IACT;IAEA,MAAM8B,iCAAkCH,UAAkB,CACxDP,kCACD;IAID,IAAI,CAACU,gCAAgC;QACnC,MAAM,OAAA,cAA0D,CAA1D,IAAIC,gBAAAA,cAAc,CAAC,yCAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAAyD;IACjE;IAEA,MAAMM,SACJC,QAAQC,GAAG,CAACC,kCAAkC,IAC9CV,+BAA+BL,qBAAqB,CAACgB,aAAa;IAEpE,IAAIJ,WAAWK,WAAW;QACxB,MAAM,OAAA,cAA+D,CAA/D,IAAIX,gBAAAA,cAAc,CAAC,8CAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAA8D;IACtE;IAEA/B,2BAA2B,MAAMiB,OAAOC,MAAM,CAACyB,SAAS,CACtD,OACA5C,mBAAmB6C,KAAKP,UACxB,WACA,MACA;QAAC;QAAW;KAAU;IAGxB,OAAOrC;AACT;AAEA,SAASmC,8BACPP,+BAEC;IAED,MAAMiB,2BAA2BC,OAAOC,MAAM,CAC5CnB;IAGF,MAAMoB,gCAA+D;QACnEC,eAAe,CAAC;QAChBC,sBAAsB,CAAC;QACvBC,kBAAkB,CAAC;IACrB;IAEA,KAAK,MAAM3B,2BAA2BqB,yBAA0B;QAC9DG,8BAA8BC,aAAa,GAAG;YAC5C,GAAGD,8BAA8BC,aAAa;YAC9C,GAAGzB,wBAAwByB,aAAa;QAC1C;QACAD,8BAA8BE,oBAAoB,GAAG;YACnD,GAAGF,8BAA8BE,oBAAoB;YACrD,GAAG1B,wBAAwB0B,oBAAoB;QACjD;QACAF,8BAA8BG,gBAAgB,GAAG;YAC/C,GAAGH,8BAA8BG,gBAAgB;YACjD,GAAG3B,wBAAwB2B,gBAAgB;QAC7C;IACF;IAEA,OAAOH;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/action-utils.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\n// This function creates a Flight-acceptable server module map proxy from our\n// Server Reference Manifest similar to our client module map.\n// This is because our manifest contains a lot of internal Next.js data that\n// are relevant to the runtime, workers, etc. that React doesn't need to know.\nexport function createServerModuleMap({\n  serverActionsManifest,\n}: {\n  serverActionsManifest: ActionManifest\n}) {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          serverActionsManifest[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string,\n  serverActionsManifest: ActionManifest\n) {\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n  const workerName = normalizeWorkerPageName(pageName)\n\n  // no workers, nothing to forward to\n  if (!workers) return\n\n  // if there is a worker for this page, no need to forward it.\n  if (workers[workerName]) {\n    return\n  }\n\n  // otherwise, grab the first worker that has a handler for this action id\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\n/**\n * The flight entry loader keys actions by bundlePath.\n * bundlePath corresponds with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page name\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n"],"names":["createServerModuleMap","selectWorkerForForwarding","serverActionsManifest","Proxy","get","_","id","workers","process","env","NEXT_RUNTIME","undefined","workStore","workAsyncStorage","getStore","workerEntry","normalizeWorkerPageName","page","Object","values","at","moduleId","async","name","chunks","actionId","pageName","workerName","denormalizeWorkerPageName","keys","pathHasPrefix","bundlePath","normalizeAppPath","removePathPrefix"],"mappings":";;;;;;;;;;;;;;;IAUgBA,qBAAqB,EAAA;eAArBA;;IAqDAC,yBAAyB,EAAA;eAAzBA;;;0BA9DiB;+BACH;kCACG;0CACA;AAM1B,SAASD,sBAAsB,EACpCE,qBAAqB,EAGtB;IACC,OAAO,IAAIC,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;gBAELJ,4BAAAA;YADF,MAAMK,UAAAA,CACJL,0BAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,uCAAS,OAChD,KAAA,OAAA,KAAA,IAAA,CAFDR,6BAAAA,uBAEG,CAACI,GAAG,KAAA,OAAA,KAAA,IAFPJ,2BAESK,OAAO;YAElB,IAAI,CAACA,SAAS;gBACZ,OAAOI;YACT;YAEA,MAAMC,YAAYC,0BAAAA,gBAAgB,CAACC,QAAQ;YAE3C,IAAIC;YAIJ,IAAIH,WAAW;gBACbG,cAAcR,OAAO,CAACS,wBAAwBJ,UAAUK,IAAI,EAAE;YAChE,OAAO;gBACL,gEAAgE;gBAChE,kEAAkE;gBAClE,sEAAsE;gBACtE,qEAAqE;gBACrE,qEAAqE;gBACrE,qEAAqE;gBACrE,oCAAoC;gBACpCF,cAAcG,OAAOC,MAAM,CAACZ,SAASa,EAAE,CAAC;YAC1C;YAEA,IAAI,CAACL,aAAa;gBAChB,OAAOJ;YACT;YAEA,MAAM,EAAEU,QAAQ,EAAEC,KAAK,EAAE,GAAGP;YAE5B,OAAO;gBAAET,IAAIe;gBAAUE,MAAMjB;gBAAIkB,QAAQ,EAAE;gBAAEF;YAAM;QACrD;IACF;AAEJ;AAMO,SAASrB,0BACdwB,QAAgB,EAChBC,QAAgB,EAChBxB,qBAAqC;QAGnCA;IADF,MAAMK,UAAAA,CACJL,mCAAAA,qBAAqB,CACnBM,QAAQC,GAAG,CAACC,YAAY,KAAK,SAAS,uCAAS,OAChD,CAACe,SAAS,KAAA,OAAA,KAAA,IAFXvB,iCAEaK,OAAO;IACtB,MAAMoB,aAAaX,wBAAwBU;IAE3C,oCAAoC;IACpC,IAAI,CAACnB,SAAS;IAEd,6DAA6D;IAC7D,IAAIA,OAAO,CAACoB,WAAW,EAAE;QACvB;IACF;IAEA,yEAAyE;IACzE,OAAOC,0BAA0BV,OAAOW,IAAI,CAACtB,QAAQ,CAAC,EAAE;AAC1D;AAEA;;;CAGC,GACD,SAASS,wBAAwBU,QAAgB;IAC/C,IAAII,CAAAA,GAAAA,eAAAA,aAAa,EAACJ,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;CAEC,GACD,SAASE,0BAA0BG,UAAkB;IACnD,OAAOC,CAAAA,GAAAA,UAAAA,gBAAgB,EAACC,CAAAA,GAAAA,kBAAAA,gBAAgB,EAACF,YAAY;AACvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/async-local-storage.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n"],"names":["bindSnapshot","createAsyncLocalStorage","createSnapshot","sharedAsyncLocalStorageNotAvailableError","Error","FakeAsyncLocalStorage","disable","getStore","undefined","run","exit","enterWith","bind","fn","maybeGlobalAsyncLocalStorage","globalThis","AsyncLocalStorage","snapshot","args"],"mappings":";;;;;;;;;;;;;;;;IA+CgBA,YAAY,EAAA;eAAZA;;IATAC,uBAAuB,EAAA;eAAvBA;;IAgBAC,cAAc,EAAA;eAAdA;;;AApDhB,MAAMC,2CAA2C,OAAA,cAEhD,CAFgD,IAAIC,MACnD,+EAD+C,qBAAA;WAAA;gBAAA;kBAAA;AAEjD;AAEA,MAAMC;IAGJC,UAAgB;QACd,MAAMH;IACR;IAEAI,WAA8B;QAC5B,4EAA4E;QAC5E,OAAOC;IACT;IAEAC,MAAY;QACV,MAAMN;IACR;IAEAO,OAAa;QACX,MAAMP;IACR;IAEAQ,YAAkB;QAChB,MAAMR;IACR;IAEA,OAAOS,KAAQC,EAAK,EAAK;QACvB,OAAOA;IACT;AACF;AAEA,MAAMC,+BACJ,OAAOC,eAAe,eAAgBA,WAAmBC,iBAAiB;AAErE,SAASf;IAGd,IAAIa,8BAA8B;QAChC,OAAO,IAAIA;IACb;IACA,OAAO,IAAIT;AACb;AAEO,SAASL,aAAgBa,EAAK;IACnC,IAAIC,8BAA8B;QAChC,OAAOA,6BAA6BF,IAAI,CAACC;IAC3C;IACA,OAAOR,sBAAsBO,IAAI,CAACC;AACpC;AAEO,SAASX;IAId,IAAIY,8BAA8B;QAChC,OAAOA,6BAA6BG,QAAQ;IAC9C;IACA,OAAO,SAAUJ,EAAO,EAAE,GAAGK,IAAW;QACtC,OAAOL,MAAMK;IACf;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-segment-param.tsx"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\nimport type { DynamicParamTypes } from './types'\n\n/**\n * Parse dynamic route segment to type of parameter\n */\nexport function getSegmentParam(segment: string): {\n  param: string\n  type: DynamicParamTypes\n} | null {\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n    segment.startsWith(marker)\n  )\n\n  // if an interception marker is part of the path segment, we need to jump ahead\n  // to the relevant portion for param parsing\n  if (interceptionMarker) {\n    segment = segment.slice(interceptionMarker.length)\n  }\n\n  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n    return {\n      // TODO-APP: Optional catchall does not currently work with parallel routes,\n      // so for now aren't handling a potential interception marker.\n      type: 'optional-catchall',\n      param: segment.slice(5, -2),\n    }\n  }\n\n  if (segment.startsWith('[...') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'catchall-intercepted' : 'catchall',\n      param: segment.slice(4, -1),\n    }\n  }\n\n  if (segment.startsWith('[') && segment.endsWith(']')) {\n    return {\n      type: interceptionMarker ? 'dynamic-intercepted' : 'dynamic',\n      param: segment.slice(1, -1),\n    }\n  }\n\n  return null\n}\n"],"names":["getSegmentParam","segment","interceptionMarker","INTERCEPTION_ROUTE_MARKERS","find","marker","startsWith","slice","length","endsWith","type","param"],"mappings":";;;;+BAMgBA,mBAAAA;;;eAAAA;;;oCAN2B;AAMpC,SAASA,gBAAgBC,OAAe;IAI7C,MAAMC,qBAAqBC,oBAAAA,0BAA0B,CAACC,IAAI,CAAC,CAACC,SAC1DJ,QAAQK,UAAU,CAACD;IAGrB,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAIH,oBAAoB;QACtBD,UAAUA,QAAQM,KAAK,CAACL,mBAAmBM,MAAM;IACnD;IAEA,IAAIP,QAAQK,UAAU,CAAC,YAAYL,QAAQQ,QAAQ,CAAC,OAAO;QACzD,OAAO;YACL,4EAA4E;YAC5E,8DAA8D;YAC9DC,MAAM;YACNC,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIN,QAAQK,UAAU,CAAC,WAAWL,QAAQQ,QAAQ,CAAC,MAAM;QACvD,OAAO;YACLC,MAAMR,qBAAqB,yBAAyB;YACpDS,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,IAAIN,QAAQK,UAAU,CAAC,QAAQL,QAAQQ,QAAQ,CAAC,MAAM;QACpD,OAAO;YACLC,MAAMR,qBAAqB,wBAAwB;YACnDS,OAAOV,QAAQM,KAAK,CAAC,GAAG,CAAC;QAC3B;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/server-inserted-html.tsx"],"sourcesContent":["// Provider for the `useServerInsertedHTML` API to register callbacks to insert\n// elements into the HTML stream.\n\nimport React, { type JSX } from 'react'\nimport { ServerInsertedHTMLContext } from '../../shared/lib/server-inserted-html.shared-runtime'\n\nexport function createServerInsertedHTML() {\n  const serverInsertedHTMLCallbacks: (() => React.ReactNode)[] = []\n  const addInsertedHtml = (handler: () => React.ReactNode) => {\n    serverInsertedHTMLCallbacks.push(handler)\n  }\n\n  return {\n    ServerInsertedHTMLProvider({ children }: { children: JSX.Element }) {\n      return (\n        <ServerInsertedHTMLContext.Provider value={addInsertedHtml}>\n          {children}\n        </ServerInsertedHTMLContext.Provider>\n      )\n    },\n    renderServerInsertedHTML() {\n      return serverInsertedHTMLCallbacks.map((callback, index) => (\n        <React.Fragment key={'__next_server_inserted__' + index}>\n          {callback()}\n        </React.Fragment>\n      ))\n    },\n  }\n}\n"],"names":["createServerInsertedHTML","serverInsertedHTMLCallbacks","addInsertedHtml","handler","push","ServerInsertedHTMLProvider","children","ServerInsertedHTMLContext","Provider","value","renderServerInsertedHTML","map","callback","index","React","Fragment"],"mappings":"AAAA,+EAA+E;AAC/E,iCAAiC;;;;;+BAKjBA,4BAAAA;;;eAAAA;;;;8DAHgB;iDACU;;;;;;AAEnC,SAASA;IACd,MAAMC,8BAAyD,EAAE;IACjE,MAAMC,kBAAkB,CAACC;QACvBF,4BAA4BG,IAAI,CAACD;IACnC;IAEA,OAAO;QACLE,4BAA2B,EAAEC,QAAQ,EAA6B;YAChE,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,iCAAAA,yBAAyB,CAACC,QAAQ,EAAA;gBAACC,OAAOP;0BACxCI;;QAGP;QACAI;YACE,OAAOT,4BAA4BU,GAAG,CAAC,CAACC,UAAUC,QAAAA,WAAAA,GAChD,CAAA,GAAA,YAAA,GAAA,EAACC,OAAAA,OAAK,CAACC,QAAQ,EAAA;8BACZH;mBADkB,6BAA6BC;QAItD;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/encryption-utils-server.ts"],"sourcesContent":["// This file should never be bundled into application's runtime code and should\n// stay in the Next.js server.\nimport path from 'path'\nimport fs from 'fs'\nimport { getStorageDirectory } from '../cache-dir'\nimport { arrayBufferToString } from './encryption-utils'\n\n// Keep the key in memory as it should never change during the lifetime of the server in\n// both development and production.\nlet __next_encryption_key_generation_promise: Promise<string> | null = null\nconst CONFIG_FILE = '.rscinfo'\nconst ENCRYPTION_KEY = 'encryption.key'\nconst ENCRYPTION_EXPIRE_AT = 'encryption.expire_at'\nconst EXPIRATION = 1000 * 60 * 60 * 24 * 14 // 14 days\n\nasync function writeCache(distDir: string, configValue: string) {\n  const cacheBaseDir = getStorageDirectory(distDir)\n  if (!cacheBaseDir) return\n\n  const configPath = path.join(cacheBaseDir, CONFIG_FILE)\n  if (!fs.existsSync(cacheBaseDir)) {\n    await fs.promises.mkdir(cacheBaseDir, { recursive: true })\n  }\n  await fs.promises.writeFile(\n    configPath,\n    JSON.stringify({\n      [ENCRYPTION_KEY]: configValue,\n      [ENCRYPTION_EXPIRE_AT]: Date.now() + EXPIRATION,\n    })\n  )\n}\n\n// This utility is used to get a key for the cache directory. If the\n// key is not present, it will generate a new one and store it in the\n// cache directory inside dist.\n// The key will also expire after a certain amount of time. Once it\n// expires, a new one will be generated.\n// During the lifetime of the server, it will be reused and never refreshed.\nasync function loadOrGenerateKey(\n  distDir: string,\n  isBuild: boolean,\n  generateKey: () => Promise<string>\n): Promise<string> {\n  const cacheBaseDir = getStorageDirectory(distDir)\n\n  if (!cacheBaseDir) {\n    // There's no persistent storage available. We generate a new key.\n    // This also covers development time.\n    return await generateKey()\n  }\n\n  const configPath = path.join(cacheBaseDir, CONFIG_FILE)\n  async function hasCachedKey(): Promise<false | string> {\n    if (!fs.existsSync(configPath)) return false\n    try {\n      const config = JSON.parse(await fs.promises.readFile(configPath, 'utf8'))\n      if (!config) return false\n      if (\n        typeof config[ENCRYPTION_KEY] !== 'string' ||\n        typeof config[ENCRYPTION_EXPIRE_AT] !== 'number'\n      ) {\n        return false\n      }\n      // For build time, we need to rotate the key if it's expired. Otherwise\n      // (next start) we have to keep the key as it is so the runtime key matches\n      // the build time key.\n      if (isBuild && config[ENCRYPTION_EXPIRE_AT] < Date.now()) {\n        return false\n      }\n      const cachedKey = config[ENCRYPTION_KEY]\n\n      // If encryption key is provided via env, and it's not same as valid cache,\n      //  we should not use the cached key and respect the env key.\n      if (\n        cachedKey &&\n        process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY &&\n        cachedKey !== process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY\n      ) {\n        return false\n      }\n      return cachedKey\n    } catch {\n      // Broken config file. We should generate a new key and overwrite it.\n      return false\n    }\n  }\n  const maybeValidKey = await hasCachedKey()\n  if (typeof maybeValidKey === 'string') {\n    return maybeValidKey\n  }\n  const key = await generateKey()\n  await writeCache(distDir, key)\n\n  return key\n}\n\nexport async function generateEncryptionKeyBase64({\n  isBuild,\n  distDir,\n}: {\n  isBuild: boolean\n  distDir: string\n}) {\n  // This avoids it being generated multiple times in parallel.\n  if (!__next_encryption_key_generation_promise) {\n    __next_encryption_key_generation_promise = loadOrGenerateKey(\n      distDir,\n      isBuild,\n      async () => {\n        const providedKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY\n\n        if (providedKey) {\n          return providedKey\n        }\n        const key = await crypto.subtle.generateKey(\n          {\n            name: 'AES-GCM',\n            length: 256,\n          },\n          true,\n          ['encrypt', 'decrypt']\n        )\n        const exported = await crypto.subtle.exportKey('raw', key)\n        return btoa(arrayBufferToString(exported))\n      }\n    )\n  }\n  return __next_encryption_key_generation_promise\n}\n"],"names":["generateEncryptionKeyBase64","__next_encryption_key_generation_promise","CONFIG_FILE","ENCRYPTION_KEY","ENCRYPTION_EXPIRE_AT","EXPIRATION","writeCache","distDir","configValue","cacheBaseDir","getStorageDirectory","configPath","path","join","fs","existsSync","promises","mkdir","recursive","writeFile","JSON","stringify","Date","now","loadOrGenerateKey","isBuild","generateKey","hasCachedKey","config","parse","readFile","cachedKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","maybeValidKey","key","providedKey","crypto","subtle","name","length","exported","exportKey","btoa","arrayBufferToString"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/make-get-server-inserted-html.tsx"],"sourcesContent":["import React, { type JSX } from 'react'\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport type { ClientTraceDataEntry } from '../lib/trace/tracer'\n\nexport function makeGetServerInsertedHTML({\n  polyfills,\n  renderServerInsertedHTML,\n  serverCapturedErrors,\n  tracingMetadata,\n  basePath,\n}: {\n  polyfills: JSX.IntrinsicElements['script'][]\n  renderServerInsertedHTML: () => React.ReactNode\n  tracingMetadata: ClientTraceDataEntry[] | undefined\n  serverCapturedErrors: Array<unknown>\n  basePath: string\n}) {\n  let flushedErrorMetaTagsUntilIndex = 0\n  // flag for static content that only needs to be flushed once\n  let hasFlushedInitially = false\n\n  const polyfillTags = polyfills.map((polyfill) => {\n    return <script key={polyfill.src} {...polyfill} />\n  })\n\n  return async function getServerInsertedHTML() {\n    // Loop through all the errors that have been captured but not yet\n    // flushed.\n    const errorMetaTags = []\n    while (flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length) {\n      const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex]\n      flushedErrorMetaTagsUntilIndex++\n\n      if (isHTTPAccessFallbackError(error)) {\n        errorMetaTags.push(\n          <meta name=\"robots\" content=\"noindex\" key={error.digest} />,\n          process.env.NODE_ENV === 'development' ? (\n            <meta name=\"next-error\" content=\"not-found\" key=\"next-error\" />\n          ) : null\n        )\n      } else if (isRedirectError(error)) {\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(error),\n          basePath\n        )\n        const statusCode = getRedirectStatusCodeFromError(error)\n        const isPermanent =\n          statusCode === RedirectStatusCode.PermanentRedirect ? true : false\n        if (redirectUrl) {\n          errorMetaTags.push(\n            <meta\n              id=\"__next-page-redirect\"\n              httpEquiv=\"refresh\"\n              content={`${isPermanent ? 0 : 1};url=${redirectUrl}`}\n              key={error.digest}\n            />\n          )\n        }\n      }\n    }\n\n    const traceMetaTags = (tracingMetadata || []).map(\n      ({ key, value }, index) => (\n        <meta key={`next-trace-data-${index}`} name={key} content={value} />\n      )\n    )\n\n    const serverInsertedHTML = renderServerInsertedHTML()\n\n    // Skip React rendering if we know the content is empty.\n    if (\n      polyfillTags.length === 0 &&\n      traceMetaTags.length === 0 &&\n      errorMetaTags.length === 0 &&\n      Array.isArray(serverInsertedHTML) &&\n      serverInsertedHTML.length === 0\n    ) {\n      return ''\n    }\n\n    const stream = await renderToReadableStream(\n      <>\n        {\n          /* Insert the polyfills if they haven't been flushed yet. */\n          hasFlushedInitially ? null : polyfillTags\n        }\n        {serverInsertedHTML}\n        {hasFlushedInitially ? null : traceMetaTags}\n        {errorMetaTags}\n      </>,\n      {\n        // Larger chunk because this isn't sent over the network.\n        // Let's set it to 1MB.\n        progressiveChunkSize: 1024 * 1024,\n      }\n    )\n\n    hasFlushedInitially = true\n\n    // There's no need to wait for the stream to be ready\n    // e.g. calling `await stream.allReady` because `streamToString` will\n    // wait and decode the stream progressively with better parallelism.\n    return streamToString(stream)\n  }\n}\n"],"names":["makeGetServerInsertedHTML","polyfills","renderServerInsertedHTML","serverCapturedErrors","tracingMetadata","basePath","flushedErrorMetaTagsUntilIndex","hasFlushedInitially","polyfillTags","map","polyfill","script","src","getServerInsertedHTML","errorMetaTags","length","error","isHTTPAccessFallbackError","push","meta","name","content","digest","process","env","NODE_ENV","isRedirectError","redirectUrl","addPathPrefix","getURLFromRedirectError","statusCode","getRedirectStatusCodeFromError","isPermanent","RedirectStatusCode","PermanentRedirect","id","httpEquiv","traceMetaTags","key","value","index","serverInsertedHTML","Array","isArray","stream","renderToReadableStream","progressiveChunkSize","streamToString"],"mappings":";;;;+BAagBA,6BAAAA;;;eAAAA;;;;8DAbgB;oCACU;0BAInC;+BACyB;4BACO;sCACR;oCACI;+BACL;;;;;;AAGvB,SAASA,0BAA0B,EACxCC,SAAS,EACTC,wBAAwB,EACxBC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EAOT;IACC,IAAIC,iCAAiC;IACrC,6DAA6D;IAC7D,IAAIC,sBAAsB;IAE1B,MAAMC,eAAeP,UAAUQ,GAAG,CAAC,CAACC;QAClC,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACC,UAAAA;YAA2B,GAAGD,QAAQ;WAA1BA,SAASE,GAAG;IAClC;IAEA,OAAO,eAAeC;QACpB,kEAAkE;QAClE,WAAW;QACX,MAAMC,gBAAgB,EAAE;QACxB,MAAOR,iCAAiCH,qBAAqBY,MAAM,CAAE;YACnE,MAAMC,QAAQb,oBAAoB,CAACG,+BAA+B;YAClEA;YAEA,IAAIW,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACD,QAAQ;gBACpCF,cAAcI,IAAI,CAAA,WAAA,GAChB,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA;oBAAKC,MAAK;oBAASC,SAAQ;mBAAeL,MAAMM,MAAM,GACvDC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cAAA,WAAA,GACvB,CAAA,GAAA,YAAA,GAAA,EAACN,QAAAA;oBAAKC,MAAK;oBAAaC,SAAQ;mBAAgB,gBAC9C;YAER,OAAO,IAAIK,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;gBACjC,MAAMW,cAAcC,CAAAA,GAAAA,eAAAA,aAAa,EAC/BC,CAAAA,GAAAA,UAAAA,uBAAuB,EAACb,QACxBX;gBAEF,MAAMyB,aAAaC,CAAAA,GAAAA,UAAAA,8BAA8B,EAACf;gBAClD,MAAMgB,cACJF,eAAeG,oBAAAA,kBAAkB,CAACC,iBAAiB,GAAG,OAAO;gBAC/D,IAAIP,aAAa;oBACfb,cAAcI,IAAI,CAAA,WAAA,GAChB,CAAA,GAAA,YAAA,GAAA,EAACC,QAAAA;wBACCgB,IAAG;wBACHC,WAAU;wBACVf,SAAS,GAAGW,cAAc,IAAI,EAAE,KAAK,EAAEL,aAAa;uBAC/CX,MAAMM,MAAM;gBAGvB;YACF;QACF;QAEA,MAAMe,gBAAiBjC,CAAAA,mBAAmB,EAAC,EAAGK,GAAG,CAC/C,CAAC,EAAE6B,GAAG,EAAEC,KAAK,EAAE,EAAEC,QAAAA,WAAAA,GACf,CAAA,GAAA,YAAA,GAAA,EAACrB,QAAAA;gBAAsCC,MAAMkB;gBAAKjB,SAASkB;eAAhD,CAAC,gBAAgB,EAAEC,OAAO;QAIzC,MAAMC,qBAAqBvC;QAE3B,wDAAwD;QACxD,IACEM,aAAaO,MAAM,KAAK,KACxBsB,cAActB,MAAM,KAAK,KACzBD,cAAcC,MAAM,KAAK,KACzB2B,MAAMC,OAAO,CAACF,uBACdA,mBAAmB1B,MAAM,KAAK,GAC9B;YACA,OAAO;QACT;QAEA,MAAM6B,SAAS,MAAMC,CAAAA,GAAAA,YAAAA,sBAAsB,EAAA,WAAA,GACzC,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;gBAEI,0DAA0D,GAC1DtC,sBAAsB,OAAOC;gBAE9BiC;gBACAlC,sBAAsB,OAAO8B;gBAC7BvB;;YAEH;YACE,yDAAyD;YACzD,uBAAuB;YACvBgC,sBAAsB,OAAO;QAC/B;QAGFvC,sBAAsB;QAEtB,qDAAqD;QACrD,qEAAqE;QACrE,oEAAoE;QACpE,OAAOwC,CAAAA,GAAAA,sBAAAA,cAAc,EAACH;IACxB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/render-to-string.tsx"],"sourcesContent":["import { streamToString } from '../stream-utils/node-web-streams-helper'\n\nexport async function renderToString({\n  renderToReadableStream,\n  element,\n}: {\n  // `renderToReadableStream()` method could come from different react-dom/server implementations\n  // such as `react-dom/server.edge` or `react-dom/server.node`, etc.\n  renderToReadableStream: typeof import('react-dom/server.edge').renderToReadableStream\n  element: React.ReactElement\n}): Promise<string> {\n  const renderStream = await renderToReadableStream(element)\n  await renderStream.allReady\n  return streamToString(renderStream)\n}\n"],"names":["renderToString","renderToReadableStream","element","renderStream","allReady","streamToString"],"mappings":";;;;+BAEsBA,kBAAAA;;;eAAAA;;;sCAFS;AAExB,eAAeA,eAAe,EACnCC,sBAAsB,EACtBC,OAAO,EAMR;IACC,MAAMC,eAAe,MAAMF,uBAAuBC;IAClD,MAAMC,aAAaC,QAAQ;IAC3B,OAAOC,CAAAA,GAAAA,sBAAAA,cAAc,EAACF;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/metadata-insertion/create-server-inserted-metadata.tsx"],"sourcesContent":["import React from 'react'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport {\n  ServerInsertedMetadataContext,\n  type MetadataResolver,\n} from '../../../shared/lib/server-inserted-metadata.shared-runtime'\nimport { renderToString } from '../render-to-string'\n\n/**\n * For chromium based browsers (Chrome, Edge, etc.) and Safari,\n * icons need to stay under <head> to be picked up by the browser.\n *\n */\nconst REINSERT_ICON_SCRIPT = `\\\ndocument.querySelectorAll('body link[rel=\"icon\"], body link[rel=\"apple-touch-icon\"]').forEach(el => document.head.appendChild(el))`\n\nexport function createServerInsertedMetadata(nonce: string | undefined) {\n  let metadataResolver: MetadataResolver | null = null\n  let metadataToFlush: React.ReactNode = null\n  const setMetadataResolver = (resolver: MetadataResolver): void => {\n    metadataResolver = resolver\n  }\n\n  return {\n    ServerInsertedMetadataProvider: ({\n      children,\n    }: {\n      children: React.ReactNode\n    }) => {\n      return (\n        <ServerInsertedMetadataContext.Provider value={setMetadataResolver}>\n          {children}\n        </ServerInsertedMetadataContext.Provider>\n      )\n    },\n\n    async getServerInsertedMetadata(): Promise<string> {\n      if (!metadataResolver || metadataToFlush) {\n        return ''\n      }\n\n      metadataToFlush = metadataResolver()\n      const html = await renderToString({\n        renderToReadableStream,\n        element: (\n          <>\n            {metadataToFlush}\n            <script nonce={nonce}>{REINSERT_ICON_SCRIPT}</script>\n          </>\n        ),\n      })\n\n      return html\n    },\n  }\n}\n"],"names":["createServerInsertedMetadata","REINSERT_ICON_SCRIPT","nonce","metadataResolver","metadataToFlush","setMetadataResolver","resolver","ServerInsertedMetadataProvider","children","ServerInsertedMetadataContext","Provider","value","getServerInsertedMetadata","html","renderToString","renderToReadableStream","element","script"],"mappings":";;;;+BAgBgBA,gCAAAA;;;eAAAA;;;;8DAhBE;4BACqB;qDAIhC;gCACwB;;;;;;AAE/B;;;;CAIC,GACD,MAAMC,uBAAuB,CAAC;kIACoG,CAAC;AAE5H,SAASD,6BAA6BE,KAAyB;IACpE,IAAIC,mBAA4C;IAChD,IAAIC,kBAAmC;IACvC,MAAMC,sBAAsB,CAACC;QAC3BH,mBAAmBG;IACrB;IAEA,OAAO;QACLC,gCAAgC,CAAC,EAC/BC,QAAQ,EAGT;YACC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,qCAAAA,6BAA6B,CAACC,QAAQ,EAAA;gBAACC,OAAON;0BAC5CG;;QAGP;QAEA,MAAMI;YACJ,IAAI,CAACT,oBAAoBC,iBAAiB;gBACxC,OAAO;YACT;YAEAA,kBAAkBD;YAClB,MAAMU,OAAO,MAAMC,CAAAA,GAAAA,gBAAAA,cAAc,EAAC;gBAChCC,wBAAAA,YAAAA,sBAAsB;gBACtBC,SAAAA,WAAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;wBACGZ;sCACD,CAAA,GAAA,YAAA,GAAA,EAACa,UAAAA;4BAAOf,OAAOA;sCAAQD;;;;YAG7B;YAEA,OAAOY;QACT;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 764, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type {\n  ExperimentalConfig,\n  NextConfigComplete,\n} from '../../server/config-shared'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { InstrumentationOnRequestError } from '../instrumentation/types'\nimport type { NextRequestHint } from '../web/adapter'\nimport type { BaseNextRequest } from '../base-http'\nimport type { IncomingMessage } from 'http'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nconst dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])\n\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n\nconst segmentSchema = s.union([\n  s.string(),\n  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n])\n\nexport type Segment = s.Infer<typeof segmentSchema>\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(\n    s.nullable(\n      s.union([\n        s.literal('refetch'),\n        s.literal('refresh'),\n        s.literal('inside-shared-layout'),\n      ])\n    )\n  ),\n  s.optional(s.boolean()),\n])\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?: 'refetch' | 'refresh' | 'inside-shared-layout' | null,\n  isRootLayout?: boolean,\n]\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  segment: Segment,\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type ServerOnInstrumentationRequestError = (\n  error: unknown,\n  // The request could be middleware, node server or web server request,\n  // we normalized them into an aligned format to `onRequestError` API later.\n  request: NextRequestHint | BaseNextRequest | IncomingMessage,\n  errorContext: Parameters<InstrumentationOnRequestError>[2]\n) => void | Promise<void>\n\nexport interface RenderOptsPartial {\n  previewProps: __ApiPreviewProps | undefined\n  err?: Error | null\n  dev?: boolean\n  basePath: string\n  trailingSlash: boolean\n  clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  supportsDynamicResponse: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  botType?: 'dom' | 'html' | undefined\n  serveStreamingMetadata?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  cacheLifeProfiles?: {\n    [profile: string]: import('../use-cache/cache-life').CacheLife\n  }\n  setIsrStatus?: (key: string, value: boolean | null) => void\n  isRevalidate?: boolean\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  onInstrumentationRequestError?: ServerOnInstrumentationRequestError\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  htmlLimitedBots: string | undefined\n  experimental: {\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    expireTime: number | undefined\n    staleTimes: ExperimentalConfig['staleTimes'] | undefined\n    clientTraceMetadata: string[] | undefined\n    dynamicIO: boolean\n    clientSegmentCache: boolean | 'client-only'\n    dynamicOnHover: boolean\n    inlineCss: boolean\n    authInterrupts: boolean\n  }\n  postponed?: string\n\n  /**\n   * Should wait for react stream allReady to resolve all suspense boundaries,\n   * in order to perform a full page render.\n   */\n  shouldWaitOnAllReady?: boolean\n\n  /**\n   * The resume data cache that was generated for this partially prerendered\n   * page during dev warmup.\n   */\n  devRenderResumeDataCache?: RenderResumeDataCache\n\n  /**\n   * When true, the page will be rendered using the static rendering to detect\n   * any dynamic API's that would have stopped the page from being fully\n   * statically generated.\n   */\n  isDebugDynamicAccesses?: boolean\n\n  /**\n   * The maximum length of the headers that are emitted by React and added to\n   * the response.\n   */\n  reactMaxHeadersLength: number | undefined\n\n  isStaticGeneration?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n\nexport type PreloadCallbacks = (() => void)[]\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** assetPrefix */\n  p: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** postponed */\n  s: boolean\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n"],"names":["flightRouterStateSchema","dynamicParamTypesSchema","s","enums","segmentSchema","union","string","tuple","record","lazy","optional","nullable","literal","boolean"],"mappings":";;;;+BA8CaA,2BAAAA;;;eAAAA;;;oEA7BC;;;;;;AAed,MAAMC,0BAA0BC,aAAAA,OAAC,CAACC,KAAK,CAAC;IAAC;IAAK;IAAM;IAAM;IAAK;CAAK;AAIpE,MAAMC,gBAAgBF,aAAAA,OAAC,CAACG,KAAK,CAAC;IAC5BH,aAAAA,OAAC,CAACI,MAAM;IACRJ,aAAAA,OAAC,CAACK,KAAK,CAAC;QAACL,aAAAA,OAAC,CAACI,MAAM;QAAIJ,aAAAA,OAAC,CAACI,MAAM;QAAIL;KAAwB;CAC1D;AAOM,MAAMD,0BAA2CE,aAAAA,OAAC,CAACK,KAAK,CAAC;IAC9DH;IACAF,aAAAA,OAAC,CAACM,MAAM,CACNN,aAAAA,OAAC,CAACI,MAAM,IACRJ,aAAAA,OAAC,CAACO,IAAI,CAAC,IAAMT;IAEfE,aAAAA,OAAC,CAACQ,QAAQ,CAACR,aAAAA,OAAC,CAACS,QAAQ,CAACT,aAAAA,OAAC,CAACI,MAAM;IAC9BJ,aAAAA,OAAC,CAACQ,QAAQ,CACRR,aAAAA,OAAC,CAACS,QAAQ,CACRT,aAAAA,OAAC,CAACG,KAAK,CAAC;QACNH,aAAAA,OAAC,CAACU,OAAO,CAAC;QACVV,aAAAA,OAAC,CAACU,OAAO,CAAC;QACVV,aAAAA,OAAC,CAACU,OAAO,CAAC;KACX;IAGLV,aAAAA,OAAC,CAACQ,QAAQ,CAACR,aAAAA,OAAC,CAACW,OAAO;CACrB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/parse-and-validate-flight-router-state.tsx"],"sourcesContent":["import type { FlightRouterState } from './types'\nimport { flightRouterStateSchema } from './types'\nimport { assert } from 'next/dist/compiled/superstruct'\n\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[]\n): FlightRouterState\nexport function parseAndValidateFlightRouterState(\n  stateHeader: undefined\n): undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined\nexport function parseAndValidateFlightRouterState(\n  stateHeader: string | string[] | undefined\n): FlightRouterState | undefined {\n  if (typeof stateHeader === 'undefined') {\n    return undefined\n  }\n  if (Array.isArray(stateHeader)) {\n    throw new Error(\n      'Multiple router state headers were sent. This is not allowed.'\n    )\n  }\n\n  // We limit the size of the router state header to ~40kb. This is to prevent\n  // a malicious user from sending a very large header and slowing down the\n  // resolving of the router state.\n  // This is around 2,000 nested or parallel route segment states:\n  // '{\"children\":[\"\",{}]}'.length === 20.\n  if (stateHeader.length > 20 * 2000) {\n    throw new Error('The router state header was too large.')\n  }\n\n  try {\n    const state = JSON.parse(decodeURIComponent(stateHeader))\n    assert(state, flightRouterStateSchema)\n    return state\n  } catch {\n    throw new Error('The router state header was sent but could not be parsed.')\n  }\n}\n"],"names":["parseAndValidateFlightRouterState","stateHeader","undefined","Array","isArray","Error","length","state","JSON","parse","decodeURIComponent","assert","flightRouterStateSchema"],"mappings":";;;;+BAagBA,qCAAAA;;;eAAAA;;;uBAZwB;6BACjB;AAWhB,SAASA,kCACdC,WAA0C;IAE1C,IAAI,OAAOA,gBAAgB,aAAa;QACtC,OAAOC;IACT;IACA,IAAIC,MAAMC,OAAO,CAACH,cAAc;QAC9B,MAAM,OAAA,cAEL,CAFK,IAAII,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,4EAA4E;IAC5E,yEAAyE;IACzE,iCAAiC;IACjC,gEAAgE;IAChE,wCAAwC;IACxC,IAAIJ,YAAYK,MAAM,GAAG,KAAK,MAAM;QAClC,MAAM,OAAA,cAAmD,CAAnD,IAAID,MAAM,2CAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkD;IAC1D;IAEA,IAAI;QACF,MAAME,QAAQC,KAAKC,KAAK,CAACC,mBAAmBT;QAC5CU,CAAAA,GAAAA,aAAAA,MAAM,EAACJ,OAAOK,OAAAA,uBAAuB;QACrC,OAAOL;IACT,EAAE,OAAM;QACN,MAAM,OAAA,cAAsE,CAAtE,IAAIF,MAAM,8DAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAqE;IAC7E;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 863, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/strip-flight-headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'node:http'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\n\n/**\n * Removes the flight headers from the request.\n *\n * @param req the request to strip the headers from\n */\nexport function stripFlightHeaders(headers: IncomingHttpHeaders) {\n  for (const header of FLIGHT_HEADERS) {\n    delete headers[header.toLowerCase()]\n  }\n}\n"],"names":["stripFlightHeaders","headers","header","FLIGHT_HEADERS","toLowerCase"],"mappings":";;;;+BASgBA,sBAAAA;;;eAAAA;;;kCAPe;AAOxB,SAASA,mBAAmBC,OAA4B;IAC7D,KAAK,MAAMC,UAAUC,kBAAAA,cAAc,CAAE;QACnC,OAAOF,OAAO,CAACC,OAAOE,WAAW,GAAG;IACtC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/csrf-protection.ts"],"sourcesContent":["// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function\n// can be run from edge. This is a simple implementation that safely achieves the required functionality.\n// the goal is to match the functionality for remotePatterns as defined here -\n// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns\n// TODO - retrofit micromatch to work in edge and use that instead\nfunction matchWildcardDomain(domain: string, pattern: string) {\n  const domainParts = domain.split('.')\n  const patternParts = pattern.split('.')\n\n  if (patternParts.length < 1) {\n    // pattern is empty and therefore invalid to match against\n    return false\n  }\n\n  if (domainParts.length < patternParts.length) {\n    // domain has too few segments and thus cannot match\n    return false\n  }\n\n  // Prevent wildcards from matching entire domains (e.g. '**' or '*.com')\n  // This ensures wildcards can only match subdomains, not the main domain\n  if (\n    patternParts.length === 1 &&\n    (patternParts[0] === '*' || patternParts[0] === '**')\n  ) {\n    return false\n  }\n\n  while (patternParts.length) {\n    const patternPart = patternParts.pop()\n    const domainPart = domainParts.pop()\n\n    switch (patternPart) {\n      case '': {\n        // invalid pattern. pattern segments must be non empty\n        return false\n      }\n      case '*': {\n        // wildcard matches anything so we continue if the domain part is non-empty\n        if (domainPart) {\n          continue\n        } else {\n          return false\n        }\n      }\n      case '**': {\n        // if this is not the last item in the pattern the pattern is invalid\n        if (patternParts.length > 0) {\n          return false\n        }\n        // recursive wildcard matches anything so we terminate here if the domain part is non empty\n        return domainPart !== undefined\n      }\n      default: {\n        if (domainPart !== patternPart) {\n          return false\n        }\n      }\n    }\n  }\n\n  // We exhausted the pattern. If we also exhausted the domain we have a match\n  return domainParts.length === 0\n}\n\nexport const isCsrfOriginAllowed = (\n  originDomain: string,\n  allowedOrigins: string[] = []\n): boolean => {\n  return allowedOrigins.some(\n    (allowedOrigin) =>\n      allowedOrigin &&\n      (allowedOrigin === originDomain ||\n        matchWildcardDomain(originDomain, allowedOrigin))\n  )\n}\n"],"names":["isCsrfOriginAllowed","matchWildcardDomain","domain","pattern","domainParts","split","patternParts","length","patternPart","pop","domainPart","undefined","originDomain","allowedOrigins","some","allowedOrigin"],"mappings":"AAAA,uHAAuH;AACvH,yGAAyG;AACzG,8EAA8E;AAC9E,4EAA4E;AAC5E,kEAAkE;;;;;+BA6DrDA,uBAAAA;;;eAAAA;;;AA5Db,SAASC,oBAAoBC,MAAc,EAAEC,OAAe;IAC1D,MAAMC,cAAcF,OAAOG,KAAK,CAAC;IACjC,MAAMC,eAAeH,QAAQE,KAAK,CAAC;IAEnC,IAAIC,aAAaC,MAAM,GAAG,GAAG;QAC3B,0DAA0D;QAC1D,OAAO;IACT;IAEA,IAAIH,YAAYG,MAAM,GAAGD,aAAaC,MAAM,EAAE;QAC5C,oDAAoD;QACpD,OAAO;IACT;IAEA,wEAAwE;IACxE,wEAAwE;IACxE,IACED,aAAaC,MAAM,KAAK,KACvBD,CAAAA,YAAY,CAAC,EAAE,KAAK,OAAOA,YAAY,CAAC,EAAE,KAAK,IAAG,GACnD;QACA,OAAO;IACT;IAEA,MAAOA,aAAaC,MAAM,CAAE;QAC1B,MAAMC,cAAcF,aAAaG,GAAG;QACpC,MAAMC,aAAaN,YAAYK,GAAG;QAElC,OAAQD;YACN,KAAK;gBAAI;oBACP,sDAAsD;oBACtD,OAAO;gBACT;YACA,KAAK;gBAAK;oBACR,2EAA2E;oBAC3E,IAAIE,YAAY;wBACd;oBACF,OAAO;wBACL,OAAO;oBACT;gBACF;YACA,KAAK;gBAAM;oBACT,qEAAqE;oBACrE,IAAIJ,aAAaC,MAAM,GAAG,GAAG;wBAC3B,OAAO;oBACT;oBACA,2FAA2F;oBAC3F,OAAOG,eAAeC;gBACxB;YACA;gBAAS;oBACP,IAAID,eAAeF,aAAa;wBAC9B,OAAO;oBACT;gBACF;QACF;IACF;IAEA,4EAA4E;IAC5E,OAAOJ,YAAYG,MAAM,KAAK;AAChC;AAEO,MAAMP,sBAAsB,CACjCY,cACAC,iBAA2B,EAAE;IAE7B,OAAOA,eAAeC,IAAI,CACxB,CAACC,gBACCA,iBACCA,CAAAA,kBAAkBH,gBACjBX,oBAAoBW,cAAcG,cAAa;AAEvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 961, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/action-async-storage-instance.ts"],"sourcesContent":["import type { ActionAsyncStorage } from './action-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const actionAsyncStorageInstance: ActionAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["actionAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;;+BAGaA,8BAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,6BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 978, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/flight-render-result.ts"],"sourcesContent":["import { RSC_CONTENT_TYPE_HEADER } from '../../client/components/app-router-headers'\nimport RenderResult, { type RenderResultMetadata } from '../render-result'\n\n/**\n * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.\n */\nexport class FlightRenderResult extends RenderResult {\n  constructor(\n    response: string | ReadableStream<Uint8Array>,\n    metadata: RenderResultMetadata = {}\n  ) {\n    super(response, { contentType: RSC_CONTENT_TYPE_HEADER, metadata })\n  }\n}\n"],"names":["FlightRenderResult","RenderResult","constructor","response","metadata","contentType","RSC_CONTENT_TYPE_HEADER"],"mappings":";;;;+BAMaA,sBAAAA;;;eAAAA;;;kCAN2B;qEACgB;;;;;;AAKjD,MAAMA,2BAA2BC,cAAAA,OAAY;IAClDC,YACEC,QAA6C,EAC7CC,WAAiC,CAAC,CAAC,CACnC;QACA,KAAK,CAACD,UAAU;YAAEE,aAAaC,kBAAAA,uBAAuB;YAAEF;QAAS;IACnE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1008, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/react-server.node.ts"],"sourcesContent":["// This file should be opted into the react-server layer\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport {\n  createTemporaryReferenceSet,\n  decodeReply,\n  decodeReplyFromBusboy,\n  decodeAction,\n  decodeFormState,\n} from 'react-server-dom-webpack/server.node'\n"],"names":["createTemporaryReferenceSet","decodeAction","decodeFormState","decodeReply","decodeReplyFromBusboy"],"mappings":"AAAA,wDAAwD;AAExD,6DAA6D;;;;;;;;;;;;;;;;;;;IAE3DA,2BAA2B,EAAA;eAA3BA,YAAAA,2BAA2B;;IAG3BC,YAAY,EAAA;eAAZA,YAAAA,YAAY;;IACZC,eAAe,EAAA;eAAfA,YAAAA,eAAe;;IAHfC,WAAW,EAAA;eAAXA,YAAAA,WAAW;;IACXC,qBAAqB,EAAA;eAArBA,YAAAA,qBAAqB;;;4BAGhB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'node:http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport { selectWorkerForForwarding } from './action-utils'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server.edge'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { executeRevalidates } from '../revalidation-utils'\n\nfunction formDataFromSearchQueryString(query: string) {\n  const searchParams = new URLSearchParams(query)\n  const formData = new FormData()\n  for (const [key, value] of searchParams) {\n    formData.append(key, value)\n  }\n  return formData\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nfunction addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // To keep the header size small, we use a tuple of\n  // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]\n  // instead of a JSON object.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.pendingRevalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  res.setHeader(\n    'x-action-revalidated',\n    JSON.stringify([[], isTagRevalidated, isCookieRevalidated])\n  )\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string,\n  workStore: WorkStore\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string\n): URL | null {\n  if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {\n    // Make sure we are appending the basePath to relative URLS\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.pendingRevalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.pendingRevalidatedTags.join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\nexport function parseHostHeader(\n  headers: IncomingHttpHeaders,\n  originDomain?: string\n) {\n  const forwardedHostHeader = headers['x-forwarded-host']\n  const forwardedHostHeaderValue =\n    forwardedHostHeader && Array.isArray(forwardedHostHeader)\n      ? forwardedHostHeader[0]\n      : forwardedHostHeader?.split(',')?.[0]?.trim()\n  const hostHeader = headers['host']\n\n  if (originDomain) {\n    return forwardedHostHeaderValue === originDomain\n      ? {\n          type: HostType.XForwardedHost,\n          value: forwardedHostHeaderValue,\n        }\n      : hostHeader === originDomain\n        ? {\n            type: HostType.Host,\n            value: hostHeader,\n          }\n        : undefined\n  }\n\n  return forwardedHostHeaderValue\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeaderValue,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n}\n\ntype ServerModuleMap = Record<\n  string,\n  {\n    id: string\n    chunks: string[]\n    name: string\n  }\n>\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  serverModuleMap,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  serverModuleMap: ServerModuleMap\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n}): Promise<\n  | undefined\n  | {\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n> {\n  const contentType = req.headers['content-type']\n  const { serverActionsManifest, page } = ctx.renderOpts\n\n  const {\n    actionId,\n    isURLEncodedAction,\n    isMultipartAction,\n    isFetchAction,\n    isPossibleServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  // If it can't be a Server Action, skip handling.\n  // Note that this can be a false positive -- any multipart/urlencoded POST can get us here,\n  // But won't know if it's an MPA action or not until we call `decodeAction` below.\n  if (!isPossibleServerAction) {\n    return\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  const finalizeAndGenerateFlight: GenerateFlight = (...args) => {\n    // When we switch to the render phase, cookies() will return\n    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n    // We want the render to see any cookie writes that we performed during the action,\n    // so we need to update the immutable cookies to reflect the changes.\n    synchronizeMutableCookies(requestStore)\n\n    // The server action might have toggled draft mode, so we need to reflect\n    // that in the work store to be up-to-date for subsequent rendering.\n    workStore.isDraftMode = requestStore.draftMode.isEnabled\n\n    return generateFlight(...args)\n  }\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originDomain =\n    typeof req.headers['origin'] === 'string'\n      ? new URL(req.headers['origin']).host\n      : undefined\n  const host = parseHostHeader(req.headers)\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        await executeRevalidates(workStore)\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // if the page was not revalidated, we can skip the rendering the flight tree\n            skipFlight: !workStore.pathWasRevalidated,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  let boundActionArguments: unknown[] = []\n\n  const { actionAsyncStorage } = ComponentMod\n\n  let actionResult: RenderResult | undefined\n  let formState: any | undefined\n  let actionModId: string | undefined\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(\n      actionId,\n      page,\n      serverActionsManifest\n    )\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath,\n          workStore\n        ),\n      }\n    }\n  }\n\n  try {\n    await actionAsyncStorage.run({ isAction: true }, async () => {\n      if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' &&\n        isWebNextRequest(req)\n      ) {\n        if (!req.body) {\n          throw new Error('invariant: Missing request body.')\n        }\n\n        // TODO: add body limit\n\n        // Use react-server-dom-webpack/server.edge\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeAction,\n          decodeFormState,\n        } = ComponentMod\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        if (isMultipartAction) {\n          // TODO-APP: Add streaming support\n          const formData = await req.request.formData()\n          if (isFetchAction) {\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              let actionReturnedState: unknown\n              requestStore.phase = 'action'\n              try {\n                actionReturnedState = await workUnitAsyncStorage.run(\n                  requestStore,\n                  action\n                )\n              } finally {\n                requestStore.phase = 'render'\n              }\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          const reader = req.body.getReader()\n          while (true) {\n            const { done, value } = await reader.read()\n            if (done) {\n              break\n            }\n\n            chunks.push(value)\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        isNodeNextRequest(req)\n      ) {\n        // Use react-server-dom-webpack/server.node which supports streaming\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeReplyFromBusboy,\n          decodeAction,\n          decodeFormState,\n        } = require(\n          `./react-server.node`\n        ) as typeof import('./react-server.node')\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        const { Transform } =\n          require('node:stream') as typeof import('node:stream')\n\n        const defaultBodySizeLimit = '1 MB'\n        const bodySizeLimit =\n          serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n        const bodySizeLimitBytes =\n          bodySizeLimit !== defaultBodySizeLimit\n            ? (\n                require('next/dist/compiled/bytes') as typeof import('bytes')\n              ).parse(bodySizeLimit)\n            : 1024 * 1024 // 1 MB\n\n        let size = 0\n        const body = req.body.pipe(\n          new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } = require('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\n                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n        )\n\n        if (isMultipartAction) {\n          if (isFetchAction) {\n            const busboy = (require('busboy') as typeof import('busboy'))({\n              defParamCharset: 'utf8',\n              headers: req.headers,\n              limits: { fieldSize: bodySizeLimitBytes },\n            })\n\n            body.pipe(busboy)\n\n            boundActionArguments = await decodeReplyFromBusboy(\n              busboy,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            // React doesn't yet publish a busboy version of decodeAction\n            // so we polyfill the parsing of FormData.\n            const fakeRequest = new Request('http://localhost', {\n              method: 'POST',\n              // @ts-expect-error\n              headers: { 'Content-Type': contentType },\n              body: new ReadableStream({\n                start: (controller) => {\n                  body.on('data', (chunk) => {\n                    controller.enqueue(new Uint8Array(chunk))\n                  })\n                  body.on('end', () => {\n                    controller.close()\n                  })\n                  body.on('error', (err) => {\n                    controller.error(err)\n                  })\n                },\n              }),\n              duplex: 'half',\n            })\n            const formData = await fakeRequest.formData()\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n\n              let actionReturnedState: unknown\n              requestStore.phase = 'action'\n              try {\n                actionReturnedState = await workUnitAsyncStorage.run(\n                  requestStore,\n                  action\n                )\n              } finally {\n                requestStore.phase = 'render'\n              }\n\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          for await (const chunk of req.body) {\n            chunks.push(Buffer.from(chunk))\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          if (isURLEncodedAction) {\n            const formData = formDataFromSearchQueryString(actionData)\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            boundActionArguments = await decodeReply(\n              actionData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          }\n        }\n      } else {\n        throw new Error('Invariant: Unknown request type.')\n      }\n\n      // actions.js\n      // app/page.js\n      //   action worker1\n      //     appRender1\n\n      // app/foo/page.js\n      //   action worker2\n      //     appRender\n\n      // / -> fire action -> POST / -> appRender1 -> modId for the action file\n      // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n      try {\n        actionModId =\n          actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n      } catch (err) {\n        if (actionId !== null) {\n          console.error(err)\n        }\n        return {\n          type: 'not-found',\n        }\n      }\n\n      const actionMod = (await ComponentMod.__next_app__.require(\n        actionModId\n      )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n      const actionHandler =\n        actionMod[\n          // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n          actionId!\n        ]\n\n      let returnVal: unknown\n      requestStore.phase = 'action'\n      try {\n        returnVal = await workUnitAsyncStorage.run(requestStore, () =>\n          actionHandler.apply(null, boundActionArguments)\n        )\n      } finally {\n        requestStore.phase = 'render'\n      }\n\n      // For form actions, we need to continue rendering the page.\n      if (isFetchAction) {\n        await executeRevalidates(workStore)\n        addRevalidationHeader(res, { workStore, requestStore })\n\n        actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n          actionResult: Promise.resolve(returnVal),\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        })\n      }\n    })\n\n    return {\n      type: 'done',\n      result: actionResult,\n      formState,\n    }\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      await executeRevalidates(workStore)\n      addRevalidationHeader(res, { workStore, requestStore })\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore\n          ),\n        }\n      }\n\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.fromStatic(''),\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n\n      await executeRevalidates(workStore)\n      addRevalidationHeader(res, { workStore, requestStore })\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            skipFlight: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n      return {\n        type: 'not-found',\n      }\n    }\n\n    if (isFetchAction) {\n      res.statusCode = 500\n      await executeRevalidates(workStore)\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    throw err\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string {\n  // if we're missing the action ID header, we can't do any further processing\n  if (!actionId) {\n    throw new InvariantError(\"Missing 'next-action' header.\")\n  }\n\n  const actionModId = serverModuleMap[actionId]?.id\n\n  if (!actionModId) {\n    throw new Error(\n      `Failed to find Server Action \"${actionId}\". This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  return actionModId\n}\n"],"names":["handleAction","parseHostHeader","formDataFromSearchQueryString","query","searchParams","URLSearchParams","formData","FormData","key","value","append","nodeHeadersToRecord","headers","record","Object","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","RequestCookies","HeadersAdapter","from","responseHeaders","getHeaders","responseCookies","ResponseCookies","fromNodeOutgoingHttpHeaders","mergedHeaders","filterReqHeaders","actionsForbiddenHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","isTagRevalidated","pendingRevalidatedTags","length","isCookieRevalidated","getModifiedCookieValues","mutableCookies","setHeader","JSON","stringify","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","incrementalCache","requestProtocol","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","isWebNextRequest","isNodeNextRequest","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","RSC_CONTENT_TYPE_HEADER","includes","FlightRenderResult","cancel","err","console","error","RenderResult","fromStatic","getAppRelativeRedirectUrl","redirectUrl","parsedRedirectUrl","pathname","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","RSC_HEADER","search","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","prerenderManifest","preview","previewModeId","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","limitUntrustedHeaderValueForLogs","slice","originDomain","forwardedHostHeader","forwardedHostHeaderValue","split","trim","hostHeader","type","ComponentMod","serverModuleMap","generateFlight","serverActions","ctx","contentType","serverActionsManifest","page","renderOpts","actionId","isURLEncodedAction","isMultipartAction","isFetchAction","isPossibleServerAction","getServerActionRequestMetadata","isStaticGeneration","temporaryReferences","finalizeAndGenerateFlight","args","synchronizeMutableCookies","isDraftMode","draftMode","isEnabled","fetchCache","warning","warnBadServerActionRequest","warn","isCsrfOriginAllowed","allowedOrigins","statusCode","executeRevalidates","promise","Promise","reject","result","actionResult","skipFlight","pathWasRevalidated","boundActionArguments","actionAsyncStorage","formState","actionModId","actionWasForwarded","Boolean","forwardedWorker","selectWorkerForForwarding","run","isAction","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","request","action","actionReturnedState","phase","workUnitAsyncStorage","getActionModIdOrError","chunks","reader","getReader","done","read","push","actionData","Buffer","concat","decodeReplyFromBusboy","require","Transform","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","pipe","transform","chunk","encoding","callback","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","fakeRequest","Request","ReadableStream","start","controller","on","enqueue","Uint8Array","close","actionMod","__next_app__","actionHandler","returnVal","apply","resolve","isRedirectError","getURLFromRedirectError","getRedirectTypeFromError","RedirectStatusCode","SeeOther","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","InvariantError","id"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1727, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts"],"sourcesContent":["import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["afterTaskAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;;+BAGaA,iCAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,gCACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/app-render-prerender-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function prerenderAndAbortInSequentialTasks<R>(\n  prerender: () => Promise<R>,\n  abort: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = prerender()\n          pendingResult.catch(() => {})\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        abort()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult>\nexport function prerenderServerWithPhases(\n  signal: AbortSignal,\n  render: () => ReadableStream<Uint8Array>,\n  ...remainingPhases: Array<() => void>\n): Promise<ServerPrerenderStreamResult> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let result: ServerPrerenderStreamResult\n\n      signal.addEventListener(\n        'abort',\n        () => {\n          if (isPrerenderInterruptedError(signal.reason)) {\n            result.markInterrupted()\n          } else {\n            result.markComplete()\n          }\n        },\n        {\n          once: true,\n        }\n      )\n\n      setImmediate(() => {\n        try {\n          result = new ServerPrerenderStreamResult(render())\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          if (result) {\n            result.markComplete()\n            this()\n          }\n          resolve(result)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          if (result) {\n            result.markPhase()\n            this()\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\nconst PENDING = 0\nconst COMPLETE = 1\nconst INTERRUPTED = 2\nconst ERRORED = 3\n\nexport class ServerPrerenderStreamResult {\n  private currentChunks: Array<Uint8Array>\n  private chunksByPhase: Array<Array<Uint8Array>>\n  private trailingChunks: Array<Uint8Array>\n  private status: 0 | 1 | 2 | 3\n  private reason: null | unknown\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this.status = PENDING\n    this.reason = null\n\n    this.trailingChunks = []\n    this.currentChunks = []\n    this.chunksByPhase = [this.currentChunks]\n\n    const reader = stream.getReader()\n\n    const progress = ({\n      done,\n      value,\n    }: ReadableStreamReadResult<Uint8Array>) => {\n      if (done) {\n        if (this.status === PENDING) {\n          this.status = COMPLETE\n        }\n        return\n      }\n      if (this.status === PENDING || this.status === INTERRUPTED) {\n        this.currentChunks.push(value)\n      } else {\n        this.trailingChunks.push(value)\n      }\n      reader.read().then(progress, error)\n    }\n    const error = (reason: unknown) => {\n      this.status = ERRORED\n      this.reason = reason\n    }\n\n    reader.read().then(progress, error)\n  }\n\n  markPhase() {\n    this.currentChunks = []\n    this.chunksByPhase.push(this.currentChunks)\n  }\n\n  markComplete() {\n    if (this.status === PENDING) {\n      this.status = COMPLETE\n    }\n  }\n\n  markInterrupted() {\n    this.status = INTERRUPTED\n  }\n\n  /**\n   * Returns a stream which only releases chunks when `releasePhase` is called. This stream will never \"complete\" because\n   * we rely upon the stream remaining open when prerendering to avoid triggering errors for incomplete chunks in the client.\n   *\n   * asPhasedStream is expected to be called once per result however it is safe to call multiple times as long as we have not\n   * transferred the underlying data. Generally this will only happen when streaming to a response\n   */\n  asPhasedStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        return new PhasedStream(this.chunksByPhase)\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n\n  /**\n   * Returns a stream which will release all chunks immediately. This stream will \"complete\" synchronously. It should be used outside\n   * of render use cases like loading client chunks ahead of SSR or writing the streamed content to disk.\n   */\n  asStream() {\n    switch (this.status) {\n      case COMPLETE:\n      case INTERRUPTED:\n        const chunksByPhase = this.chunksByPhase\n        const trailingChunks = this.trailingChunks\n        return new ReadableStream({\n          start(controller) {\n            for (let i = 0; i < chunksByPhase.length; i++) {\n              const chunks = chunksByPhase[i]\n              for (let j = 0; j < chunks.length; j++) {\n                controller.enqueue(chunks[j])\n              }\n            }\n            for (let i = 0; i < trailingChunks.length; i++) {\n              controller.enqueue(trailingChunks[i])\n            }\n            controller.close()\n          },\n        })\n      default:\n        throw new InvariantError(\n          `ServerPrerenderStreamResult cannot be consumed as a stream because it is not yet complete. status: ${this.status}`\n        )\n    }\n  }\n}\n\nclass PhasedStream<T> extends ReadableStream<T> {\n  private nextPhase: number\n  private chunksByPhase: Array<Array<T>>\n  private destination: ReadableStreamDefaultController<T>\n\n  constructor(chunksByPhase: Array<Array<T>>) {\n    if (chunksByPhase.length === 0) {\n      throw new InvariantError(\n        'PhasedStream expected at least one phase but none were found.'\n      )\n    }\n\n    let destination: ReadableStreamDefaultController<T>\n    super({\n      start(controller) {\n        destination = controller\n      },\n    })\n\n    // the start function above is called synchronously during construction so we will always have a destination\n    // We wait to assign it until after the super call because we cannot access `this` before calling super\n    this.destination = destination!\n    this.nextPhase = 0\n    this.chunksByPhase = chunksByPhase\n    this.releasePhase()\n  }\n\n  releasePhase() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      const chunks = this.chunksByPhase[this.nextPhase++]\n      for (let i = 0; i < chunks.length; i++) {\n        this.destination.enqueue(chunks[i])\n      }\n    } else {\n      throw new InvariantError(\n        'PhasedStream expected more phases to release but none were found.'\n      )\n    }\n  }\n\n  assertExhausted() {\n    if (this.nextPhase < this.chunksByPhase.length) {\n      throw new InvariantError(\n        'PhasedStream expected no more phases to release but some were found.'\n      )\n    }\n  }\n}\n\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  finalPhase: () => void\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  secondPhase: () => void,\n  thirdPhase: () => void,\n  ...remainingPhases: Array<() => void>\n): Promise<T>\nexport function prerenderClientWithPhases<T>(\n  render: () => Promise<T>,\n  ...remainingPhases: Array<() => void>\n): Promise<T> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`prerenderAndAbortInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: Promise<T>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n          pendingResult.catch((err) => reject(err))\n        } catch (err) {\n          reject(err)\n        }\n      })\n\n      function runFinalTask(this: () => void) {\n        try {\n          this()\n          resolve(pendingResult)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      function runNextTask(this: () => void) {\n        try {\n          this()\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      let i = 0\n      for (; i < remainingPhases.length - 1; i++) {\n        const phase = remainingPhases[i]\n        setImmediate(runNextTask.bind(phase))\n      }\n      if (remainingPhases[i]) {\n        const finalPhase = remainingPhases[i]\n        setImmediate(runFinalTask.bind(finalPhase))\n      }\n    })\n  }\n}\n\n// React's RSC prerender function will emit an incomplete flight stream when using `prerender`. If the connection\n// closes then whatever hanging chunks exist will be errored. This is because prerender (an experimental feature)\n// has not yet implemented a concept of resume. For now we will simulate a paused connection by wrapping the stream\n// in one that doesn't close even when the underlying is complete.\nexport class ReactServerResult {\n  private _stream: null | ReadableStream<Uint8Array>\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    this._stream = stream\n  }\n\n  tee() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot tee a ReactServerResult that has already been consumed'\n      )\n    }\n    const tee = this._stream.tee()\n    this._stream = tee[0]\n    return tee[1]\n  }\n\n  consume() {\n    if (this._stream === null) {\n      throw new Error(\n        'Cannot consume a ReactServerResult that has already been consumed'\n      )\n    }\n    const stream = this._stream\n    this._stream = null\n    return stream\n  }\n}\n\nexport type ReactServerPrerenderResolveToType = {\n  prelude: ReadableStream<Uint8Array>\n}\n\nexport async function createReactServerPrerenderResult(\n  underlying: Promise<ReactServerPrerenderResolveToType>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const { prelude } = await underlying\n  const reader = prelude.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      return new ReactServerPrerenderResult(chunks)\n    } else {\n      chunks.push(value)\n    }\n  }\n}\n\nexport async function createReactServerPrerenderResultFromRender(\n  underlying: ReadableStream<Uint8Array>\n): Promise<ReactServerPrerenderResult> {\n  const chunks: Array<Uint8Array> = []\n  const reader = underlying.getReader()\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    } else {\n      chunks.push(value)\n    }\n  }\n  return new ReactServerPrerenderResult(chunks)\n}\nexport class ReactServerPrerenderResult {\n  private _chunks: null | Array<Uint8Array>\n\n  private assertChunks(expression: string): Array<Uint8Array> {\n    if (this._chunks === null) {\n      throw new InvariantError(\n        `Cannot \\`${expression}\\` on a ReactServerPrerenderResult that has already been consumed.`\n      )\n    }\n    return this._chunks\n  }\n\n  private consumeChunks(expression: string): Array<Uint8Array> {\n    const chunks = this.assertChunks(expression)\n    this.consume()\n    return chunks\n  }\n\n  consume(): void {\n    this._chunks = null\n  }\n\n  constructor(chunks: Array<Uint8Array>) {\n    this._chunks = chunks\n  }\n\n  asUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  consumeAsUnclosingStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsUnclosingStream()')\n    return createUnclosingStream(chunks)\n  }\n\n  asStream(): ReadableStream<Uint8Array> {\n    const chunks = this.assertChunks('asStream()')\n    return createClosingStream(chunks)\n  }\n\n  consumeAsStream(): ReadableStream<Uint8Array> {\n    const chunks = this.consumeChunks('consumeAsStream()')\n    return createClosingStream(chunks)\n  }\n}\n\nfunction createUnclosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      }\n      // we intentionally keep the stream open. The consumer will clear\n      // out chunks once finished and the remaining memory will be GC'd\n      // when this object goes out of scope\n    },\n  })\n}\n\nfunction createClosingStream(\n  chunks: Array<Uint8Array>\n): ReadableStream<Uint8Array> {\n  let i = 0\n  return new ReadableStream({\n    async pull(controller) {\n      if (i < chunks.length) {\n        controller.enqueue(chunks[i++])\n      } else {\n        controller.close()\n      }\n    },\n  })\n}\n"],"names":["ReactServerPrerenderResult","ReactServerResult","ServerPrerenderStreamResult","createReactServerPrerenderResult","createReactServerPrerenderResultFromRender","prerenderAndAbortInSequentialTasks","prerenderClientWithPhases","prerenderServerWithPhases","prerender","abort","process","env","NEXT_RUNTIME","InvariantError","Promise","resolve","reject","pendingResult","setImmediate","catch","err","signal","render","remainingPhases","result","addEventListener","isPrerenderInterruptedError","reason","markInterrupted","markComplete","once","runFinalTask","runNextTask","markPhase","i","length","phase","bind","finalPhase","PENDING","COMPLETE","INTERRUPTED","ERRORED","constructor","stream","status","trailingChunks","currentChunks","chunksByPhase","reader","getReader","progress","done","value","push","read","then","error","asPhasedStream","PhasedStream","asStream","ReadableStream","start","controller","chunks","j","enqueue","close","destination","nextPhase","releasePhase","assertExhausted","_stream","tee","Error","consume","underlying","prelude","assertChunks","expression","_chunks","consumeChunks","asUnclosingStream","createUnclosingStream","consumeAsUnclosingStream","createClosingStream","consumeAsStream","pull"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/app-render-render-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport function scheduleInSequentialTasks<R>(\n  render: () => R | Promise<R>,\n  followup: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`scheduleInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: R | Promise<R>\n      setImmediate(() => {\n        try {\n          pendingResult = render()\n        } catch (err) {\n          reject(err)\n        }\n      })\n      setImmediate(() => {\n        followup()\n        resolve(pendingResult)\n      })\n    })\n  }\n}\n"],"names":["scheduleInSequentialTasks","render","followup","process","env","NEXT_RUNTIME","InvariantError","Promise","resolve","reject","pendingResult","setImmediate","err"],"mappings":";;;;+BAMgBA,6BAAAA;;;eAAAA;;;gCANe;AAMxB,SAASA,0BACdC,MAA4B,EAC5BC,QAAoB;IAEpB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;IAIzC,OAAO;QACL,OAAO,IAAIE,QAAQ,CAACC,SAASC;YAC3B,IAAIC;YACJC,aAAa;gBACX,IAAI;oBACFD,gBAAgBT;gBAClB,EAAE,OAAOW,KAAK;oBACZH,OAAOG;gBACT;YACF;YACAD,aAAa;gBACXT;gBACAM,QAAQE;YACV;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2212, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/create-error-handler.tsx"],"sourcesContent":["import type { ErrorInfo } from 'react'\n\nimport stringHash from 'next/dist/compiled/string-hash'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createFlightReactServerErrorHandler(\n  shouldFormatError: boolean,\n  onReactServerRenderError: (err: DigestedError) => void\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + err.stack || '').toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Record exception in an active span, if available.\n    const span = getTracer().getActiveScopeSpan()\n    if (span) {\n      span.recordException(err)\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      })\n    }\n\n    onReactServerRenderError(err)\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  silenceLogger: boolean,\n  onReactServerRenderError: undefined | ((err: DigestedError) => void)\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + (err.stack || '')).toString()\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (!silenceLogger) {\n        onReactServerRenderError?.(err)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  silenceLogger: boolean,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = stringHash(\n        err.message + (errorInfo?.componentStack || err.stack || '')\n      ).toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (\n        !silenceLogger &&\n        // HTML errors contain RSC errors as well, filter them out before reporting\n        isSSRError\n      ) {\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n"],"names":["createFlightReactServerErrorHandler","createHTMLErrorHandler","createHTMLReactServerErrorHandler","getDigestForWellKnownError","isUserLandError","error","isBailoutToCSRError","digest","isNextRouterError","isDynamicServerError","undefined","shouldFormatError","onReactServerRenderError","thrownValue","stringHash","toString","isAbortError","err","getProperError","message","stack","formatServerError","span","getTracer","getActiveScopeSpan","recordException","setStatus","code","SpanStatusCode","ERROR","createDigestWithErrorCode","isNextExport","reactServerErrors","silenceLogger","has","set","includes","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","get","componentStack"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2413, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type { DynamicParamTypes, DynamicParamTypesShort } from './types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted': 'ci',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted': 'di',\n}\n\n/**\n * Shorten the dynamic param in order to make it smaller when transmitted to the browser.\n */\nexport function getShortDynamicParamType(\n  type: DynamicParamTypes\n): DynamicParamTypesShort {\n  const short = dynamicParamTypes[type]\n  if (!short) {\n    throw new Error('Unknown dynamic param type')\n  }\n  return short\n}\n"],"names":["dynamicParamTypes","getShortDynamicParamType","catchall","dynamic","type","short","Error"],"mappings":";;;;;;;;;;;;;;;IAEaA,iBAAiB,EAAA;eAAjBA;;IAcGC,wBAAwB,EAAA;eAAxBA;;;AAdT,MAAMD,oBAGT;IACFE,UAAU;IACV,wBAAwB;IACxB,qBAAqB;IACrBC,SAAS;IACT,uBAAuB;AACzB;AAKO,SAASF,yBACdG,IAAuB;IAEvB,MAAMC,QAAQL,iBAAiB,CAACI,KAAK;IACrC,IAAI,CAACC,OAAO;QACV,MAAM,OAAA,cAAuC,CAAvC,IAAIC,MAAM,+BAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAsC;IAC9C;IACA,OAAOD;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2458, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-script-nonce-from-header.tsx"],"sourcesContent":["import { ESCAPE_REGEX } from '../htmlescape'\n\nexport function getScriptNonceFromHeader(\n  cspHeaderValue: string\n): string | undefined {\n  const directives = cspHeaderValue\n    // Directives are split by ';'.\n    .split(';')\n    .map((directive) => directive.trim())\n\n  // First try to find the directive for the 'script-src', otherwise try to\n  // fallback to the 'default-src'.\n  const directive =\n    directives.find((dir) => dir.startsWith('script-src')) ||\n    directives.find((dir) => dir.startsWith('default-src'))\n\n  // If no directive could be found, then we're done.\n  if (!directive) {\n    return\n  }\n\n  // Extract the nonce from the directive\n  const nonce = directive\n    .split(' ')\n    // Remove the 'strict-src'/'default-src' string, this can't be the nonce.\n    .slice(1)\n    .map((source) => source.trim())\n    // Find the first source with the 'nonce-' prefix.\n    .find(\n      (source) =>\n        source.startsWith(\"'nonce-\") &&\n        source.length > 8 &&\n        source.endsWith(\"'\")\n    )\n    // Grab the nonce by trimming the 'nonce-' prefix.\n    ?.slice(7, -1)\n\n  // If we could't find the nonce, then we're done.\n  if (!nonce) {\n    return\n  }\n\n  // Don't accept the nonce value if it contains HTML escape characters.\n  // Technically, the spec requires a base64'd value, but this is just an\n  // extra layer.\n  if (ESCAPE_REGEX.test(nonce)) {\n    throw new Error(\n      'Nonce value from Content-Security-Policy contained HTML escape characters.\\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters'\n    )\n  }\n\n  return nonce\n}\n"],"names":["getScriptNonceFromHeader","cspHeaderValue","directive","directives","split","map","trim","find","dir","startsWith","nonce","slice","source","length","endsWith","ESCAPE_REGEX","test","Error"],"mappings":";;;;+BAEgBA,4BAAAA;;;eAAAA;;;4BAFa;AAEtB,SAASA,yBACdC,cAAsB;QAmBRC;IAjBd,MAAMC,aAAaF,eACjB,+BAA+B;KAC9BG,KAAK,CAAC,KACNC,GAAG,CAAC,CAACH,YAAcA,UAAUI,IAAI;IAEpC,yEAAyE;IACzE,iCAAiC;IACjC,MAAMJ,YACJC,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC,kBACxCN,WAAWI,IAAI,CAAC,CAACC,MAAQA,IAAIC,UAAU,CAAC;IAE1C,mDAAmD;IACnD,IAAI,CAACP,WAAW;QACd;IACF;IAEA,uCAAuC;IACvC,MAAMQ,QAAAA,CAAQR,kCAAAA,UACXE,KAAK,CAAC,KACP,yEAAyE;KACxEO,KAAK,CAAC,GACNN,GAAG,CAAC,CAACO,SAAWA,OAAON,IAAI,IAC5B,kDAAkD;KACjDC,IAAI,CACH,CAACK,SACCA,OAAOH,UAAU,CAAC,cAClBG,OAAOC,MAAM,GAAG,KAChBD,OAAOE,QAAQ,CAAC,KAAA,KAAA,OAAA,KAAA,IAVRZ,gCAaVS,KAAK,CAAC,GAAG,CAAC;IAEd,iDAAiD;IACjD,IAAI,CAACD,OAAO;QACV;IACF;IAEA,sEAAsE;IACtE,uEAAuE;IACvE,eAAe;IACf,IAAIK,YAAAA,YAAY,CAACC,IAAI,CAACN,QAAQ;QAC5B,MAAM,OAAA,cAEL,CAFK,IAAIO,MACR,gKADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,OAAOP;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2505, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/create-flight-router-state-from-loader-tree.ts"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\nimport type { FlightRouterState } from './types'\nimport type { GetDynamicParamFromSegment } from './app-render'\nimport { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\n\nexport function createFlightRouterStateFromLoaderTree(\n  [segment, parallelRoutes, { layout }]: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n  searchParams: any,\n  rootLayoutIncluded = false\n): FlightRouterState {\n  const dynamicParam = getDynamicParamFromSegment(segment)\n  const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment\n\n  const segmentTree: FlightRouterState = [\n    addSearchParamsIfPageSegment(treeSegment, searchParams),\n    {},\n  ]\n\n  if (!rootLayoutIncluded && typeof layout !== 'undefined') {\n    rootLayoutIncluded = true\n    segmentTree[4] = true\n  }\n\n  segmentTree[1] = Object.keys(parallelRoutes).reduce(\n    (existingValue, currentValue) => {\n      existingValue[currentValue] = createFlightRouterStateFromLoaderTree(\n        parallelRoutes[currentValue],\n        getDynamicParamFromSegment,\n        searchParams,\n        rootLayoutIncluded\n      )\n      return existingValue\n    },\n    {} as FlightRouterState[1]\n  )\n\n  return segmentTree\n}\n"],"names":["createFlightRouterStateFromLoaderTree","segment","parallelRoutes","layout","getDynamicParamFromSegment","searchParams","rootLayoutIncluded","dynamicParam","treeSegment","segmentTree","addSearchParamsIfPageSegment","Object","keys","reduce","existingValue","currentValue"],"mappings":";;;;+BAKgBA,yCAAAA;;;eAAAA;;;yBAF6B;AAEtC,SAASA,sCACd,CAACC,SAASC,gBAAgB,EAAEC,MAAM,EAAE,CAAa,EACjDC,0BAAsD,EACtDC,YAAiB,EACjBC,qBAAqB,KAAK;IAE1B,MAAMC,eAAeH,2BAA2BH;IAChD,MAAMO,cAAcD,eAAeA,aAAaC,WAAW,GAAGP;IAE9D,MAAMQ,cAAiC;QACrCC,CAAAA,GAAAA,SAAAA,4BAA4B,EAACF,aAAaH;QAC1C,CAAC;KACF;IAED,IAAI,CAACC,sBAAsB,OAAOH,WAAW,aAAa;QACxDG,qBAAqB;QACrBG,WAAW,CAAC,EAAE,GAAG;IACnB;IAEAA,WAAW,CAAC,EAAE,GAAGE,OAAOC,IAAI,CAACV,gBAAgBW,MAAM,CACjD,CAACC,eAAeC;QACdD,aAAa,CAACC,aAAa,GAAGf,sCAC5BE,cAAc,CAACa,aAAa,EAC5BX,4BACAC,cACAC;QAEF,OAAOQ;IACT,GACA,CAAC;IAGH,OAAOL;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/required-scripts.tsx"],"sourcesContent":["import { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { BuildManifest } from '../get-page-files'\n\nimport ReactDOM from 'react-dom'\n\nexport function getRequiredScripts(\n  buildManifest: BuildManifest,\n  assetPrefix: string,\n  crossOrigin: undefined | '' | 'anonymous' | 'use-credentials',\n  SRIManifest: undefined | Record<string, string>,\n  qs: string,\n  nonce: string | undefined,\n  pagePath: string\n): [\n  () => void,\n  { src: string; integrity?: string; crossOrigin?: string | undefined },\n] {\n  let preinitScripts: () => void\n  let preinitScriptCommands: string[] = []\n  const bootstrapScript: {\n    src: string\n    integrity?: string\n    crossOrigin?: string | undefined\n  } = {\n    src: '',\n    crossOrigin,\n  }\n\n  const files = (\n    buildManifest.rootMainFilesTree?.[pagePath] || buildManifest.rootMainFiles\n  ).map(encodeURIPath)\n  if (files.length === 0) {\n    throw new Error(\n      'Invariant: missing bootstrap script. This is a bug in Next.js'\n    )\n  }\n  if (SRIManifest) {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n    bootstrapScript.integrity = SRIManifest[files[0]]\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      const integrity = SRIManifest[files[i]]\n      preinitScriptCommands.push(src, integrity)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a double indexed array of src/integrity pairs\n      for (let i = 0; i < preinitScriptCommands.length; i += 2) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          integrity: preinitScriptCommands[i + 1],\n          crossOrigin,\n          nonce,\n        })\n      }\n    }\n  } else {\n    bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs\n\n    for (let i = 1; i < files.length; i++) {\n      const src = `${assetPrefix}/_next/` + files[i] + qs\n      preinitScriptCommands.push(src)\n    }\n    preinitScripts = () => {\n      // preinitScriptCommands is a singled indexed array of src values\n      for (let i = 0; i < preinitScriptCommands.length; i++) {\n        ReactDOM.preinit(preinitScriptCommands[i], {\n          as: 'script',\n          nonce,\n          crossOrigin,\n        })\n      }\n    }\n  }\n\n  return [preinitScripts, bootstrapScript]\n}\n"],"names":["getRequiredScripts","buildManifest","assetPrefix","crossOrigin","SRIManifest","qs","nonce","pagePath","preinitScripts","preinitScriptCommands","bootstrapScript","src","files","rootMainFilesTree","rootMainFiles","map","encodeURIPath","length","Error","integrity","i","push","ReactDOM","preinit","as"],"mappings":";;;;+BAKgBA,sBAAAA;;;eAAAA;;;+BALc;iEAGT;;;;;;AAEd,SAASA,mBACdC,aAA4B,EAC5BC,WAAmB,EACnBC,WAA6D,EAC7DC,WAA+C,EAC/CC,EAAU,EACVC,KAAyB,EACzBC,QAAgB;QAiBdN;IAZF,IAAIO;IACJ,IAAIC,wBAAkC,EAAE;IACxC,MAAMC,kBAIF;QACFC,KAAK;QACLR;IACF;IAEA,MAAMS,QACJX,CAAAA,CAAAA,CAAAA,mCAAAA,cAAcY,iBAAiB,KAAA,OAAA,KAAA,IAA/BZ,gCAAiC,CAACM,SAAS,KAAIN,cAAca,aAAY,EACzEC,GAAG,CAACC,eAAAA,aAAa;IACnB,IAAIJ,MAAMK,MAAM,KAAK,GAAG;QACtB,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,kEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IACA,IAAId,aAAa;QACfM,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAC3DK,gBAAgBS,SAAS,GAAGf,WAAW,CAACQ,KAAK,CAAC,EAAE,CAAC;QAEjD,IAAK,IAAIQ,IAAI,GAAGA,IAAIR,MAAMK,MAAM,EAAEG,IAAK;YACrC,MAAMT,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACQ,EAAE,GAAGf;YACjD,MAAMc,YAAYf,WAAW,CAACQ,KAAK,CAACQ,EAAE,CAAC;YACvCX,sBAAsBY,IAAI,CAACV,KAAKQ;QAClC;QACAX,iBAAiB;YACf,yEAAyE;YACzE,IAAK,IAAIY,IAAI,GAAGA,IAAIX,sBAAsBQ,MAAM,EAAEG,KAAK,EAAG;gBACxDE,UAAAA,OAAQ,CAACC,OAAO,CAACd,qBAAqB,CAACW,EAAE,EAAE;oBACzCI,IAAI;oBACJL,WAAWV,qBAAqB,CAACW,IAAI,EAAE;oBACvCjB;oBACAG;gBACF;YACF;QACF;IACF,OAAO;QACLI,gBAAgBC,GAAG,GAAG,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAAC,EAAE,GAAGP;QAE3D,IAAK,IAAIe,IAAI,GAAGA,IAAIR,MAAMK,MAAM,EAAEG,IAAK;YACrC,MAAMT,MAAM,GAAGT,YAAY,OAAO,CAAC,GAAGU,KAAK,CAACQ,EAAE,GAAGf;YACjDI,sBAAsBY,IAAI,CAACV;QAC7B;QACAH,iBAAiB;YACf,iEAAiE;YACjE,IAAK,IAAIY,IAAI,GAAGA,IAAIX,sBAAsBQ,MAAM,EAAEG,IAAK;gBACrDE,UAAAA,OAAQ,CAACC,OAAO,CAACd,qBAAqB,CAACW,EAAE,EAAE;oBACzCI,IAAI;oBACJlB;oBACAH;gBACF;YACF;QACF;IACF;IAEA,OAAO;QAACK;QAAgBE;KAAgB;AAC1C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2617, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-css-inlined-link-tags.tsx"],"sourcesContent":["import type {\n  ClientReferenceManifest,\n  CssResource,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get external stylesheet link hrefs based on server CSS manifest.\n */\nexport function getLinkAndScriptTags(\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  filePath: string,\n  injectedCSS: Set<string>,\n  injectedScripts: Set<string>,\n  collectNewImports?: boolean\n): { styles: CssResource[]; scripts: string[] } {\n  const filePathWithoutExt = filePath.replace(/\\.[^.]+$/, '')\n  const cssChunks = new Set<CssResource>()\n  const jsChunks = new Set<string>()\n\n  const entryCSSFiles =\n    clientReferenceManifest.entryCSSFiles[filePathWithoutExt]\n  const entryJSFiles =\n    clientReferenceManifest.entryJSFiles?.[filePathWithoutExt] ?? []\n\n  if (entryCSSFiles) {\n    for (const css of entryCSSFiles) {\n      if (!injectedCSS.has(css.path)) {\n        if (collectNewImports) {\n          injectedCSS.add(css.path)\n        }\n        cssChunks.add(css)\n      }\n    }\n  }\n\n  if (entryJSFiles) {\n    for (const file of entryJSFiles) {\n      if (!injectedScripts.has(file)) {\n        if (collectNewImports) {\n          injectedScripts.add(file)\n        }\n        jsChunks.add(file)\n      }\n    }\n  }\n\n  return { styles: [...cssChunks], scripts: [...jsChunks] }\n}\n"],"names":["getLinkAndScriptTags","clientReferenceManifest","filePath","injectedCSS","injectedScripts","collectNewImports","filePathWithoutExt","replace","cssChunks","Set","jsChunks","entryCSSFiles","entryJSFiles","css","has","path","add","file","styles","scripts"],"mappings":";;;;+BASgBA,wBAAAA;;;eAAAA;;;AAAT,SAASA,qBACdC,uBAA8D,EAC9DC,QAAgB,EAChBC,WAAwB,EACxBC,eAA4B,EAC5BC,iBAA2B;QASzBJ;IAPF,MAAMK,qBAAqBJ,SAASK,OAAO,CAAC,YAAY;IACxD,MAAMC,YAAY,IAAIC;IACtB,MAAMC,WAAW,IAAID;IAErB,MAAME,gBACJV,wBAAwBU,aAAa,CAACL,mBAAmB;IAC3D,MAAMM,eACJX,CAAAA,CAAAA,wCAAAA,wBAAwBW,YAAY,KAAA,OAAA,KAAA,IAApCX,qCAAsC,CAACK,mBAAmB,KAAI,EAAE;IAElE,IAAIK,eAAe;QACjB,KAAK,MAAME,OAAOF,cAAe;YAC/B,IAAI,CAACR,YAAYW,GAAG,CAACD,IAAIE,IAAI,GAAG;gBAC9B,IAAIV,mBAAmB;oBACrBF,YAAYa,GAAG,CAACH,IAAIE,IAAI;gBAC1B;gBACAP,UAAUQ,GAAG,CAACH;YAChB;QACF;IACF;IAEA,IAAID,cAAc;QAChB,KAAK,MAAMK,QAAQL,aAAc;YAC/B,IAAI,CAACR,gBAAgBU,GAAG,CAACG,OAAO;gBAC9B,IAAIZ,mBAAmB;oBACrBD,gBAAgBY,GAAG,CAACC;gBACtB;gBACAP,SAASM,GAAG,CAACC;YACf;QACF;IACF;IAEA,OAAO;QAAEC,QAAQ;eAAIV;SAAU;QAAEW,SAAS;eAAIT;SAAS;IAAC;AAC1D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2668, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-preloadable-fonts.tsx"],"sourcesContent":["import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\n/**\n * Get hrefs for fonts to preload\n * Returns null if there are no fonts at all.\n * Returns string[] if there are fonts to preload (font paths)\n * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded\n * Returns null if there are fonts but none to preload and at least some were previously preloaded\n */\nexport function getPreloadableFonts(\n  nextFontManifest: DeepReadonly<NextFontManifest> | undefined,\n  filePath: string | undefined,\n  injectedFontPreloadTags: Set<string>\n): string[] | null {\n  if (!nextFontManifest || !filePath) {\n    return null\n  }\n  const filepathWithoutExtension = filePath.replace(/\\.[^.]+$/, '')\n  const fontFiles = new Set<string>()\n  let foundFontUsage = false\n\n  const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension]\n  if (preloadedFontFiles) {\n    foundFontUsage = true\n    for (const fontFile of preloadedFontFiles) {\n      if (!injectedFontPreloadTags.has(fontFile)) {\n        fontFiles.add(fontFile)\n        injectedFontPreloadTags.add(fontFile)\n      }\n    }\n  }\n\n  if (fontFiles.size) {\n    return [...fontFiles].sort()\n  } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {\n    return []\n  } else {\n    return null\n  }\n}\n"],"names":["getPreloadableFonts","nextFontManifest","filePath","injectedFontPreloadTags","filepathWithoutExtension","replace","fontFiles","Set","foundFontUsage","preloadedFontFiles","app","fontFile","has","add","size","sort"],"mappings":";;;;+BAUgBA,uBAAAA;;;eAAAA;;;AAAT,SAASA,oBACdC,gBAA4D,EAC5DC,QAA4B,EAC5BC,uBAAoC;IAEpC,IAAI,CAACF,oBAAoB,CAACC,UAAU;QAClC,OAAO;IACT;IACA,MAAME,2BAA2BF,SAASG,OAAO,CAAC,YAAY;IAC9D,MAAMC,YAAY,IAAIC;IACtB,IAAIC,iBAAiB;IAErB,MAAMC,qBAAqBR,iBAAiBS,GAAG,CAACN,yBAAyB;IACzE,IAAIK,oBAAoB;QACtBD,iBAAiB;QACjB,KAAK,MAAMG,YAAYF,mBAAoB;YACzC,IAAI,CAACN,wBAAwBS,GAAG,CAACD,WAAW;gBAC1CL,UAAUO,GAAG,CAACF;gBACdR,wBAAwBU,GAAG,CAACF;YAC9B;QACF;IACF;IAEA,IAAIL,UAAUQ,IAAI,EAAE;QAClB,OAAO;eAAIR;SAAU,CAACS,IAAI;IAC5B,OAAO,IAAIP,kBAAkBL,wBAAwBW,IAAI,KAAK,GAAG;QAC/D,OAAO,EAAE;IACX,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/has-loading-component-in-tree.tsx"],"sourcesContent":["import type { LoaderTree } from '../lib/app-dir-module'\n\nexport function hasLoadingComponentInTree(tree: LoaderTree): boolean {\n  const [, parallelRoutes, { loading }] = tree\n\n  if (loading) {\n    return true\n  }\n\n  return Object.values(parallelRoutes).some((parallelRoute) =>\n    hasLoadingComponentInTree(parallelRoute)\n  ) as boolean\n}\n"],"names":["hasLoadingComponentInTree","tree","parallelRoutes","loading","Object","values","some","parallelRoute"],"mappings":";;;;+BAEgBA,6BAAAA;;;eAAAA;;;AAAT,SAASA,0BAA0BC,IAAgB;IACxD,MAAM,GAAGC,gBAAgB,EAAEC,OAAO,EAAE,CAAC,GAAGF;IAExC,IAAIE,SAAS;QACX,OAAO;IACT;IAEA,OAAOC,OAAOC,MAAM,CAACH,gBAAgBI,IAAI,CAAC,CAACC,gBACzCP,0BAA0BO;AAE9B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2732, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GAAA;;;;+BACeA,kBAAAA;;;eAAAA;;;AAAT,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/parse-loader-tree.ts"],"sourcesContent":["import { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { LoaderTree } from '../lib/app-dir-module'\n\nexport function parseLoaderTree(tree: LoaderTree) {\n  const [segment, parallelRoutes, modules] = tree\n  const { layout } = modules\n  let { page } = modules\n  // a __DEFAULT__ segment means that this route didn't match any of the\n  // segments in the route, so we should use the default page\n  page = segment === DEFAULT_SEGMENT_KEY ? modules.defaultPage : page\n\n  const layoutOrPagePath = layout?.[1] || page?.[1]\n\n  return {\n    page,\n    segment,\n    modules,\n    layoutOrPagePath,\n    parallelRoutes,\n  }\n}\n"],"names":["parseLoaderTree","tree","segment","parallelRoutes","modules","layout","page","DEFAULT_SEGMENT_KEY","defaultPage","layoutOrPagePath"],"mappings":";;;;+BAGgBA,mBAAAA;;;eAAAA;;;yBAHoB;AAG7B,SAASA,gBAAgBC,IAAgB;IAC9C,MAAM,CAACC,SAASC,gBAAgBC,QAAQ,GAAGH;IAC3C,MAAM,EAAEI,MAAM,EAAE,GAAGD;IACnB,IAAI,EAAEE,IAAI,EAAE,GAAGF;IACf,sEAAsE;IACtE,2DAA2D;IAC3DE,OAAOJ,YAAYK,SAAAA,mBAAmB,GAAGH,QAAQI,WAAW,GAAGF;IAE/D,MAAMG,mBAAmBJ,CAAAA,UAAAA,OAAAA,KAAAA,IAAAA,MAAQ,CAAC,EAAE,KAAA,CAAIC,QAAAA,OAAAA,KAAAA,IAAAA,IAAM,CAAC,EAAE;IAEjD,OAAO;QACLA;QACAJ;QACAE;QACAK;QACAN;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2784, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-asset-query-string.ts"],"sourcesContent":["import type { AppRenderContext } from './app-render'\n\nconst isDev = process.env.NODE_ENV === 'development'\nconst isTurbopack = !!process.env.TURBOPACK\n\nexport function getAssetQueryString(\n  ctx: AppRenderContext,\n  addTimestamp: boolean\n) {\n  let qs = ''\n\n  // In development we add the request timestamp to allow react to\n  // reload assets when a new RSC response is received.\n  // Turbopack handles HMR of assets itself and react doesn't need to reload them\n  // so this approach is not needed for Turbopack.\n  const shouldAddVersion = isDev && !isTurbopack && addTimestamp\n  if (shouldAddVersion) {\n    qs += `?v=${ctx.requestTimestamp}`\n  }\n\n  if (ctx.renderOpts.deploymentId) {\n    qs += `${shouldAddVersion ? '&' : '?'}dpl=${ctx.renderOpts.deploymentId}`\n  }\n  return qs\n}\n"],"names":["getAssetQueryString","isDev","process","env","NODE_ENV","isTurbopack","TURBOPACK","ctx","addTimestamp","qs","shouldAddVersion","requestTimestamp","renderOpts","deploymentId"],"mappings":";;;;+BAKgBA,uBAAAA;;;eAAAA;;;AAHhB,MAAMC,QAAQC,QAAQC,GAAG,CAACC,QAAQ,gCAAK;AACvC,MAAMC,cAAc,CAAC,CAACH,QAAQC,GAAG,CAACG,SAAS;AAEpC,SAASN,oBACdO,GAAqB,EACrBC,YAAqB;IAErB,IAAIC,KAAK;IAET,gEAAgE;IAChE,qDAAqD;IACrD,+EAA+E;IAC/E,gDAAgD;IAChD,MAAMC,mBAAmBT,SAAS,CAACI,eAAeG;IAClD,IAAIE,mCAAkB;;IAEtB;IAEA,IAAIH,IAAIK,UAAU,CAACC,YAAY,EAAE;QAC/BJ,MAAM,GAAGC,mBAAmB,0DAAM,IAAI,IAAI,EAAEH,IAAIK,UAAU,CAACC,YAAY,EAAE;IAC3E;IACA,OAAOJ;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/render-css-resource.tsx"],"sourcesContent":["import type { CssResource } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport type { PreloadCallbacks } from './types'\n\n/**\n * Abstracts the rendering of CSS files based on whether they are inlined or not.\n * For inlined CSS, renders a <style> tag with the CSS content directly embedded.\n * For external CSS files, renders a <link> tag pointing to the CSS file.\n */\nexport function renderCssResource(\n  entryCssFiles: CssResource[],\n  ctx: AppRenderContext,\n  preloadCallbacks?: PreloadCallbacks\n) {\n  return entryCssFiles.map((entryCssFile, index) => {\n    // `Precedence` is an opt-in signal for React to handle resource\n    // loading and deduplication, etc. It's also used as the key to sort\n    // resources so they will be injected in the correct order.\n    // During HMR, it's critical to use different `precedence` values\n    // for different stylesheets, so their order will be kept.\n    // https://github.com/facebook/react/pull/25060\n    const precedence =\n      process.env.NODE_ENV === 'development'\n        ? 'next_' + entryCssFile.path\n        : 'next'\n\n    // In dev, Safari and Firefox will cache the resource during HMR:\n    // - https://github.com/vercel/next.js/issues/5860\n    // - https://bugs.webkit.org/show_bug.cgi?id=187726\n    // Because of this, we add a `?v=` query to bypass the cache during\n    // development. We need to also make sure that the number is always\n    // increasing.\n    const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(\n      entryCssFile.path\n    )}${getAssetQueryString(ctx, true)}`\n\n    if (entryCssFile.inlined && !ctx.parsedRequestHeaders.isRSCRequest) {\n      return (\n        <style\n          key={index}\n          nonce={ctx.nonce}\n          // @ts-ignore\n          precedence={precedence}\n          href={fullHref}\n        >\n          {entryCssFile.content}\n        </style>\n      )\n    }\n\n    preloadCallbacks?.push(() => {\n      ctx.componentMod.preloadStyle(\n        fullHref,\n        ctx.renderOpts.crossOrigin,\n        ctx.nonce\n      )\n    })\n\n    return (\n      <link\n        key={index}\n        rel=\"stylesheet\"\n        href={fullHref}\n        // @ts-ignore\n        precedence={precedence}\n        crossOrigin={ctx.renderOpts.crossOrigin}\n        nonce={ctx.nonce}\n      />\n    )\n  })\n}\n"],"names":["renderCssResource","entryCssFiles","ctx","preloadCallbacks","map","entryCssFile","index","precedence","process","env","NODE_ENV","path","fullHref","assetPrefix","encodeURIPath","getAssetQueryString","inlined","parsedRequestHeaders","isRSCRequest","style","nonce","href","content","push","componentMod","preloadStyle","renderOpts","crossOrigin","link","rel"],"mappings":";;;;+BAWgBA,qBAAAA;;;eAAAA;;;;+BAVc;qCAEM;AAQ7B,SAASA,kBACdC,aAA4B,EAC5BC,GAAqB,EACrBC,gBAAmC;IAEnC,OAAOF,cAAcG,GAAG,CAAC,CAACC,cAAcC;QACtC,gEAAgE;QAChE,oEAAoE;QACpE,2DAA2D;QAC3D,iEAAiE;QACjE,0DAA0D;QAC1D,+CAA+C;QAC/C,MAAMC,aACJC,QAAQC,GAAG,CAACC,QAAQ,KAAK,cACrB,UAAUL,aAAaM,IAAI,GAC3B;QAEN,iEAAiE;QACjE,kDAAkD;QAClD,mDAAmD;QACnD,mEAAmE;QACnE,mEAAmE;QACnE,cAAc;QACd,MAAMC,WAAW,GAAGV,IAAIW,WAAW,CAAC,OAAO,EAAEC,CAAAA,GAAAA,eAAAA,aAAa,EACxDT,aAAaM,IAAI,IACfI,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACb,KAAK,OAAO;QAEpC,IAAIG,aAAaW,OAAO,IAAI,CAACd,IAAIe,oBAAoB,CAACC,YAAY,EAAE;YAClE,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACC,SAAAA;gBAECC,OAAOlB,IAAIkB,KAAK;gBAChB,aAAa;gBACbb,YAAYA;gBACZc,MAAMT;0BAELP,aAAaiB,OAAO;eANhBhB;QASX;QAEAH,oBAAAA,OAAAA,KAAAA,IAAAA,iBAAkBoB,IAAI,CAAC;YACrBrB,IAAIsB,YAAY,CAACC,YAAY,CAC3Bb,UACAV,IAAIwB,UAAU,CAACC,WAAW,EAC1BzB,IAAIkB,KAAK;QAEb;QAEA,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAACQ,QAAAA;YAECC,KAAI;YACJR,MAAMT;YACN,aAAa;YACbL,YAAYA;YACZoB,aAAazB,IAAIwB,UAAU,CAACC,WAAW;YACvCP,OAAOlB,IAAIkB,KAAK;WANXd;IASX;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2872, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/create-component-styles-and-scripts.tsx"],"sourcesContent":["import React from 'react'\nimport { interopDefault } from './interop-default'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport { renderCssResource } from './render-css-resource'\n\nexport async function createComponentStylesAndScripts({\n  filePath,\n  getComponent,\n  injectedCSS,\n  injectedJS,\n  ctx,\n}: {\n  filePath: string\n  getComponent: () => any\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  ctx: AppRenderContext\n}): Promise<[React.ComponentType<any>, React.ReactNode, React.ReactNode]> {\n  const { styles: entryCssFiles, scripts: jsHrefs } = getLinkAndScriptTags(\n    ctx.clientReferenceManifest,\n    filePath,\n    injectedCSS,\n    injectedJS\n  )\n\n  const styles = renderCssResource(entryCssFiles, ctx)\n\n  const scripts = jsHrefs\n    ? jsHrefs.map((href, index) => (\n        <script\n          src={`${ctx.assetPrefix}/_next/${encodeURIPath(\n            href\n          )}${getAssetQueryString(ctx, true)}`}\n          async={true}\n          key={`script-${index}`}\n        />\n      ))\n    : null\n\n  const Comp = interopDefault(await getComponent())\n\n  return [Comp, styles, scripts]\n}\n"],"names":["createComponentStylesAndScripts","filePath","getComponent","injectedCSS","injectedJS","ctx","styles","entryCssFiles","scripts","jsHrefs","getLinkAndScriptTags","clientReferenceManifest","renderCssResource","map","href","index","script","src","assetPrefix","encodeURIPath","getAssetQueryString","async","Comp","interopDefault"],"mappings":";;;;+BAQsBA,mCAAAA;;;eAAAA;;;;8DARJ;gCACa;uCACM;qCAED;+BACN;mCACI;;;;;;AAE3B,eAAeA,gCAAgC,EACpDC,QAAQ,EACRC,YAAY,EACZC,WAAW,EACXC,UAAU,EACVC,GAAG,EAOJ;IACC,MAAM,EAAEC,QAAQC,aAAa,EAAEC,SAASC,OAAO,EAAE,GAAGC,CAAAA,GAAAA,uBAAAA,oBAAoB,EACtEL,IAAIM,uBAAuB,EAC3BV,UACAE,aACAC;IAGF,MAAME,SAASM,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACL,eAAeF;IAEhD,MAAMG,UAAUC,UACZA,QAAQI,GAAG,CAAC,CAACC,MAAMC,QAAAA,WAAAA,GACjB,CAAA,GAAA,YAAA,GAAA,EAACC,UAAAA;YACCC,KAAK,GAAGZ,IAAIa,WAAW,CAAC,OAAO,EAAEC,CAAAA,GAAAA,eAAAA,aAAa,EAC5CL,QACEM,CAAAA,GAAAA,qBAAAA,mBAAmB,EAACf,KAAK,OAAO;YACpCgB,OAAO;WACF,CAAC,OAAO,EAAEN,OAAO,KAG1B;IAEJ,MAAMO,OAAOC,CAAAA,GAAAA,gBAAAA,cAAc,EAAC,MAAMrB;IAElC,OAAO;QAACoB;QAAMhB;QAAQE;KAAQ;AAChC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2913, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/get-layer-assets.tsx"],"sourcesContent":["import React from 'react'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport type { AppRenderContext } from './app-render'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { encodeURIPath } from '../../shared/lib/encode-uri-path'\nimport type { PreloadCallbacks } from './types'\nimport { renderCssResource } from './render-css-resource'\n\nexport function getLayerAssets({\n  ctx,\n  layoutOrPagePath,\n  injectedCSS: injectedCSSWithCurrentLayout,\n  injectedJS: injectedJSWithCurrentLayout,\n  injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  preloadCallbacks,\n}: {\n  layoutOrPagePath: string | undefined\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n}): React.ReactNode {\n  const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath\n    ? getLinkAndScriptTags(\n        ctx.clientReferenceManifest,\n        layoutOrPagePath,\n        injectedCSSWithCurrentLayout,\n        injectedJSWithCurrentLayout,\n        true\n      )\n    : { styles: [], scripts: [] }\n\n  const preloadedFontFiles = layoutOrPagePath\n    ? getPreloadableFonts(\n        ctx.renderOpts.nextFontManifest,\n        layoutOrPagePath,\n        injectedFontPreloadTagsWithCurrentLayout\n      )\n    : null\n\n  if (preloadedFontFiles) {\n    if (preloadedFontFiles.length) {\n      for (let i = 0; i < preloadedFontFiles.length; i++) {\n        const fontFilename = preloadedFontFiles[i]\n        const ext = /\\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)![1]\n        const type = `font/${ext}`\n        const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`\n\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preloadFont(\n            href,\n            type,\n            ctx.renderOpts.crossOrigin,\n            ctx.nonce\n          )\n        })\n      }\n    } else {\n      try {\n        let url = new URL(ctx.assetPrefix)\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect(url.origin, 'anonymous', ctx.nonce)\n        })\n      } catch (error) {\n        // assetPrefix must not be a fully qualified domain name. We assume\n        // we should preconnect to same origin instead\n        preloadCallbacks.push(() => {\n          ctx.componentMod.preconnect('/', 'anonymous', ctx.nonce)\n        })\n      }\n    }\n  }\n\n  const styles = renderCssResource(styleTags, ctx, preloadCallbacks)\n\n  const scripts = scriptTags\n    ? scriptTags.map((href, index) => {\n        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(\n          href\n        )}${getAssetQueryString(ctx, true)}`\n\n        return (\n          <script\n            src={fullSrc}\n            async={true}\n            key={`script-${index}`}\n            nonce={ctx.nonce}\n          />\n        )\n      })\n    : []\n\n  return styles.length || scripts.length ? [...styles, ...scripts] : null\n}\n"],"names":["getLayerAssets","ctx","layoutOrPagePath","injectedCSS","injectedCSSWithCurrentLayout","injectedJS","injectedJSWithCurrentLayout","injectedFontPreloadTags","injectedFontPreloadTagsWithCurrentLayout","preloadCallbacks","styles","styleTags","scripts","scriptTags","getLinkAndScriptTags","clientReferenceManifest","preloadedFontFiles","getPreloadableFonts","renderOpts","nextFontManifest","length","i","fontFilename","ext","exec","type","href","assetPrefix","encodeURIPath","push","componentMod","preloadFont","crossOrigin","nonce","url","URL","preconnect","origin","error","renderCssResource","map","index","fullSrc","getAssetQueryString","script","src","async"],"mappings":";;;;+BASgBA,kBAAAA;;;eAAAA;;;;8DATE;uCACmB;qCACD;qCAEA;+BACN;mCAEI;;;;;;AAE3B,SAASA,eAAe,EAC7BC,GAAG,EACHC,gBAAgB,EAChBC,aAAaC,4BAA4B,EACzCC,YAAYC,2BAA2B,EACvCC,yBAAyBC,wCAAwC,EACjEC,gBAAgB,EAQjB;IACC,MAAM,EAAEC,QAAQC,SAAS,EAAEC,SAASC,UAAU,EAAE,GAAGX,mBAC/CY,CAAAA,GAAAA,uBAAAA,oBAAoB,EAClBb,IAAIc,uBAAuB,EAC3Bb,kBACAE,8BACAE,6BACA,QAEF;QAAEI,QAAQ,EAAE;QAAEE,SAAS,EAAE;IAAC;IAE9B,MAAMI,qBAAqBd,mBACvBe,CAAAA,GAAAA,qBAAAA,mBAAmB,EACjBhB,IAAIiB,UAAU,CAACC,gBAAgB,EAC/BjB,kBACAM,4CAEF;IAEJ,IAAIQ,oBAAoB;QACtB,IAAIA,mBAAmBI,MAAM,EAAE;YAC7B,IAAK,IAAIC,IAAI,GAAGA,IAAIL,mBAAmBI,MAAM,EAAEC,IAAK;gBAClD,MAAMC,eAAeN,kBAAkB,CAACK,EAAE;gBAC1C,MAAME,MAAM,8BAA8BC,IAAI,CAACF,aAAc,CAAC,EAAE;gBAChE,MAAMG,OAAO,CAAC,KAAK,EAAEF,KAAK;gBAC1B,MAAMG,OAAO,GAAGzB,IAAI0B,WAAW,CAAC,OAAO,EAAEC,CAAAA,GAAAA,eAAAA,aAAa,EAACN,eAAe;gBAEtEb,iBAAiBoB,IAAI,CAAC;oBACpB5B,IAAI6B,YAAY,CAACC,WAAW,CAC1BL,MACAD,MACAxB,IAAIiB,UAAU,CAACc,WAAW,EAC1B/B,IAAIgC,KAAK;gBAEb;YACF;QACF,OAAO;YACL,IAAI;gBACF,IAAIC,MAAM,IAAIC,IAAIlC,IAAI0B,WAAW;gBACjClB,iBAAiBoB,IAAI,CAAC;oBACpB5B,IAAI6B,YAAY,CAACM,UAAU,CAACF,IAAIG,MAAM,EAAE,aAAapC,IAAIgC,KAAK;gBAChE;YACF,EAAE,OAAOK,OAAO;gBACd,mEAAmE;gBACnE,8CAA8C;gBAC9C7B,iBAAiBoB,IAAI,CAAC;oBACpB5B,IAAI6B,YAAY,CAACM,UAAU,CAAC,KAAK,aAAanC,IAAIgC,KAAK;gBACzD;YACF;QACF;IACF;IAEA,MAAMvB,SAAS6B,CAAAA,GAAAA,mBAAAA,iBAAiB,EAAC5B,WAAWV,KAAKQ;IAEjD,MAAMG,UAAUC,aACZA,WAAW2B,GAAG,CAAC,CAACd,MAAMe;QACpB,MAAMC,UAAU,GAAGzC,IAAI0B,WAAW,CAAC,OAAO,EAAEC,CAAAA,GAAAA,eAAAA,aAAa,EACvDF,QACEiB,CAAAA,GAAAA,qBAAAA,mBAAmB,EAAC1C,KAAK,OAAO;QAEpC,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,GAAA,EAAC2C,UAAAA;YACCC,KAAKH;YACLI,OAAO;YAEPb,OAAOhC,IAAIgC,KAAK;WADX,CAAC,OAAO,EAAEQ,OAAO;IAI5B,KACA,EAAE;IAEN,OAAO/B,OAAOU,MAAM,IAAIR,QAAQQ,MAAM,GAAG;WAAIV;WAAWE;KAAQ,GAAG;AACrE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2986, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type { CacheNodeSeedData, PreloadCallbacks } from './types'\nimport React from 'react'\nimport {\n  isClientReference,\n  isUseCacheFunction,\n} from '../../lib/client-and-server-references'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { AppRenderContext, GetDynamicParamFromSegment } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { Params } from '../request/params'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { OUTLET_BOUNDARY_NAME } from '../../lib/metadata/metadata-constants'\nimport type { UseCachePageComponentProps } from '../use-cache/use-cache-wrapper'\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<CacheNodeSeedData> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props)\n  )\n}\n\nfunction errorMissingDefaultExport(\n  pagePath: string,\n  convention: string\n): never {\n  const normalizedPagePath = pagePath === '/' ? '' : pagePath\n  throw new Error(\n    `The default export is not a React Component in \"${normalizedPagePath}/${convention}\"`\n  )\n}\n\nconst cacheNodeKey = 'c'\n\nasync function createComponentTreeInternal({\n  loaderTree: tree,\n  parentParams,\n  rootLayoutIncluded,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  missingSlots,\n  preloadCallbacks,\n  authInterrupts,\n  StreamingMetadataOutlet,\n}: {\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  getViewportReady: () => Promise<void>\n  getMetadataReady: () => Promise<void>\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n  preloadCallbacks: PreloadCallbacks\n  authInterrupts: boolean\n  StreamingMetadataOutlet: React.ComponentType | null\n}): Promise<CacheNodeSeedData> {\n  const {\n    renderOpts: { nextConfigOutput, experimental },\n    workStore,\n    componentMod: {\n      HTTPAccessFallbackBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      OutletBoundary,\n      ClientPageRoot,\n      ClientSegmentRoot,\n      createServerSearchParamsForServerPage,\n      createPrerenderSearchParamsForClientPage,\n      createServerParamsForServerSegment,\n      createPrerenderParamsForClientSegment,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, layoutOrPagePath, segment, modules, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const {\n    layout,\n    template,\n    error,\n    loading,\n    'not-found': notFound,\n    forbidden,\n    unauthorized,\n  } = modules\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    preloadCallbacks,\n    ctx,\n    layoutOrPagePath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [React.Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const { mod: layoutOrPageMod, modType } = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Forbidden, forbiddenStyles] =\n    authInterrupts && forbidden\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: forbidden[1],\n          getComponent: forbidden[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  const [Unauthorized, unauthorizedStyles] =\n    authInterrupts && unauthorized\n      ? await createComponentStylesAndScripts({\n          ctx,\n          filePath: unauthorized[1],\n          getComponent: unauthorized[0],\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n        })\n      : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      workStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      workStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (workStore.isStaticGeneration && !experimental.isRoutePPREnabled) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        workStore.dynamicUsageDescription = err.message\n        workStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      workStore.dynamicShouldError = false\n      workStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    workStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, workStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    const defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    if (workUnitStore) {\n      if (\n        workUnitStore.type === 'prerender' ||\n        workUnitStore.type === 'prerender-legacy' ||\n        workUnitStore.type === 'prerender-ppr' ||\n        workUnitStore.type === 'cache'\n      ) {\n        if (workUnitStore.revalidate > defaultRevalidate) {\n          workUnitStore.revalidate = defaultRevalidate\n        }\n      }\n    }\n\n    if (\n      !workStore.forceStatic &&\n      workStore.isStaticGeneration &&\n      defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !experimental.isRoutePPREnabled\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      workStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  const isStaticGeneration = workStore.isStaticGeneration\n\n  // Assume the segment we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // It's OK for this to be `true` when the data is actually fully static, but\n  // it's not OK for this to be `false` when the data possibly contains holes.\n  // Although the value here is overly pessimistic, for prefetches, it will be\n  // replaced by a more specific value when the data is later processed into\n  // per-segment responses (see collect-segment-data.tsx)\n  //\n  // For dynamic requests, this must always be `false` because dynamic responses\n  // are never partial.\n  const isPossiblyPartialResponse =\n    isStaticGeneration && experimental.isRoutePPREnabled === true\n\n  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let MaybeComponent = LayoutOrPage\n\n  if (process.env.NODE_ENV === 'development') {\n    const { isValidElementType } = require('next/dist/compiled/react-is')\n    if (\n      typeof MaybeComponent !== 'undefined' &&\n      !isValidElementType(MaybeComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, modType ?? 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n\n    if (typeof Forbidden !== 'undefined' && !isValidElementType(Forbidden)) {\n      errorMissingDefaultExport(pagePath, 'forbidden')\n    }\n\n    if (\n      typeof Unauthorized !== 'undefined' &&\n      !isValidElementType(Unauthorized)\n    ) {\n      errorMissingDefaultExport(pagePath, 'unauthorized')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  // Create object holding the parent params and current params\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  // Resolve the segment param\n  const actualSegment = segmentParam ? segmentParam.treeSegment : segment\n\n  // Use the same condition to render metadataOutlet as metadata\n  const metadataOutlet = StreamingMetadataOutlet ? (\n    <StreamingMetadataOutlet />\n  ) : undefined\n\n  const notFoundElement = NotFound ? (\n    <>\n      <NotFound />\n      {notFoundStyles}\n    </>\n  ) : undefined\n\n  const forbiddenElement = Forbidden ? (\n    <>\n      <Forbidden />\n      {forbiddenStyles}\n    </>\n  ) : undefined\n\n  const unauthorizedElement = Unauthorized ? (\n    <>\n      <Unauthorized />\n      {unauthorizedStyles}\n    </>\n  ) : undefined\n\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent = isChildrenRouteKey\n          ? notFoundElement\n          : undefined\n\n        const forbiddenComponent = isChildrenRouteKey\n          ? forbiddenElement\n          : undefined\n\n        const unauthorizedComponent = isChildrenRouteKey\n          ? unauthorizedElement\n          : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is deferred until the actual navigation.\n          // It does not take into account whether the data is dynamic — even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different — loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.layoutOrPagePath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const seedData = await createComponentTreeInternal({\n            loaderTree: parallelRoute,\n            parentParams: currentParams,\n            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n            injectedCSS: injectedCSSWithCurrentLayout,\n            injectedJS: injectedJSWithCurrentLayout,\n            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n            // `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            getMetadataReady: isChildrenRouteKey\n              ? getMetadataReady\n              : () => Promise.resolve(),\n            getViewportReady: isChildrenRouteKey\n              ? getViewportReady\n              : () => Promise.resolve(),\n            ctx,\n            missingSlots,\n            preloadCallbacks,\n            authInterrupts,\n            // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n            // but we only want to throw on the first one.\n            StreamingMetadataOutlet: isChildrenRouteKey\n              ? StreamingMetadataOutlet\n              : null,\n          })\n\n          childCacheNodeSeedData = seedData\n        }\n\n        // This is turned back into an object below.\n        return [\n          parallelRouteKey,\n          <LayoutRouter\n            parallelRouterKey={parallelRouteKey}\n            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n            error={ErrorComponent}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n            template={\n              <Template>\n                <RenderFromTemplateContext />\n              </Template>\n            }\n            templateStyles={templateStyles}\n            templateScripts={templateScripts}\n            notFound={notFoundComponent}\n            forbidden={forbiddenComponent}\n            unauthorized={unauthorizedComponent}\n          />,\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  const loadingData: LoadingModuleData = Loading\n    ? [<Loading key=\"l\" />, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!MaybeComponent) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {layerAssets}\n        {parallelRouteProps.children}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n\n  const Component = MaybeComponent\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    workStore.isStaticGeneration &&\n    workStore.forceDynamic &&\n    experimental.isRoutePPREnabled\n  ) {\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        <Postpone\n          reason='dynamic = \"force-dynamic\" was used'\n          route={workStore.route}\n        />\n        {layerAssets}\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      true,\n    ]\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n\n  if (isPage) {\n    const PageComponent = Component\n    // Assign searchParams to props if this is a page\n    let pageElement: React.ReactNode\n    if (isClientComponent) {\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n        const promiseOfSearchParams =\n          createPrerenderSearchParamsForClientPage(workStore)\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n            promises={[promiseOfSearchParams, promiseOfParams]}\n          />\n        )\n      } else {\n        pageElement = (\n          <ClientPageRoot\n            Component={PageComponent}\n            searchParams={query}\n            params={currentParams}\n          />\n        )\n      }\n    } else {\n      // If we are passing params to a server component Page we need to track\n      // their usage in case the current render mode tracks dynamic API usage.\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      // TODO(useCache): Should we use this trick also if dynamicIO is enabled,\n      // instead of relying on the searchParams being a hanging promise?\n      if (!experimental.dynamicIO && isUseCacheFunction(PageComponent)) {\n        const UseCachePageComponent: React.ComponentType<UseCachePageComponentProps> =\n          PageComponent\n\n        // The \"use cache\" wrapper takes care of converting this into an\n        // erroring search params promise when passing it to the original\n        // function.\n        const searchParams = Promise.resolve({})\n\n        pageElement = (\n          <UseCachePageComponent\n            params={params}\n            searchParams={searchParams}\n            $$isPageComponent\n          />\n        )\n      } else {\n        // If we are passing searchParams to a server component Page we need to\n        // track their usage in case the current render mode tracks dynamic API\n        // usage.\n        const searchParams = createServerSearchParamsForServerPage(\n          query,\n          workStore\n        )\n\n        pageElement = (\n          <PageComponent params={params} searchParams={searchParams} />\n        )\n      }\n    }\n    return [\n      actualSegment,\n      <React.Fragment key={cacheNodeKey}>\n        {pageElement}\n        {layerAssets}\n        <OutletBoundary>\n          <MetadataOutlet ready={getViewportReady} />\n          {/* Blocking metadata outlet */}\n          <MetadataOutlet ready={getMetadataReady} />\n          {/* Streaming metadata outlet */}\n          {metadataOutlet}\n        </OutletBoundary>\n      </React.Fragment>,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  } else {\n    const SegmentComponent = Component\n\n    const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot =\n      rootLayoutAtThisLevel &&\n      'children' in parallelRoutes &&\n      Object.keys(parallelRoutes).length > 1\n\n    let segmentNode: React.ReactNode\n\n    if (isClientComponent) {\n      let clientSegment: React.ReactNode\n\n      if (isStaticGeneration) {\n        const promiseOfParams = createPrerenderParamsForClientSegment(\n          currentParams,\n          workStore\n        )\n\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n            promise={promiseOfParams}\n          />\n        )\n      } else {\n        clientSegment = (\n          <ClientSegmentRoot\n            Component={SegmentComponent}\n            slots={parallelRouteProps}\n            params={currentParams}\n          />\n        )\n      }\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        let notfoundClientSegment: React.ReactNode\n        let forbiddenClientSegment: React.ReactNode\n        let unauthorizedClientSegment: React.ReactNode\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: NotFound,\n          errorElement: notFoundElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Forbidden,\n          errorElement: forbiddenElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n          ErrorBoundaryComponent: Unauthorized,\n          errorElement: unauthorizedElement,\n          ClientSegmentRoot,\n          layerAssets,\n          SegmentComponent,\n          currentParams,\n        })\n        if (\n          notfoundClientSegment ||\n          forbiddenClientSegment ||\n          unauthorizedClientSegment\n        ) {\n          segmentNode = (\n            <HTTPAccessFallbackBoundary\n              key={cacheNodeKey}\n              notFound={notfoundClientSegment}\n              forbidden={forbiddenClientSegment}\n              unauthorized={unauthorizedClientSegment}\n            >\n              {layerAssets}\n              {clientSegment}\n            </HTTPAccessFallbackBoundary>\n          )\n        } else {\n          segmentNode = (\n            <React.Fragment key={cacheNodeKey}>\n              {layerAssets}\n              {clientSegment}\n            </React.Fragment>\n          )\n        }\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {clientSegment}\n          </React.Fragment>\n        )\n      }\n    } else {\n      const params = createServerParamsForServerSegment(\n        currentParams,\n        workStore\n      )\n\n      let serverSegment = (\n        <SegmentComponent {...parallelRouteProps} params={params} />\n      )\n\n      if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n        // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n        // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n        // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n        // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n        // rely on the `NotFound` behavior.\n        segmentNode = (\n          <HTTPAccessFallbackBoundary\n            key={cacheNodeKey}\n            notFound={\n              NotFound ? (\n                <>\n                  {layerAssets}\n                  <SegmentComponent params={params}>\n                    {notFoundStyles}\n                    <NotFound />\n                  </SegmentComponent>\n                </>\n              ) : undefined\n            }\n          >\n            {layerAssets}\n            {serverSegment}\n          </HTTPAccessFallbackBoundary>\n        )\n      } else {\n        segmentNode = (\n          <React.Fragment key={cacheNodeKey}>\n            {layerAssets}\n            {serverSegment}\n          </React.Fragment>\n        )\n      }\n    }\n    // For layouts we just render the component\n    return [\n      actualSegment,\n      segmentNode,\n      parallelRouteCacheNodeSeedData,\n      loadingData,\n      isPossiblyPartialResponse,\n    ]\n  }\n}\n\nasync function MetadataOutlet({\n  ready,\n}: {\n  ready: () => Promise<void> & { status?: string; value?: unknown }\n}) {\n  const r = ready()\n  // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n  if (r.status === 'rejected') {\n    throw r.value\n  } else if (r.status !== 'fulfilled') {\n    await r\n  }\n  return null\n}\nMetadataOutlet.displayName = OUTLET_BOUNDARY_NAME\n\nfunction createErrorBoundaryClientSegmentRoot({\n  ErrorBoundaryComponent,\n  errorElement,\n  ClientSegmentRoot,\n  layerAssets,\n  SegmentComponent,\n  currentParams,\n}: {\n  ErrorBoundaryComponent: React.ComponentType<any> | undefined\n  errorElement: React.ReactNode\n  ClientSegmentRoot: React.ComponentType<any>\n  layerAssets: React.ReactNode\n  SegmentComponent: React.ComponentType<any>\n  currentParams: Params\n}) {\n  if (ErrorBoundaryComponent) {\n    const notFoundParallelRouteProps = {\n      children: errorElement,\n    }\n    return (\n      <>\n        {layerAssets}\n        <ClientSegmentRoot\n          Component={SegmentComponent}\n          slots={notFoundParallelRouteProps}\n          params={currentParams}\n        />\n      </>\n    )\n  }\n  return null\n}\n\nexport function getRootParams(\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment)\n}\n\nfunction getRootParamsImpl(\n  parentParams: Params,\n  loaderTree: LoaderTree,\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n): Params {\n  const {\n    segment,\n    modules: { layout },\n    parallelRoutes,\n  } = parseLoaderTree(loaderTree)\n\n  const segmentParam = getDynamicParamFromSegment(segment)\n\n  let currentParams: Params = parentParams\n  if (segmentParam && segmentParam.value !== null) {\n    currentParams = {\n      ...parentParams,\n      [segmentParam.param]: segmentParam.value,\n    }\n  }\n\n  const isRootLayout = typeof layout !== 'undefined'\n\n  if (isRootLayout) {\n    return currentParams\n  } else if (!parallelRoutes.children) {\n    // This should really be an error but there are bugs in Turbopack that cause\n    // the _not-found LoaderTree to not have any layouts. For rootParams sake\n    // this is somewhat irrelevant when you are not customizing the 404 page.\n    // If you are customizing 404\n    // TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined\n    return currentParams\n  } else {\n    return getRootParamsImpl(\n      currentParams,\n      // We stop looking for root params as soon as we hit the first layout\n      // and it is not possible to use parallel route children above the root layout\n      // so every parallelRoutes object that this function can visit will necessarily\n      // have a single `children` prop and no others.\n      parallelRoutes.children,\n      getDynamicParamFromSegment\n    )\n  }\n}\n"],"names":["createComponentTree","getRootParams","props","getTracer","trace","NextNodeServerSpan","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","normalizedPagePath","Error","cacheNodeKey","loaderTree","tree","parentParams","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","getViewportReady","getMetadataReady","ctx","missingSlots","preloadCallbacks","authInterrupts","StreamingMetadataOutlet","renderOpts","nextConfigOutput","experimental","workStore","componentMod","HTTPAccessFallbackBoundary","LayoutRouter","RenderFromTemplateContext","OutletBoundary","ClientPageRoot","ClientSegmentRoot","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createPrerenderParamsForClientSegment","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","layoutOrPagePath","segment","modules","parallelRoutes","parseLoaderTree","layout","template","error","loading","notFound","forbidden","unauthorized","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","getLayerAssets","Template","templateStyles","templateScripts","createComponentStylesAndScripts","filePath","getComponent","React","Fragment","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","mod","layoutOrPageMod","modType","getLayoutOrPageModule","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","Forbidden","forbiddenStyles","Unauthorized","unauthorizedStyles","dynamic","StaticGenBailoutError","dynamicShouldError","forceDynamic","isStaticGeneration","isRoutePPREnabled","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","validateRevalidate","route","defaultRevalidate","workUnitStore","workUnitAsyncStorage","getStore","type","isPossiblyPartialResponse","LayoutOrPage","interopDefault","undefined","MaybeComponent","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","actualSegment","treeSegment","metadataOutlet","notFoundElement","forbiddenElement","unauthorizedElement","parallelRouteMap","Promise","all","Object","keys","map","parallelRouteKey","isChildrenRouteKey","parallelRoute","notFoundComponent","forbiddenComponent","unauthorizedComponent","childCacheNodeSeedData","hasLoadingComponentInTree","parsedTree","endsWith","PARALLEL_ROUTE_DEFAULT_PATH","add","seedData","resolve","parallelRouterKey","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingData","children","Component","reason","isClientComponent","isClientReference","console","PageComponent","pageElement","promiseOfParams","promiseOfSearchParams","searchParams","params","promises","dynamicIO","isUseCacheFunction","UseCachePageComponent","$$isPageComponent","MetadataOutlet","ready","SegmentComponent","isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot","length","segmentNode","clientSegment","slots","promise","notfoundClientSegment","forbiddenClientSegment","unauthorizedClientSegment","createErrorBoundaryClientSegmentRoot","ErrorBoundaryComponent","errorElement","serverSegment","r","status","displayName","OUTLET_BOUNDARY_NAME","notFoundParallelRouteProps","getRootParamsImpl","isRootLayout"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3681, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/walk-tree-with-flight-router-state.tsx"],"sourcesContent":["import type {\n  FlightDataPath,\n  FlightDataSegment,\n  FlightRouterState,\n  PreloadCallbacks,\n  Segment,\n} from './types'\nimport { matchSegment } from '../../client/components/match-segments'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport type { AppRenderContext } from './app-render'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  addSearchParamsIfPageSegment,\n} from '../../shared/lib/segment'\nimport { createComponentTree } from './create-component-tree'\nimport type { HeadData } from '../../shared/lib/app-router-context.shared-runtime'\nimport { getSegmentParam } from './get-segment-param'\n\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */\nexport async function walkTreeWithFlightRouterState({\n  loaderTreeToFilter,\n  parentParams,\n  flightRouterState,\n  parentIsInsideSharedLayout,\n  rscHead,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  rootLayoutIncluded,\n  getViewportReady,\n  getMetadataReady,\n  ctx,\n  preloadCallbacks,\n  StreamingMetadataOutlet,\n}: {\n  loaderTreeToFilter: LoaderTree\n  parentParams: { [key: string]: string | string[] }\n  flightRouterState?: FlightRouterState\n  rscHead: HeadData\n  parentIsInsideSharedLayout?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  rootLayoutIncluded: boolean\n  getMetadataReady: () => Promise<void>\n  getViewportReady: () => Promise<void>\n  ctx: AppRenderContext\n  preloadCallbacks: PreloadCallbacks\n  StreamingMetadataOutlet: React.ComponentType\n}): Promise<FlightDataPath[]> {\n  const {\n    renderOpts: { nextFontManifest, experimental },\n    query,\n    isPrefetch,\n    getDynamicParamFromSegment,\n    parsedRequestHeaders,\n  } = ctx\n\n  const [segment, parallelRoutes, modules] = loaderTreeToFilter\n\n  const parallelRoutesKeys = Object.keys(parallelRoutes)\n\n  const { layout } = modules\n  const isLayout = typeof layout !== 'undefined'\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n  const segmentParam = getDynamicParamFromSegment(segment)\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : parentParams\n  const actualSegment: Segment = addSearchParamsIfPageSegment(\n    segmentParam ? segmentParam.treeSegment : segment,\n    query\n  )\n\n  /**\n   * Decide if the current segment is where rendering has to start.\n   */\n  const renderComponentsOnThisLevel =\n    // No further router state available\n    !flightRouterState ||\n    // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) ||\n    // Last item in the tree\n    parallelRoutesKeys.length === 0 ||\n    // Explicit refresh\n    flightRouterState[3] === 'refetch'\n\n  // Pre-PPR, the `loading` component signals to the router how deep to render the component tree\n  // to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,\n  // the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`\n  // somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.\n\n  // Check if we're inside the \"new\" part of the navigation — inside the\n  // shared layout. In the case of a prefetch, this can be true even if the\n  // segment matches, because the client might send a matching segment to\n  // indicate that it already has the data in its cache. But in order to find\n  // the correct loading boundary, we still need to track where the shared\n  // layout begins.\n  //\n  // TODO: We should rethink the protocol for dynamic requests. It might not\n  // make sense for the client to send a FlightRouterState, since that type is\n  // overloaded with other concerns.\n  const isInsideSharedLayout =\n    renderComponentsOnThisLevel ||\n    parentIsInsideSharedLayout ||\n    flightRouterState[3] === 'inside-shared-layout'\n\n  if (\n    isInsideSharedLayout &&\n    !experimental.isRoutePPREnabled &&\n    // If PPR is disabled, and this is a request for the route tree, then we\n    // never render any components. Only send the router state.\n    (parsedRequestHeaders.isRouteTreePrefetchRequest ||\n      // Otherwise, check for the presence of a `loading` component.\n      (isPrefetch &&\n        !Boolean(modules.loading) &&\n        !hasLoadingComponentInTree(loaderTreeToFilter)))\n  ) {\n    // Send only the router state.\n    // TODO: Even for a dynamic route, we should cache these responses,\n    // because they do not contain any render data (neither segment data nor\n    // the head). They can be made even more cacheable once we move the route\n    // params into a separate data structure.\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        null,\n        [null, null],\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  if (renderComponentsOnThisLevel) {\n    const overriddenSegment =\n      flightRouterState &&\n      // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n      // use `actualSegment`? Is it to avoid overwriting some state that's\n      // tracked by the client? Dig deeper to see if we can simplify this.\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n    // Create component tree using the slice of the loaderTree\n    const seedData = await createComponentTree(\n      // This ensures flightRouterPath is valid and filters down the tree\n      {\n        ctx,\n        loaderTree: loaderTreeToFilter,\n        parentParams: currentParams,\n        injectedCSS,\n        injectedJS,\n        injectedFontPreloadTags,\n        // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n        rootLayoutIncluded,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        authInterrupts: experimental.authInterrupts,\n        StreamingMetadataOutlet,\n      }\n    )\n\n    return [\n      [\n        overriddenSegment,\n        routerState,\n        seedData,\n        rscHead,\n        false,\n      ] satisfies FlightDataSegment,\n    ]\n  }\n\n  // If we are not rendering on this level we need to check if the current\n  // segment has a layout. If so, we need to track all the used CSS to make\n  // the result consistent.\n  const layoutPath = layout?.[1]\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n  if (layoutPath) {\n    getLinkAndScriptTags(\n      ctx.clientReferenceManifest,\n      layoutPath,\n      injectedCSSWithCurrentLayout,\n      injectedJSWithCurrentLayout,\n      true\n    )\n    getPreloadableFonts(\n      nextFontManifest,\n      layoutPath,\n      injectedFontPreloadTagsWithCurrentLayout\n    )\n  }\n\n  const paths: FlightDataPath[] = []\n\n  // Walk through all parallel routes.\n  for (const parallelRouteKey of parallelRoutesKeys) {\n    const parallelRoute = parallelRoutes[parallelRouteKey]\n\n    const subPaths = await walkTreeWithFlightRouterState({\n      ctx,\n      loaderTreeToFilter: parallelRoute,\n      parentParams: currentParams,\n      flightRouterState:\n        flightRouterState && flightRouterState[1][parallelRouteKey],\n      parentIsInsideSharedLayout: isInsideSharedLayout,\n      rscHead,\n      injectedCSS: injectedCSSWithCurrentLayout,\n      injectedJS: injectedJSWithCurrentLayout,\n      injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n      rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n      getViewportReady,\n      getMetadataReady,\n      preloadCallbacks,\n      StreamingMetadataOutlet,\n    })\n\n    for (const subPath of subPaths) {\n      // we don't need to send over default routes in the flight data\n      // because they are always ignored by the client, unless it's a refetch\n      if (\n        subPath[0] === DEFAULT_SEGMENT_KEY &&\n        flightRouterState &&\n        !!flightRouterState[1][parallelRouteKey][0] &&\n        flightRouterState[1][parallelRouteKey][3] !== 'refetch'\n      ) {\n        continue\n      }\n\n      paths.push([actualSegment, parallelRouteKey, ...subPath])\n    }\n  }\n\n  return paths\n}\n\n/*\n * This function is used to determine if an existing segment can be overridden\n * by the incoming segment.\n */\nconst canSegmentBeOverridden = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n    return false\n  }\n\n  return getSegmentParam(existingSegment)?.param === segment[0]\n}\n"],"names":["walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","flightRouterState","parentIsInsideSharedLayout","rscHead","injectedCSS","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","getViewportReady","getMetadataReady","ctx","preloadCallbacks","StreamingMetadataOutlet","renderOpts","nextFontManifest","experimental","query","isPrefetch","getDynamicParamFromSegment","parsedRequestHeaders","segment","parallelRoutes","modules","parallelRoutesKeys","Object","keys","layout","isLayout","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","segmentParam","currentParams","value","param","actualSegment","addSearchParamsIfPageSegment","treeSegment","renderComponentsOnThisLevel","matchSegment","length","isInsideSharedLayout","isRoutePPREnabled","isRouteTreePrefetchRequest","Boolean","loading","hasLoadingComponentInTree","overriddenSegment","canSegmentBeOverridden","routerState","createFlightRouterStateFromLoaderTree","seedData","createComponentTree","loaderTree","authInterrupts","layoutPath","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","getLinkAndScriptTags","clientReferenceManifest","getPreloadableFonts","paths","parallelRouteKey","parallelRoute","subPaths","subPath","DEFAULT_SEGMENT_KEY","push","existingSegment","getSegmentParam","Array","isArray"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3859, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/postponed-state.ts"],"sourcesContent":["import type { FallbackRouteParams } from '../../server/request/fallback-params'\nimport type { Params } from '../request/params'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n  type PrerenderResumeDataCache,\n  type RenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nexport enum DynamicState {\n  /**\n   * The dynamic access occurred during the RSC render phase.\n   */\n  DATA = 1,\n\n  /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */\n  HTML = 2,\n}\n\n/**\n * The postponed state for dynamic data.\n */\nexport type DynamicDataPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.DATA\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\n/**\n * The postponed state for dynamic HTML.\n */\nexport type DynamicHTMLPostponedState = {\n  /**\n   * The type of dynamic state.\n   */\n  readonly type: DynamicState.HTML\n\n  /**\n   * The postponed data used by React.\n   */\n  readonly data: object\n\n  /**\n   * The immutable resume data cache.\n   */\n  readonly renderResumeDataCache: RenderResumeDataCache\n}\n\nexport type PostponedState =\n  | DynamicDataPostponedState\n  | DynamicHTMLPostponedState\n\nexport async function getDynamicHTMLPostponedState(\n  data: object,\n  fallbackRouteParams: FallbackRouteParams | null,\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n    const postponedString = JSON.stringify(data)\n\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(\n      createRenderResumeDataCache(prerenderResumeDataCache)\n    )}`\n  }\n\n  const replacements: Array<[string, string]> = Array.from(fallbackRouteParams)\n  const replacementsString = JSON.stringify(replacements)\n  const dataString = JSON.stringify(data)\n\n  // Serialized as `<replacements.length><replacements><data>`\n  const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n\n  // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n  return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(prerenderResumeDataCache)}`\n}\n\nexport async function getDynamicDataPostponedState(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): Promise<string> {\n  return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(prerenderResumeDataCache))}`\n}\n\nexport function parsePostponedState(\n  state: string,\n  params: Params | undefined\n): PostponedState {\n  try {\n    const postponedStringLengthMatch = state.match(/^([0-9]*):/)?.[1]\n    if (!postponedStringLengthMatch) {\n      throw new Error(`Invariant: invalid postponed state ${state}`)\n    }\n\n    const postponedStringLength = parseInt(postponedStringLengthMatch)\n\n    // We add a `:` to the end of the length as the first character of the\n    // postponed string is the length of the replacement entries.\n    const postponedString = state.slice(\n      postponedStringLengthMatch.length + 1,\n      postponedStringLengthMatch.length + postponedStringLength + 1\n    )\n\n    const renderResumeDataCache = createRenderResumeDataCache(\n      state.slice(postponedStringLengthMatch.length + postponedStringLength + 1)\n    )\n\n    try {\n      if (postponedString === 'null') {\n        return { type: DynamicState.DATA, renderResumeDataCache }\n      }\n\n      if (/^[0-9]/.test(postponedString)) {\n        const match = postponedString.match(/^([0-9]*)/)?.[1]\n        if (!match) {\n          throw new Error(\n            `Invariant: invalid postponed state ${JSON.stringify(postponedString)}`\n          )\n        }\n\n        // This is the length of the replacements entries.\n        const length = parseInt(match)\n        const replacements = JSON.parse(\n          postponedString.slice(\n            match.length,\n            // We then go to the end of the string.\n            match.length + length\n          )\n        ) as ReadonlyArray<[string, string]>\n\n        let postponed = postponedString.slice(match.length + length)\n        for (const [key, searchValue] of replacements) {\n          const value = params?.[key] ?? ''\n          const replaceValue = Array.isArray(value) ? value.join('/') : value\n          postponed = postponed.replaceAll(searchValue, replaceValue)\n        }\n\n        return {\n          type: DynamicState.HTML,\n          data: JSON.parse(postponed),\n          renderResumeDataCache,\n        }\n      }\n\n      return {\n        type: DynamicState.HTML,\n        data: JSON.parse(postponedString),\n        renderResumeDataCache,\n      }\n    } catch (err) {\n      console.error('Failed to parse postponed state', err)\n      return { type: DynamicState.DATA, renderResumeDataCache }\n    }\n  } catch (err) {\n    console.error('Failed to parse postponed state', err)\n    return {\n      type: DynamicState.DATA,\n      renderResumeDataCache: createPrerenderResumeDataCache(),\n    }\n  }\n}\n\nexport function getPostponedFromState(state: PostponedState): any {\n  if (state.type === DynamicState.DATA) {\n    return null\n  }\n\n  return state.data\n}\n"],"names":["DynamicState","getDynamicDataPostponedState","getDynamicHTMLPostponedState","getPostponedFromState","parsePostponedState","data","fallbackRouteParams","prerenderResumeDataCache","size","postponedString","JSON","stringify","length","stringifyResumeDataCache","createRenderResumeDataCache","replacements","Array","from","replacementsString","dataString","state","params","postponedStringLengthMatch","match","Error","postponedStringLength","parseInt","slice","renderResumeDataCache","type","test","parse","postponed","key","searchValue","value","replaceValue","isArray","join","replaceAll","err","console","error","createPrerenderResumeDataCache"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3999, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/use-flight-response.tsx"],"sourcesContent":["import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { BinaryStreamOf } from './app-render'\n\nimport { htmlEscapeJsonString } from '../htmlescape'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2\nconst INLINE_FLIGHT_PAYLOAD_BINARY = 3\n\nconst flightResponses = new WeakMap<BinaryStreamOf<any>, Promise<any>>()\nconst encoder = new TextEncoder()\n\n/**\n * Render Flight stream.\n * This is only used for renderToHTML, the Flight response does not need additional wrappers.\n */\nexport function useFlightStream<T>(\n  flightStream: BinaryStreamOf<T>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  nonce?: string\n): Promise<T> {\n  const response = flightResponses.get(flightStream)\n\n  if (response) {\n    return response\n  }\n\n  // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n  const { createFromReadableStream } =\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    require('react-server-dom-webpack/client.edge') as typeof import('react-server-dom-webpack/client.edge')\n\n  const newResponse = createFromReadableStream<T>(flightStream, {\n    serverConsumerManifest: {\n      moduleLoading: clientReferenceManifest.moduleLoading,\n      moduleMap: isEdgeRuntime\n        ? clientReferenceManifest.edgeSSRModuleMapping\n        : clientReferenceManifest.ssrModuleMapping,\n      serverModuleMap: null,\n    },\n    nonce,\n  })\n\n  flightResponses.set(flightStream, newResponse)\n\n  return newResponse\n}\n\n/**\n * Creates a ReadableStream provides inline script tag chunks for writing hydration\n * data to the client outside the React render itself.\n *\n * @param flightStream The RSC render stream\n * @param nonce optionally a nonce used during this particular render\n * @param formState optionally the formState used with this particular render\n * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream\n */\nexport function createInlinedDataReadableStream(\n  flightStream: ReadableStream<Uint8Array>,\n  nonce: string | undefined,\n  formState: unknown | null\n): ReadableStream<Uint8Array> {\n  const startScriptTag = nonce\n    ? `<script nonce=${JSON.stringify(nonce)}>`\n    : '<script>'\n\n  const flightReader = flightStream.getReader()\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n\n  const readable = new ReadableStream({\n    type: 'bytes',\n    start(controller) {\n      try {\n        writeInitialInstructions(controller, startScriptTag, formState)\n      } catch (error) {\n        // during encoding or enqueueing forward the error downstream\n        controller.error(error)\n      }\n    },\n    async pull(controller) {\n      try {\n        const { done, value } = await flightReader.read()\n\n        if (value) {\n          try {\n            const decodedString = decoder.decode(value, { stream: !done })\n\n            // The chunk cannot be decoded as valid UTF-8 string as it might\n            // have arbitrary binary data.\n            writeFlightDataInstruction(\n              controller,\n              startScriptTag,\n              decodedString\n            )\n          } catch {\n            // The chunk cannot be decoded as valid UTF-8 string.\n            writeFlightDataInstruction(controller, startScriptTag, value)\n          }\n        }\n\n        if (done) {\n          controller.close()\n        }\n      } catch (error) {\n        // There was a problem in the upstream reader or during decoding or enqueuing\n        // forward the error downstream\n        controller.error(error)\n      }\n    },\n  })\n\n  return readable\n}\n\nfunction writeInitialInstructions(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  formState: unknown | null\n) {\n  if (formState != null) {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )});self.__next_f.push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_FORM_STATE, formState])\n        )})</script>`\n      )\n    )\n  } else {\n    controller.enqueue(\n      encoder.encode(\n        `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n          JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n        )})</script>`\n      )\n    )\n  }\n}\n\nfunction writeFlightDataInstruction(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  chunk: string | Uint8Array\n) {\n  let htmlInlinedData: string\n\n  if (typeof chunk === 'string') {\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_DATA, chunk])\n    )\n  } else {\n    // The chunk cannot be embedded as a UTF-8 string in the script tag.\n    // Instead let's inline it in base64.\n    // Credits to Devon Govett (devongovett) for the technique.\n    // https://github.com/devongovett/rsc-html-stream\n    const base64 = btoa(String.fromCodePoint(...chunk))\n    htmlInlinedData = htmlEscapeJsonString(\n      JSON.stringify([INLINE_FLIGHT_PAYLOAD_BINARY, base64])\n    )\n  }\n\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}self.__next_f.push(${htmlInlinedData})</script>`\n    )\n  )\n}\n"],"names":["createInlinedDataReadableStream","useFlightStream","isEdgeRuntime","process","env","NEXT_RUNTIME","INLINE_FLIGHT_PAYLOAD_BOOTSTRAP","INLINE_FLIGHT_PAYLOAD_DATA","INLINE_FLIGHT_PAYLOAD_FORM_STATE","INLINE_FLIGHT_PAYLOAD_BINARY","flightResponses","WeakMap","encoder","TextEncoder","flightStream","clientReferenceManifest","nonce","response","get","createFromReadableStream","require","newResponse","serverConsumerManifest","moduleLoading","moduleMap","edgeSSRModuleMapping","ssrModuleMapping","serverModuleMap","set","formState","startScriptTag","JSON","stringify","flightReader","getReader","decoder","TextDecoder","fatal","readable","ReadableStream","type","start","controller","writeInitialInstructions","error","pull","done","value","read","decodedString","decode","stream","writeFlightDataInstruction","close","scriptStart","enqueue","encode","htmlEscapeJsonString","chunk","htmlInlinedData","base64","btoa","String","fromCodePoint"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4130, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/prospective-render-utils.ts"],"sourcesContent":["import { getDigestForWellKnownError } from './create-error-handler'\n\nexport function printDebugThrownValueForProspectiveRender(\n  thrownValue: unknown,\n  route: string\n) {\n  // We don't need to print well-known Next.js errors.\n  if (getDigestForWellKnownError(thrownValue)) {\n    return\n  }\n\n  let message: undefined | string\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    typeof (thrownValue as any).message === 'string'\n  ) {\n    message = (thrownValue as any).message\n    if (typeof (thrownValue as any).stack === 'string') {\n      const originalErrorStack: string = (thrownValue as any).stack\n      const stackStart = originalErrorStack.indexOf('\\n')\n      if (stackStart > -1) {\n        const error = new Error(\n          `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled.\n          \nOriginal Error: ${message}`\n        )\n        error.stack =\n          'Error: ' + error.message + originalErrorStack.slice(stackStart)\n        console.error(error)\n        return\n      }\n    }\n  } else if (typeof thrownValue === 'string') {\n    message = thrownValue\n  }\n\n  if (message) {\n    console.error(`Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. No stack was provided.\n          \nOriginal Message: ${message}`)\n    return\n  }\n\n  console.error(\n    `Route ${route} errored during the prospective render. These errors are normally ignored and may not prevent the route from prerendering but are logged here because build debugging is enabled. The thrown value is logged just following this message`\n  )\n  console.error(thrownValue)\n  return\n}\n"],"names":["printDebugThrownValueForProspectiveRender","thrownValue","route","getDigestForWellKnownError","message","stack","originalErrorStack","stackStart","indexOf","error","Error","slice","console"],"mappings":";;;;+BAEgBA,6CAAAA;;;eAAAA;;;oCAF2B;AAEpC,SAASA,0CACdC,WAAoB,EACpBC,KAAa;IAEb,oDAAoD;IACpD,IAAIC,CAAAA,GAAAA,oBAAAA,0BAA0B,EAACF,cAAc;QAC3C;IACF;IAEA,IAAIG;IACJ,IACE,OAAOH,gBAAgB,YACvBA,gBAAgB,QAChB,OAAQA,YAAoBG,OAAO,KAAK,UACxC;QACAA,UAAWH,YAAoBG,OAAO;QACtC,IAAI,OAAQH,YAAoBI,KAAK,KAAK,UAAU;YAClD,MAAMC,qBAA8BL,YAAoBI,KAAK;YAC7D,MAAME,aAAaD,mBAAmBE,OAAO,CAAC;YAC9C,IAAID,aAAa,CAAC,GAAG;gBACnB,MAAME,QAAQ,OAAA,cAIb,CAJa,IAAIC,MAChB,CAAC,MAAM,EAAER,MAAM;;gBAET,EAAEE,SAAS,GAHL,qBAAA;2BAAA;gCAAA;kCAAA;gBAId;gBACAK,MAAMJ,KAAK,GACT,YAAYI,MAAML,OAAO,GAAGE,mBAAmBK,KAAK,CAACJ;gBACvDK,QAAQH,KAAK,CAACA;gBACd;YACF;QACF;IACF,OAAO,IAAI,OAAOR,gBAAgB,UAAU;QAC1CG,UAAUH;IACZ;IAEA,IAAIG,SAAS;QACXQ,QAAQH,KAAK,CAAC,CAAC,MAAM,EAAEP,MAAM;;kBAEf,EAAEE,SAAS;QACzB;IACF;IAEAQ,QAAQH,KAAK,CACX,CAAC,MAAM,EAAEP,MAAM,wOAAwO,CAAC;IAE1PU,QAAQH,KAAK,CAACR;IACd;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4183, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/cache-signal.ts"],"sourcesContent":["/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the dynamicIO flag is on\n * and should only be used in codepaths gated with this feature.\n */\n\nexport class CacheSignal {\n  private count: number\n  private earlyListeners: Array<() => void>\n  private listeners: Array<() => void>\n  private tickPending: boolean\n  private taskPending: boolean\n\n  constructor() {\n    this.count = 0\n    this.earlyListeners = []\n    this.listeners = []\n    this.tickPending = false\n    this.taskPending = false\n  }\n\n  private noMorePendingCaches() {\n    if (!this.tickPending) {\n      this.tickPending = true\n      process.nextTick(() => {\n        this.tickPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.earlyListeners.length; i++) {\n            this.earlyListeners[i]()\n          }\n          this.earlyListeners.length = 0\n        }\n      })\n    }\n    if (!this.taskPending) {\n      this.taskPending = true\n      setTimeout(() => {\n        this.taskPending = false\n        if (this.count === 0) {\n          for (let i = 0; i < this.listeners.length; i++) {\n            this.listeners[i]()\n          }\n          this.listeners.length = 0\n        }\n      }, 0)\n    }\n  }\n\n  /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */\n  inputReady() {\n    return new Promise<void>((resolve) => {\n      this.earlyListeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */\n  cacheReady() {\n    return new Promise<void>((resolve) => {\n      this.listeners.push(resolve)\n      if (this.count === 0) {\n        this.noMorePendingCaches()\n      }\n    })\n  }\n\n  beginRead() {\n    this.count++\n  }\n\n  endRead() {\n    // If this is the last read we need to wait a task before we can claim the cache is settled.\n    // The cache read will likely ping a Server Component which can read from the cache again and this\n    // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n    // after at least one task.\n    // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n    // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n    this.count--\n    if (this.count === 0) {\n      this.noMorePendingCaches()\n    }\n  }\n}\n"],"names":["CacheSignal","constructor","count","earlyListeners","listeners","tickPending","taskPending","noMorePendingCaches","process","nextTick","i","length","setTimeout","inputReady","Promise","resolve","push","cacheReady","beginRead","endRead"],"mappings":"AAAA;;;;;CAKC,GAAA;;;;+BAEYA,eAAAA;;;eAAAA;;;AAAN,MAAMA;IAOXC,aAAc;QACZ,IAAI,CAACC,KAAK,GAAG;QACb,IAAI,CAACC,cAAc,GAAG,EAAE;QACxB,IAAI,CAACC,SAAS,GAAG,EAAE;QACnB,IAAI,CAACC,WAAW,GAAG;QACnB,IAAI,CAACC,WAAW,GAAG;IACrB;IAEQC,sBAAsB;QAC5B,IAAI,CAAC,IAAI,CAACF,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBG,QAAQC,QAAQ,CAAC;gBACf,IAAI,CAACJ,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACH,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACP,cAAc,CAACQ,MAAM,EAAED,IAAK;wBACnD,IAAI,CAACP,cAAc,CAACO,EAAE;oBACxB;oBACA,IAAI,CAACP,cAAc,CAACQ,MAAM,GAAG;gBAC/B;YACF;QACF;QACA,IAAI,CAAC,IAAI,CAACL,WAAW,EAAE;YACrB,IAAI,CAACA,WAAW,GAAG;YACnBM,WAAW;gBACT,IAAI,CAACN,WAAW,GAAG;gBACnB,IAAI,IAAI,CAACJ,KAAK,KAAK,GAAG;oBACpB,IAAK,IAAIQ,IAAI,GAAGA,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAED,IAAK;wBAC9C,IAAI,CAACN,SAAS,CAACM,EAAE;oBACnB;oBACA,IAAI,CAACN,SAAS,CAACO,MAAM,GAAG;gBAC1B;YACF,GAAG;QACL;IACF;IAEA;;;GAGC,GACDE,aAAa;QACX,OAAO,IAAIC,QAAc,CAACC;YACxB,IAAI,CAACZ,cAAc,CAACa,IAAI,CAACD;YACzB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEA;;;;GAIC,GACDU,aAAa;QACX,OAAO,IAAIH,QAAc,CAACC;YACxB,IAAI,CAACX,SAAS,CAACY,IAAI,CAACD;YACpB,IAAI,IAAI,CAACb,KAAK,KAAK,GAAG;gBACpB,IAAI,CAACK,mBAAmB;YAC1B;QACF;IACF;IAEAW,YAAY;QACV,IAAI,CAAChB,KAAK;IACZ;IAEAiB,UAAU;QACR,4FAA4F;QAC5F,kGAAkG;QAClG,gGAAgG;QAChG,2BAA2B;QAC3B,+GAA+G;QAC/G,mHAAmH;QACnH,IAAI,CAACjB,KAAK;QACV,IAAI,IAAI,CAACA,KAAK,KAAK,GAAG;YACpB,IAAI,CAACK,mBAAmB;QAC1B;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from './types'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  ClientReferenceManifest,\n  ManifestNode,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HASH_COOKIE,\n} from '../../client/components/app-router-headers'\nimport {\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  getFirstDynamicReason,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  consumeDynamicAccess,\n  type DynamicAccess,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../client/components/app-router-instance'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { ServerPrerenderStreamResult } from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n  prerenderServerWithPhases,\n  prerenderClientWithPhases,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport './clean-async-snapshot.external'\nimport { INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\nimport { getPreviouslyRevalidatedTags } from '../server-utils'\nimport { executeRevalidates } from '../revalidation-utils'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isPossibleServerAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n  /**\n   * For now, the implicit tags are common for the whole route. If we ever start\n   * rendering/revalidating segments independently, they need to move to the\n   * work unit store.\n   */\n  implicitTags: ImplicitTags\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n  readonly previewModeId: string | undefined\n}\n\nconst flightDataPathHeadKey = 'h'\nconst getFlightViewportKey = (requestId: string) => requestId + 'v'\nconst getFlightMetadataKey = (requestId: string) => requestId + 'm'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n  readonly previouslyRevalidatedTags: string[]\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isPrefetchRequest =\n    isDevWarmupRequest ||\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest =\n    isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n    headers,\n    options.previewModeId\n  )\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n    previouslyRevalidatedTags,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({\n  pagePath,\n  statusCode,\n  isPossibleServerAction,\n}: {\n  pagePath: string\n  statusCode: number | undefined\n  isPossibleServerAction: boolean\n}) {\n  const is404Page = pagePath === '/404'\n  const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  // TODO: is this correct if `isPossibleServerAction` is a false positive?\n  if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const {\n      ViewportTree,\n      MetadataTree,\n      getViewportReady,\n      getMetadataReady,\n      StreamingMetadataOutlet,\n    } = createMetadataComponents({\n      tree: loaderTree,\n      parsedQuery: query,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        workStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      workStore,\n      MetadataBoundary,\n      ViewportBoundary,\n      serveStreamingMetadata,\n    })\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            {/* noindex needs to be blocking */}\n            <NonIndex\n              pagePath={ctx.pagePath}\n              statusCode={ctx.res.statusCode}\n              isPossibleServerAction={ctx.isPossibleServerAction}\n            />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <ViewportTree key={getFlightViewportKey(requestId)} />\n            {/* Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed */}\n            <MetadataTree key={getFlightMetadataKey(requestId)} />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        StreamingMetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during dynamicIO development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  if (\n    // We only want this behavior when running `next dev`\n    renderOpts.dev &&\n    // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' &&\n    // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO\n  ) {\n    const [resolveValidation, validationOutlet] = createValidationOutlet()\n    RSCPayload._validation = validationOutlet\n\n    spawnDynamicValidationInDev(\n      resolveValidation,\n      ctx.componentMod.tree,\n      ctx,\n      false,\n      ctx.clientReferenceManifest,\n      ctx.workStore.route,\n      requestStore\n    )\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    ctx.componentMod.renderToReadableStream,\n    RSCPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext\n): Promise<RenderResult> {\n  const {\n    clientReferenceManifest,\n    componentMod,\n    getDynamicParamFromSegment,\n    implicitTags,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  if (!renderOpts.dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  const rootParams = getRootParams(\n    componentMod.tree,\n    getDynamicParamFromSegment\n  )\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  // We're doing a dev warmup, so we should create a new resume data cache so\n  // we can fill it.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const renderController = new AbortController()\n  const prerenderController = new AbortController()\n  const cacheSignal = new CacheSignal()\n\n  const prerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: renderController.signal,\n    controller: prerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash: req.cookies[NEXT_HMR_REFRESH_HASH_COOKIE],\n  }\n\n  const rscPayload = await workUnitAsyncStorage.run(\n    prerenderStore,\n    generateDynamicRSCPayload,\n    ctx\n  )\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  workUnitAsyncStorage.run(\n    prerenderStore,\n    componentMod.renderToReadableStream,\n    rscPayload,\n    clientReferenceManifest.clientModules,\n    {\n      onError,\n      signal: renderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling\n  await cacheSignal.cacheReady()\n  // We unset the cache so any late over-run renders aren't able to write into this cache\n  prerenderStore.prerenderResumeDataCache = null\n  // Abort the render\n  renderController.abort()\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: workStore.fetchMetrics,\n    devRenderResumeDataCache: createRenderResumeDataCache(\n      prerenderResumeDataCache\n    ),\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  const {\n    ViewportTree,\n    MetadataTree,\n    getViewportReady,\n    getMetadataReady,\n    StreamingMetadataOutlet,\n  } = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    parsedQuery: query,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      workStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getViewportReady,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    StreamingMetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      <ViewportTree key={getFlightViewportKey(ctx.requestId)} />\n      {/* Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed */}\n      <MetadataTree />\n    </React.Fragment>\n  )\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    requestId,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const { MetadataTree, ViewportTree } = createMetadataComponents({\n    tree,\n    parsedQuery: query,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  // {/* Adding requestId as react key to make metadata remount for each render */}\n  const metadata = <MetadataTree key={getFlightMetadataKey(requestId)} />\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <ViewportTree key={getFlightViewportKey(requestId)} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n      {metadata}\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head>{metadata}</head>\n      <body>\n        {process.env.NODE_ENV !== 'production' && err ? (\n          <template\n            data-next-error-message={err.message}\n            data-next-error-digest={'digest' in err ? err.digest : ''}\n            data-next-error-stack={err.stack}\n          />\n        ) : null}\n      </body>\n    </html>,\n    {},\n    null,\n    false,\n  ]\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n  ServerInsertedHTMLProvider,\n  ServerInsertedMetadataProvider,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedMetadataProvider>\n        <ServerInsertedHTMLProvider>\n          <AppRouter\n            actionQueue={actionQueue}\n            globalErrorComponentAndStyles={response.G}\n            assetPrefix={response.p}\n          />\n        </ServerInsertedHTMLProvider>\n      </ServerInsertedMetadataProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  ServerInsertedMetadataProvider,\n  ServerInsertedHTMLProvider,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  return (\n    <ServerInsertedMetadataProvider>\n      <ServerInsertedHTMLProvider>\n        <AppRouter\n          actionQueue={actionQueue}\n          globalErrorComponentAndStyles={response.G}\n          assetPrefix={response.p}\n        />\n      </ServerInsertedHTMLProvider>\n    </ServerInsertedMetadataProvider>\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n\n  setReferenceManifestsSingleton({\n    page: workStore.page,\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = workStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isPossibleActionRequest = getIsPossibleServerAction(req)\n\n  const implicitTags = await getImplicitTags(\n    workStore.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isPossibleServerAction: isPossibleActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n    implicitTags,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      workStore,\n      loaderTree\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (workStore.invalidUsageError) {\n      throw workStore.invalidUsageError\n    }\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    if (response.collectedTags) {\n      metadata.fetchTags = response.collectedTags.join(',')\n    }\n\n    // Let the client router know how long to keep the cached entry around.\n    const staleHeader = String(response.collectedStale)\n    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n    metadata.headers ??= {}\n    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n      metadata.cacheControl = { revalidate: 0, expire: undefined }\n    } else {\n      // Copy the cache control value onto the render result metadata.\n      metadata.cacheControl = {\n        revalidate:\n          response.collectedRevalidate >= INFINITE_CACHE\n            ? false\n            : response.collectedRevalidate,\n        expire:\n          response.collectedExpire >= INFINITE_CACHE\n            ? undefined\n            : response.collectedExpire,\n      }\n    }\n\n    // provide bailout info for debugging\n    if (metadata.cacheControl?.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: workStore.dynamicUsageDescription,\n        stack: workStore.dynamicUsageStack,\n      }\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.devRenderResumeDataCache ??\n      postponedState?.renderResumeDataCache\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const requestStore = createRequestStoreForRender(\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache\n    )\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req) &&\n      !isDevWarmupRequest\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        if (!requestStore.usedDynamic && !workStore.forceDynamic) {\n          // only node can be ISR so we only need to update the status here\n          const { pathname } = new URL(req.url || '/', 'http://n')\n          setIsrStatus(pathname, true)\n        }\n      })\n    }\n\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx, requestStore)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isPossibleActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            workStore,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      workStore,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    if (workStore.invalidUsageError) {\n      throw workStore.invalidUsageError\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  isDevWarmup: boolean,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  isDevWarmup,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n    previewModeId: renderOpts.previewProps?.previewModeId,\n  })\n\n  const { isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.devRenderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n    previouslyRevalidatedTags,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    requestEndedState,\n    postponedState,\n    serverComponentsHmrCache,\n    sharedContext\n  )\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n  const appendHeader = res.appendHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      renderOpts.dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into dynamicIO\n      renderOpts.experimental.dynamicIO\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during dynamicIO development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n              filterStackFrame(url: string, _functionName: string): boolean {\n                // The default implementation filters out <anonymous> stack frames\n                // but we want to retain them because current Server Components and\n                // built-in Components in parent stacks don't have source location.\n                return !url.startsWith('node:') && !url.includes('node_modules')\n              },\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      spawnDynamicValidationInDev(\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        workStore.route,\n        requestStore\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            appendHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        bootstrapScripts: [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML =\n      renderOpts.supportsDynamicResponse !== true ||\n      !!renderOpts.shouldWaitOnAllReady\n\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      getServerInsertedMetadata,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer: require('react-dom/server.edge'),\n          element: (\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={ctx.nonce}\n            />\n          ),\n          streamOptions: {\n            nonce: ctx.nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        renderOpts.supportsDynamicResponse !== true ||\n        !!renderOpts.shouldWaitOnAllReady\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        getServerInsertedMetadata,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  route: string,\n  requestStore: RequestStore\n): Promise<void> {\n  const { componentMod: ComponentMod, implicitTags } = ctx\n  const rootParams = getRootParams(\n    ComponentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  const hmrRefreshHash = requestStore.cookies.get(\n    NEXT_HMR_REFRESH_HASH_COOKIE\n  )?.value\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  const cacheSignal = new CacheSignal()\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  const initialServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const initialClientController = new AbortController()\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialClientController.signal,\n    controller: initialClientController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  let initialServerStream\n  try {\n    initialServerStream = workUnitAsyncStorage.run(\n      initialServerPrerenderStore,\n      ComponentMod.renderToReadableStream,\n      firstAttemptRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // The render aborted before this error was handled which indicates\n            // the error is caused by unfinished components within the render\n            return\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n        signal: initialServerRenderController.signal,\n      }\n    )\n  } catch (err: unknown) {\n    if (\n      initialServerPrerenderController.signal.aborted ||\n      initialServerRenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, route)\n    }\n  }\n\n  const nonce = '1'\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n\n  if (initialServerStream) {\n    const [warmupStream, renderStream] = initialServerStream.tee()\n    initialServerStream = null\n    // Before we attempt the SSR initial render we need to ensure all client modules\n    // are already loaded.\n    await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    const pendingInitialClientResult = workUnitAsyncStorage.run(\n      initialClientPrerenderStore,\n      prerender,\n      <App\n        reactServerStream={renderStream}\n        preinitScripts={() => {}}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        nonce={nonce}\n      />,\n      {\n        signal: initialClientController.signal,\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (initialClientController.signal.aborted) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n      }\n    )\n    pendingInitialClientResult.catch((err: unknown) => {\n      if (initialClientController.signal.aborted) {\n        // We aborted the render normally and can ignore this error\n      } else {\n        // We're going to retry to so we normally would suppress this error but\n        // when verbose logging is on we print it\n        if (process.env.__NEXT_VERBOSE_LOGGING) {\n          printDebugThrownValueForProspectiveRender(err, route)\n        }\n      }\n    })\n  }\n\n  await cacheSignal.cacheReady()\n  // It is important that we abort the SSR render first to avoid\n  // connection closed errors from having an incomplete RSC stream\n  initialClientController.abort()\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We've now filled caches and triggered any inadvertent sync bailouts\n  // due to lazy module initialization. We can restart our render to capture results\n\n  const finalServerController = new AbortController()\n  const serverDynamicTracking = createDynamicTrackingState(false)\n\n  const finalServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const finalClientController = new AbortController()\n  const clientDynamicTracking = createDynamicTrackingState(false)\n  const dynamicValidation = createDynamicValidationState()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalClientController.signal,\n    controller: finalClientController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const finalServerPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const serverPrerenderStreamResult = await prerenderServerWithPhases(\n    finalServerController.signal,\n    () =>\n      workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.renderToReadableStream,\n        finalServerPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: (err) => {\n            if (isUseCacheTimeoutError(err)) {\n              return err.digest\n            }\n\n            if (\n              finalServerController.signal.aborted &&\n              isPrerenderInterruptedError(err)\n            ) {\n              return err.digest\n            }\n\n            return getDigestForWellKnownError(err)\n          },\n          signal: finalServerController.signal,\n        }\n      ),\n    () => {\n      finalServerController.abort()\n    }\n  )\n\n  let rootDidError = false\n  const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n  try {\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    await prerenderClientWithPhases(\n      () =>\n        workUnitAsyncStorage.run(\n          finalClientPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={serverPhasedStream}\n            preinitScripts={() => {}}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n          />,\n          {\n            signal: finalClientController.signal,\n            onError: (err, errorInfo) => {\n              if (isUseCacheTimeoutError(err)) {\n                dynamicValidation.dynamicErrors.push(err)\n\n                return\n              }\n\n              if (\n                isPrerenderInterruptedError(err) ||\n                finalClientController.signal.aborted\n              ) {\n                if (!rootDidError) {\n                  // If the root errored before we observe this error then it wasn't caused by something dynamic.\n                  // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n                  // then we are a dynamic route.\n                  requestStore.usedDynamic = true\n                }\n\n                const componentStack = errorInfo.componentStack\n                if (typeof componentStack === 'string') {\n                  trackAllowedDynamicAccess(\n                    route,\n                    componentStack,\n                    dynamicValidation,\n                    serverDynamicTracking,\n                    clientDynamicTracking\n                  )\n                }\n                return\n              }\n\n              return getDigestForWellKnownError(err)\n            },\n          }\n        ),\n      () => {\n        finalClientController.abort()\n        serverPhasedStream.assertExhausted()\n      }\n    )\n  } catch (err) {\n    rootDidError = true\n    if (\n      isPrerenderInterruptedError(err) ||\n      finalClientController.signal.aborted\n    ) {\n      // we don't have a root because the abort errored in the root. We can just ignore this error\n    } else {\n      // If an error is thrown in the root before prerendering is aborted, we\n      // don't want to rethrow it here, otherwise this would lead to a hanging\n      // response and unhandled rejection. We also don't want to log it, because\n      // it's most likely already logged as part of the normal render. So we\n      // just fall through here, to make sure `resolveValidation` is called.\n    }\n  }\n\n  function LogDynamicValidation() {\n    try {\n      throwIfDisallowedDynamic(\n        route,\n        dynamicValidation,\n        serverDynamicTracking,\n        clientDynamicTracking\n      )\n    } catch {}\n    return null\n  }\n\n  resolveValidation(<LogDynamicValidation />)\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore,\n  tree: LoaderTree\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const {\n    assetPrefix,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    pagePath,\n    renderOpts,\n  } = ctx\n\n  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = workStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult:\n    | null\n    | ReactServerPrerenderResult\n    | ServerPrerenderStreamResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  const selectStaleTime = (stale: number) =>\n    stale === INFINITE_CACHE &&\n    typeof renderOpts.experimental.staleTimes?.static === 'number'\n      ? renderOpts.experimental.staleTimes.static\n      : stale\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        // The cacheSignal helps us track whether caches are still filling or we are ready\n        // to cut the render off.\n        const cacheSignal = new CacheSignal()\n\n        // The resume data cache here should use a fresh instance as it's\n        // performing a fresh prerender. If we get to implementing the\n        // prerendering of an already prerendered page, we should use the passed\n        // resume data cache instead.\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const initialServerPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const pendingInitialServerResult = workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          ComponentMod.prerender,\n          initialServerPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (initialServerPrerenderController.signal.aborted) {\n                // The render aborted before this error was handled which indicates\n                // the error is caused by unfinished components within the render\n                return\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            },\n            // we don't care to track postpones during the prospective render because we need\n            // to always do a final render anyway\n            onPostpone: undefined,\n            // We don't want to stop rendering until the cacheSignal is complete so we pass\n            // a different signal to this render call than is used by dynamic APIs to signify\n            // transitioning out of the prerender environment\n            signal: initialServerRenderController.signal,\n          }\n        )\n\n        await cacheSignal.cacheReady()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        let initialServerResult\n        try {\n          initialServerResult = await createReactServerPrerenderResult(\n            pendingInitialServerResult\n          )\n        } catch (err) {\n          if (\n            initialServerRenderController.signal.aborted ||\n            initialServerPrerenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerResult) {\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(\n            initialServerResult.asStream(),\n            clientReferenceManifest\n          )\n\n          const initialClientController = new AbortController()\n          const initialClientPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            rootParams,\n            implicitTags,\n            renderSignal: initialClientController.signal,\n            controller: initialClientController,\n            cacheSignal: null,\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...implicitTags.tags],\n            prerenderResumeDataCache,\n            hmrRefreshHash: undefined,\n          }\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                initialClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={initialServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={nonce}\n                />,\n                {\n                  signal: initialClientController.signal,\n                  onError: (err) => {\n                    const digest = getDigestForWellKnownError(err)\n\n                    if (digest) {\n                      return digest\n                    }\n\n                    if (initialClientController.signal.aborted) {\n                      // These are expected errors that might error the prerender. we ignore them.\n                    } else if (\n                      process.env.NEXT_DEBUG_BUILD ||\n                      process.env.__NEXT_VERBOSE_LOGGING\n                    ) {\n                      // We don't normally log these errors because we are going to retry anyway but\n                      // it can be useful for debugging Next.js itself to get visibility here when needed\n                      printDebugThrownValueForProspectiveRender(\n                        err,\n                        workStore.route\n                      )\n                    }\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              initialClientController.abort()\n            }\n          ).catch((err) => {\n            if (\n              initialServerRenderController.signal.aborted ||\n              isPrerenderInterruptedError(err)\n            ) {\n              // These are expected errors that might error the prerender. we ignore them.\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              // We don't normally log these errors because we are going to retry anyway but\n              // it can be useful for debugging Next.js itself to get visibility here when needed\n              printDebugThrownValueForProspectiveRender(err, workStore.route)\n            }\n          })\n        }\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        let prerenderIsPending = true\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              async () => {\n                const prerenderResult = await workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: (err: unknown) => {\n                      return serverComponentsErrorHandler(err)\n                    },\n                    signal: finalServerController.signal,\n                  }\n                )\n                prerenderIsPending = false\n                return prerenderResult\n              },\n              () => {\n                if (finalServerController.signal.aborted) {\n                  // If the server controller is already aborted we must have called something\n                  // that required aborting the prerender synchronously such as with new Date()\n                  serverIsDynamic = true\n                  return\n                }\n\n                if (prerenderIsPending) {\n                  // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                  // there is something unfinished.\n                  serverIsDynamic = true\n                }\n                finalServerController.abort()\n              }\n            )\n          ))\n\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const finalClientController = new AbortController()\n        const finalClientPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        }\n\n        let clientIsDynamic = false\n        let dynamicValidation = createDynamicValidationState()\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n          () =>\n            workUnitAsyncStorage.run(\n              finalClientPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={nonce}\n              />,\n              {\n                signal: finalClientController.signal,\n                onError: (err: unknown, errorInfo: ErrorInfo) => {\n                  if (\n                    isPrerenderInterruptedError(err) ||\n                    finalClientController.signal.aborted\n                  ) {\n                    clientIsDynamic = true\n\n                    const componentStack: string | undefined = (\n                      errorInfo as any\n                    ).componentStack\n                    if (typeof componentStack === 'string') {\n                      trackAllowedDynamicAccess(\n                        workStore.route,\n                        componentStack,\n                        dynamicValidation,\n                        serverDynamicTracking,\n                        clientDynamicTracking\n                      )\n                    }\n                    return\n                  }\n\n                  return htmlRendererErrorHandler(err, errorInfo)\n                },\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    appendHeader(key, value)\n                  })\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                bootstrapScripts: [bootstrapScript],\n              }\n            ),\n          () => {\n            finalClientController.abort()\n          }\n        )\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalRenderPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = await getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams,\n              prerenderResumeDataCache\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = await getDynamicDataPostponedState(\n              prerenderResumeDataCache\n            )\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        } else {\n          // Static case\n          if (workStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                nonce={nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = workStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        const cacheSignal = new CacheSignal()\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const initialClientController = new AbortController()\n        const initialClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialClientController.signal,\n          controller: initialClientController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        let initialServerStream\n        try {\n          initialServerStream = workUnitAsyncStorage.run(\n            initialServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (\n                  initialServerPrerenderController.signal.aborted ||\n                  initialServerRenderController.signal.aborted\n                ) {\n                  // The render aborted before this error was handled which indicates\n                  // the error is caused by unfinished components within the render\n                  return\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              signal: initialServerRenderController.signal,\n            }\n          )\n        } catch (err: unknown) {\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerStream) {\n          const [warmupStream, renderStream] = initialServerStream.tee()\n          initialServerStream = null\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const pendingInitialClientResult = workUnitAsyncStorage.run(\n            initialClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={nonce}\n            />,\n            {\n              signal: initialClientController.signal,\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (initialClientController.signal.aborted) {\n                  // These are expected errors that might error the prerender. we ignore them.\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  // We don't normally log these errors because we are going to retry anyway but\n                  // it can be useful for debugging Next.js itself to get visibility here when needed\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              bootstrapScripts: [bootstrapScript],\n            }\n          )\n          pendingInitialClientResult.catch((err: unknown) => {\n            if (initialClientController.signal.aborted) {\n              // We aborted the render normally and can ignore this error\n            } else {\n              // We're going to retry to so we normally would suppress this error but\n              // when verbose logging is on we print it\n              if (process.env.__NEXT_VERBOSE_LOGGING) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            }\n          })\n        }\n\n        await cacheSignal.cacheReady()\n        // It is important that we abort the SSR render first to avoid\n        // connection closed errors from having an incomplete RSC stream\n        initialClientController.abort()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        // We've now filled caches and triggered any inadvertant sync bailouts\n        // due to lazy module initialization. We can restart our render to capture results\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        let clientIsDynamic = false\n        const finalClientController = new AbortController()\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const dynamicValidation = createDynamicValidationState()\n\n        const finalClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const finalServerPayload = await workUnitAsyncStorage.run(\n          finalServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const serverPrerenderStreamResult = (reactServerPrerenderResult =\n          await prerenderServerWithPhases(\n            finalServerController.signal,\n            () =>\n              workUnitAsyncStorage.run(\n                finalServerPrerenderStore,\n                ComponentMod.renderToReadableStream,\n                finalServerPayload,\n                clientReferenceManifest.clientModules,\n                {\n                  onError: (err: unknown) => {\n                    if (finalServerController.signal.aborted) {\n                      serverIsDynamic = true\n                      if (isPrerenderInterruptedError(err)) {\n                        return err.digest\n                      }\n                      return getDigestForWellKnownError(err)\n                    }\n\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerController.signal,\n                }\n              ),\n            () => {\n              finalServerController.abort()\n            }\n          ))\n\n        let htmlStream\n        const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n        try {\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const result = await prerenderClientWithPhases(\n            () =>\n              workUnitAsyncStorage.run(\n                finalClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={serverPhasedStream}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  nonce={nonce}\n                />,\n                {\n                  signal: finalClientController.signal,\n                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n                    if (\n                      isPrerenderInterruptedError(err) ||\n                      finalClientController.signal.aborted\n                    ) {\n                      clientIsDynamic = true\n\n                      const componentStack: string | undefined = (\n                        errorInfo as any\n                      ).componentStack\n                      if (typeof componentStack === 'string') {\n                        trackAllowedDynamicAccess(\n                          workStore.route,\n                          componentStack,\n                          dynamicValidation,\n                          serverDynamicTracking,\n                          clientDynamicTracking\n                        )\n                      }\n                      return\n                    }\n\n                    return htmlRendererErrorHandler(err, errorInfo)\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              finalClientController.abort()\n              serverPhasedStream.assertExhausted()\n            }\n          )\n          htmlStream = result.prelude\n        } catch (err) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            finalClientController.signal.aborted\n          ) {\n            // we don't have a root because the abort errored in the root. We can just ignore this error\n          } else {\n            // This error is something else and should bubble up\n            throw err\n          }\n        }\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          const dynamicReason = serverIsDynamic\n            ? getFirstDynamicReason(serverDynamicTracking)\n            : getFirstDynamicReason(clientDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          }\n        }\n\n        const flightData = await streamToBuffer(\n          serverPrerenderStreamResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalClientPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream!, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              serverPrerenderStreamResult.asStream(),\n              nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            validateRootLayout,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n          collectedTags: finalServerPrerenderStore.tags,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      }\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await workUnitAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams,\n            prerenderResumeDataCache\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              nonce={nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: selectStaleTime(reactServerPrerenderStore.stale),\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          nonce={nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: selectStaleTime(prerenderLegacyStore.stale),\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <ErrorApp\n            reactServerStream={errorServerStream}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={nonce}\n          />\n        ),\n        streamOptions: {\n          nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream =\n        reactServerPrerenderResult instanceof ServerPrerenderStreamResult\n          ? reactServerPrerenderResult.asStream()\n          : reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale: selectStaleTime(\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE\n        ),\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: ReadableStream<Uint8Array>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  const { createFromReadableStream } =\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    require('react-server-dom-webpack/client.edge') as typeof import('react-server-dom-webpack/client.edge')\n\n  try {\n    createFromReadableStream(flightStream, {\n      serverConsumerManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n        serverModuleMap: null,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<React.ReactNode | undefined> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n\n  return globalErrorStyles\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const clientReferenceManifest = renderOpts.clientReferenceManifest\n  if (\n    !clientReferenceManifest ||\n    // Do not generate per-segment data unless the experimental Segment Cache\n    // flag is enabled.\n    //\n    // We also skip generating segment data if flag is set to \"client-only\",\n    // rather than true. (The \"client-only\" option only affects the behavior of\n    // the client-side implementation; per-segment prefetches are intentionally\n    // disabled in that configuration).\n    renderOpts.experimental.clientSegmentCache !== true\n  ) {\n    return\n  }\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: null,\n  }\n\n  // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n  // promise, the absence of which we use to determine if a segment is fully\n  // static or partially static. However, when dynamicIO is not enabled, this\n  // trick doesn't work.\n  //\n  // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n  // assume all segments are partial.\n  //\n  // TODO: When PPR is on, we can at least optimize the case where the entire\n  // page is static. Either by passing that as an argument to this function, or\n  // by setting a header on the response like the we do for full page RSC\n  // prefetches today. The latter approach might be simpler since it requires\n  // less plumbing, and the client has to check the header regardless to see if\n  // PPR is enabled.\n  const shouldAssumePartialData =\n    renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n\n  const staleTime = prerenderStore.stale\n  return await ComponentMod.collectSegmentData(\n    shouldAssumePartialData,\n    fullPageDataBuffer,\n    staleTime,\n    clientReferenceManifest.clientModules as ManifestNode,\n    serverConsumerManifest,\n    fallbackRouteParams\n  )\n}\n"],"names":["renderToHTMLOrFlight","warmFlightResponse","flightDataPathHeadKey","getFlightViewportKey","requestId","getFlightMetadataKey","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","NEXT_ROUTER_PREFETCH_HEADER","toLowerCase","undefined","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","isRSCRequest","RSC_HEADER","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE_HEADER","isRouteTreePrefetchRequest","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","csp","nonce","getScriptNonceFromHeader","previouslyRevalidatedTags","getPreviouslyRevalidatedTags","previewModeId","createNotFoundLoaderTree","loaderTree","components","children","PAGE_SEGMENT_KEY","page","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","getSegmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","dynamicParamTypes","treeSegment","split","slice","flatMap","pathSegment","parseParameter","join","getShortDynamicParamType","NonIndex","statusCode","isPossibleServerAction","is404Page","isInvalidStatusCode","meta","name","content","generateDynamicRSCPayload","ctx","flightData","componentMod","tree","createMetadataComponents","MetadataBoundary","ViewportBoundary","appUsingSizeAdjustment","query","workStore","url","serveStreamingMetadata","renderOpts","skipFlight","preloadCallbacks","ViewportTree","MetadataTree","getViewportReady","getMetadataReady","StreamingMetadataOutlet","parsedQuery","metadataContext","createTrackedMetadataContext","pathname","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","rscHead","React","Fragment","res","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","sharedContext","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","getRevalidateReason","generateDynamicFlightRenderResult","req","requestStore","onFlightDataRenderError","err","onInstrumentationRequestError","onError","createFlightReactServerErrorHandler","dev","RSCPayload","workUnitAsyncStorage","run","process","env","NODE_ENV","experimental","dynamicIO","resolveValidation","validationOutlet","createValidationOutlet","_validation","spawnDynamicValidationInDev","clientReferenceManifest","route","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","FlightRenderResult","fetchMetrics","warmupDevRender","implicitTags","InvariantError","rootParams","getRootParams","prerenderResumeDataCache","createPrerenderResumeDataCache","renderController","AbortController","prerenderController","cacheSignal","CacheSignal","prerenderStore","phase","renderSignal","signal","controller","dynamicTracking","revalidate","INFINITE_CACHE","expire","stale","tags","hmrRefreshHash","cookies","NEXT_HMR_REFRESH_HASH_COOKIE","rscPayload","cacheReady","abort","devRenderResumeDataCache","createRenderResumeDataCache","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","GlobalError","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","createComponentTree","authInterrupts","varyHeader","getHeader","couldBeIntercepted","includes","NEXT_URL","initialHead","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","ssrError","createMetadataContext","metadata","isError","Error","html","id","head","body","template","data-next-error-message","message","data-next-error-digest","digest","data-next-error-stack","stack","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","ServerInsertedMetadataProvider","response","use","useFlightStream","initialState","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","Map","location","prerendered","actionQueue","createMutableActionQueue","HeadManagerContext","require","Provider","appDir","AppRouter","globalErrorComponentAndStyles","ErrorApp","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","wrapClientComponentLoader","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setIsrStatus","NEXT_RUNTIME","isNodeNextRequest","originalRequest","on","ended","metrics","getClientComponentLoaderMetrics","reset","getTracer","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","appUsingSizeAdjust","serverModuleMap","createServerModuleMap","setReferenceManifestsSingleton","patchFetch","taintObjectReference","stripInternalQueries","crypto","randomUUID","nanoid","isPossibleActionRequest","getIsPossibleServerAction","getImplicitTags","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","AppRenderSpan","getBodyResult","spanName","prerenderToStream","dynamicAccess","accessedDynamicData","isDebugDynamicAccesses","warn","access","formatDynamicAPIAccesses","invalidUsageError","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","length","find","isUserLandError","pendingRevalidates","pendingRevalidateWrites","pendingRevalidatedTags","pendingPromise","executeRevalidates","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","waitUntil","collectedTags","fetchTags","staleHeader","String","collectedStale","setHeader","NEXT_ROUTER_STALE_TIME_HEADER","forceStatic","collectedRevalidate","cacheControl","collectedExpire","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","RenderResult","streamToString","stream","renderResumeDataCache","createRequestStoreForRender","onUpdateCookies","previewProps","usedDynamic","forceDynamic","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","handleAction","generateFlight","notFoundLoaderTree","result","assignMetadata","parseRelativeUrl","parsePostponedState","createWorkStore","routeModule","definition","workAsyncStorage","renderServerInsertedHTML","createServerInsertedHTML","getServerInsertedMetadata","createServerInsertedMetadata","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","getRequiredScripts","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","createHTMLReactServerErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","createHTMLErrorHandler","reactServerResult","bind","appendHeader","scheduleInSequentialTasks","prerenderPhase","environmentName","filterStackFrame","_functionName","startsWith","ReactServerResult","waitAtLeastOneReactRenderTask","DynamicState","DATA","inlinedReactServerDataStream","createInlinedDataReadableStream","tee","chainStreams","createDocumentClosingStream","getPostponedFromState","resume","htmlStream","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","basePath","continueDynamicHTMLResume","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","generateStaticHTML","supportsDynamicResponse","shouldWaitOnAllReady","validateRootLayout","continueFizzStream","isStaticGenBailoutError","shouldBailoutToCSR","isBailoutToCSRError","getStackWithoutErrorMessage","error","reason","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isRedirectError","getRedirectStatusCodeFromError","redirectUrl","addPathPrefix","getURLFromRedirectError","Headers","appendMutableCookies","mutableCookies","from","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","outlet","Promise","resolve","isNotFound","initialServerPrerenderController","initialServerRenderController","initialServerPrerenderStore","initialClientController","initialClientPrerenderStore","firstAttemptRSCPayload","initialServerStream","getDigestForWellKnownError","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","printDebugThrownValueForProspectiveRender","warmupStream","renderStream","prerender","pendingInitialClientResult","catch","finalServerController","serverDynamicTracking","createDynamicTrackingState","finalServerPrerenderStore","finalClientController","clientDynamicTracking","dynamicValidation","createDynamicValidationState","finalClientPrerenderStore","finalServerPayload","serverPrerenderStreamResult","prerenderServerWithPhases","isUseCacheTimeoutError","isPrerenderInterruptedError","rootDidError","serverPhasedStream","asPhasedStream","prerenderClientWithPhases","errorInfo","dynamicErrors","push","componentStack","trackAllowedDynamicAccess","assertExhausted","LogDynamicValidation","throwIfDisallowedDynamic","shouldGenerateStaticFlightData","reactServerPrerenderResult","setMetadataHeader","item","selectStaleTime","staleTimes","static","initialServerPayload","pendingInitialServerResult","onPostpone","initialServerResult","createReactServerPrerenderResult","asStream","prerenderAndAbortInSequentialTasks","asUnclosingStream","serverIsDynamic","finalRenderPrerenderStore","finalAttemptRSCPayload","prerenderIsPending","prerenderResult","clientIsDynamic","prelude","streamToBuffer","segmentData","collectSegmentData","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","consumeDynamicAccess","StaticGenBailoutError","foreverStream","ReadableStream","resumeStream","JSON","parse","stringify","createPostponedAbortSignal","continueStaticPrerender","consumeAsStream","cache","incrementalCache","dynamicReason","getFirstDynamicReason","DynamicServerError","reactServerPrerenderStore","createReactServerPrerenderResultFromRender","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","isDynamicServerError","flightStream","ServerPrerenderStreamResult","loadingChunks","chunkListeners","load","add","delete","createFromReadableStream","serverConsumerManifest","moduleLoading","moduleMap","ssrModuleMapping","r","modules","globalErrorModule","parseLoaderTree","styles","createComponentStylesAndScripts","filePath","getComponent","fullPageDataBuffer","clientSegmentCache","isEdgeRuntime","edgeRscModuleMapping","rscModuleMapping","shouldAssumePartialData","staleTime"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6977, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/clean-async-snapshot-instance.ts"],"sourcesContent":["import { createSnapshot } from '../app-render/async-local-storage'\n\nexport const runInCleanSnapshot: <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R = createSnapshot()\n"],"names":["runInCleanSnapshot","createSnapshot"],"mappings":";;;;+BAEaA,sBAAAA;;;eAAAA;;;mCAFkB;AAExB,MAAMA,qBAGJC,CAAAA,GAAAA,mBAAAA,cAAc","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6994, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  Segment as FlightRouterStateSegment,\n  DynamicParamTypesShort,\n} from './types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  encodeChildSegmentKey,\n  encodeSegment,\n  ROOT_SEGMENT_KEY,\n  type EncodedSegment,\n} from '../../shared/lib/segment-cache/segment-value-encoding'\nimport { getDigestForWellKnownError } from './create-error-handler'\nimport type { FallbackRouteParams } from '../request/fallback-params'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  head: HeadData\n  isHeadPartial: boolean\n  staleTime: number\n}\n\nexport type TreePrefetch = {\n  // The segment, in the format expected by a FlightRouterState.\n  segment: FlightRouterStateSegment\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  isRootLayout: boolean\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n}\n\nfunction onSegmentPrerenderError(error: unknown) {\n  const digest = getDigestForWellKnownError(error)\n  if (digest) {\n    return digest\n  }\n  // We don't need to log the errors because we would have already done that\n  // when generating the original Flight stream for the whole page.\n}\n\nexport async function collectSegmentData(\n  shouldAssumePartialData: boolean,\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<string, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      shouldAssumePartialData={shouldAssumePartialData}\n      fullPageDataBuffer={fullPageDataBuffer}\n      fallbackRouteParams={fallbackRouteParams}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree', treeBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  shouldAssumePartialData,\n  fullPageDataBuffer,\n  fallbackRouteParams,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  shouldAssumePartialData: boolean\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  fallbackRouteParams: FallbackRouteParams | null\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[string, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: HeadData = flightDataPaths[0][2]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = collectSegmentDataImpl(\n    shouldAssumePartialData,\n    flightRouterState,\n    buildId,\n    seedData,\n    fallbackRouteParams,\n    fullPageDataBuffer,\n    clientModules,\n    serverConsumerManifest,\n    ROOT_SEGMENT_KEY,\n    segmentTasks\n  )\n\n  const isHeadPartial =\n    shouldAssumePartialData || (await isPartialRSCData(head, clientModules))\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    head,\n    isHeadPartial,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nfunction collectSegmentDataImpl(\n  shouldAssumePartialData: boolean,\n  route: FlightRouterState,\n  buildId: string,\n  seedData: CacheNodeSeedData | null,\n  fallbackRouteParams: FallbackRouteParams | null,\n  fullPageDataBuffer: Buffer,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  key: string,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): TreePrefetch {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[2] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n    const childKey = encodeChildSegmentKey(\n      key,\n      parallelRouteKey,\n      Array.isArray(childSegment) && fallbackRouteParams !== null\n        ? encodeSegmentWithPossibleFallbackParam(\n            childSegment,\n            fallbackRouteParams\n          )\n        : encodeSegment(childSegment)\n    )\n    const childTree = collectSegmentDataImpl(\n      shouldAssumePartialData,\n      childRoute,\n      buildId,\n      childSeedData,\n      fallbackRouteParams,\n      fullPageDataBuffer,\n      clientModules,\n      serverConsumerManifest,\n      childKey,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          shouldAssumePartialData,\n          buildId,\n          seedData,\n          key,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  return {\n    segment: route[0],\n    slots: slotMetadata,\n    isRootLayout: route[4] === true,\n  }\n}\n\nfunction encodeSegmentWithPossibleFallbackParam(\n  segment: [string, string, DynamicParamTypesShort],\n  fallbackRouteParams: FallbackRouteParams\n): EncodedSegment {\n  const name = segment[0]\n  if (!fallbackRouteParams.has(name)) {\n    // Normal case. No matching fallback parameter.\n    return encodeSegment(segment)\n  }\n  // This segment includes a fallback parameter. During prerendering, a random\n  // placeholder value was used; however, for segment prefetches, we need the\n  // segment path to be predictable so the server can create a rewrite for it.\n  // So, replace the placeholder segment value with a \"template\" string,\n  // e.g. `[name]`.\n  // TODO: This will become a bit cleaner once remove route parameters from the\n  // server response, and instead add them to the segment keys on the client.\n  // Instead of a string replacement, like we do here, route params will always\n  // be encoded in separate step from the rest of the segment, not just in the\n  // case of fallback params.\n  const encodedSegment = encodeSegment(segment)\n  const lastIndex = encodedSegment.lastIndexOf('$')\n  const encodedFallbackSegment =\n    // NOTE: This is guaranteed not to clash with the rest of the segment\n    // because non-simple characters (including [ and ]) trigger a base\n    // 64 encoding.\n    encodedSegment.substring(0, lastIndex + 1) + `[${name}]`\n  return encodedFallbackSegment as EncodedSegment\n}\n\nasync function renderSegmentPrefetch(\n  shouldAssumePartialData: boolean,\n  buildId: string,\n  seedData: CacheNodeSeedData,\n  key: string,\n  clientModules: ManifestNode\n): Promise<[string, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    loading,\n    isPartial:\n      shouldAssumePartialData || (await isPartialRSCData(rsc, clientModules)),\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError: onSegmentPrerenderError,\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  if (key === ROOT_SEGMENT_KEY) {\n    return ['/_index', segmentBuffer]\n  } else {\n    return [key, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["collectSegmentData","onSegmentPrerenderError","error","digest","getDigestForWellKnownError","shouldAssumePartialData","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","fallbackRouteParams","resultMap","Map","createFromReadableStream","streamFromBuffer","waitAtLeastOneReactRenderTask","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","prerender","PrefetchTreeData","signal","onError","treeBuffer","streamToBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","flightRouterState","seedData","head","tree","collectSegmentDataImpl","ROOT_SEGMENT_KEY","isHeadPartial","isPartialRSCData","treePrefetch","route","key","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childKey","encodeChildSegmentKey","Array","isArray","encodeSegmentWithPossibleFallbackParam","encodeSegment","childTree","push","then","renderSegmentPrefetch","segment","slots","isRootLayout","name","has","encodedSegment","lastIndex","lastIndexOf","encodedFallbackSegment","substring","rsc","loading","segmentPrefetch","isPartial","segmentStream","segmentBuffer","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7261, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/encryption.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server.edge'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const { clientModules } = getClientReferenceManifestForRsc()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    const hangingInputAbortSignal =\n      workUnitStore?.type === 'prerender'\n        ? createHangingInputAbortSignal(workUnitStore)\n        : undefined\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      throw error\n    }\n\n    if (!workUnitStore) {\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const cacheSignal =\n      workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined\n\n    cacheSignal?.beginRead()\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    cacheSignal?.endRead()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal =\n      workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        if (workUnitStore?.type === 'prerender') {\n          // Explicitly don't close the stream here (until prerendering is\n          // complete) so that hanging promises are not rejected.\n          if (workUnitStore.renderSignal.aborted) {\n            controller.close()\n          } else {\n            workUnitStore.renderSignal.addEventListener(\n              'abort',\n              () => controller.close(),\n              { once: true }\n            )\n          }\n        } else {\n          controller.close()\n        }\n      },\n    }),\n    {\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n"],"names":["decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","process","env","NEXT_RUNTIME","textEncoder","TextEncoder","textDecoder","TextDecoder","decodeActionBoundArg","actionId","arg","key","getActionEncryptionKey","Error","originalPayload","atob","ivValue","slice","payload","decrypted","decode","decrypt","stringToUint8Array","startsWith","length","encodeActionBoundArg","undefined","randomBytes","Uint8Array","workUnitAsyncStorage","exit","crypto","getRandomValues","arrayBufferToString","buffer","encrypted","encrypt","encode","btoa","React","cache","args","clientModules","getClientReferenceManifestForRsc","error","captureStackTrace","didCatchError","workUnitStore","getStore","hangingInputAbortSignal","type","createHangingInputAbortSignal","serialized","streamToString","renderToReadableStream","signal","onError","err","aborted","message","String","NODE_ENV","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","get","cacheSignal","beginRead","endRead","set","encryptedPromise","decryptedBoundArgs","edgeRscModuleMapping","rscModuleMapping","deserialized","createFromReadableStream","ReadableStream","start","controller","enqueue","renderSignal","close","addEventListener","once","serverConsumerManifest","moduleLoading","moduleMap","serverModuleMap","getServerModuleMap"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7451, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/rsc/preloads.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport ReactDOM from 'react-dom'\n\nexport function preloadStyle(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'style' }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preloadFont(\n  href: string,\n  type: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = { as: 'font', type }\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ReactDOM.preload(href, opts)\n}\n\nexport function preconnect(\n  href: string,\n  crossOrigin: string | undefined,\n  nonce: string | undefined\n) {\n  const opts: any = {}\n  if (typeof crossOrigin === 'string') {\n    opts.crossOrigin = crossOrigin\n  }\n  if (typeof nonce === 'string') {\n    opts.nonce = nonce\n  }\n  ;(ReactDOM as any).preconnect(href, opts)\n}\n"],"names":["preconnect","preloadFont","preloadStyle","href","crossOrigin","nonce","opts","as","ReactDOM","preload","type"],"mappings":"AAAA;;;;AAIA,GAAA;;;;;;;;;;;;;;;;IAmCgBA,UAAU,EAAA;eAAVA;;IAhBAC,WAAW,EAAA;eAAXA;;IAfAC,YAAY,EAAA;eAAZA;;;iEAFK;;;;;;AAEd,SAASA,aACdC,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;IAAQ;IAChC,IAAI,OAAOH,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;IACAG,UAAAA,OAAQ,CAACC,OAAO,CAACN,MAAMG;AACzB;AAEO,SAASL,YACdE,IAAY,EACZO,IAAY,EACZN,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY;QAAEC,IAAI;QAAQG;IAAK;IACrC,IAAI,OAAON,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;IACAG,UAAAA,OAAQ,CAACC,OAAO,CAACN,MAAMG;AACzB;AAEO,SAASN,WACdG,IAAY,EACZC,WAA+B,EAC/BC,KAAyB;IAEzB,MAAMC,OAAY,CAAC;IACnB,IAAI,OAAOF,gBAAgB,UAAU;QACnCE,KAAKF,WAAW,GAAGA;IACrB;IACA,IAAI,OAAOC,UAAU,UAAU;QAC7BC,KAAKD,KAAK,GAAGA;IACf;;IACEG,UAAAA,OAAQ,CAASR,UAAU,CAACG,MAAMG;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7528, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/rsc/postpone.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\n// When postpone is available in canary React we can switch to importing it directly\nexport { Postpone } from '../dynamic-rendering'\n"],"names":["Postpone"],"mappings":"AAAA;;;;AAIA,GAEA,oFAAoF;;;;;+BAC3EA,YAAAA;;;eAAAA,kBAAAA,QAAQ;;;kCAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7549, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/rsc/taint.ts"],"sourcesContent":["/*\n\nFiles in the rsc directory are meant to be packaged as part of the RSC graph using next-app-loader.\n\n*/\n\nimport * as React from 'react'\n\ntype Reference = object\ntype TaintableUniqueValue = string | bigint | ArrayBufferView\n\nfunction notImplemented() {\n  throw new Error('Taint can only be used with the taint flag.')\n}\n\nexport const taintObjectReference: (\n  message: string | undefined,\n  object: Reference\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintObjectReference\n  : notImplemented\nexport const taintUniqueValue: (\n  message: string | undefined,\n  lifetime: Reference,\n  value: TaintableUniqueValue\n) => void = process.env.__NEXT_EXPERIMENTAL_REACT\n  ? // @ts-ignore\n    React.experimental_taintUniqueValue\n  : notImplemented\n"],"names":["taintObjectReference","taintUniqueValue","notImplemented","Error","process","env","__NEXT_EXPERIMENTAL_REACT","React","experimental_taintObjectReference","experimental_taintUniqueValue"],"mappings":"AAAA;;;;AAIA,GAAA;;;;;;;;;;;;;;;IAWaA,oBAAoB,EAAA;eAApBA;;IAOAC,gBAAgB,EAAA;eAAhBA;;;+DAhBU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKvB,SAASC;IACP,MAAM,OAAA,cAAwD,CAAxD,IAAIC,MAAM,gDAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAuD;AAC/D;AAEO,MAAMH,uBAGDI,QAAQC,GAAG,CAACC,yBAAyB,GAE7CC,OAAMC,8BACNN,GADuC;AAEpC,MAAMD,mBAIDG,QAAQC,GAAG,CAACC,yBAAyB,GAE7CC,OAAME,6BAA6B,CACnCP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7631, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/entry-base.ts"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nexport {\n  createTemporaryReferenceSet,\n  renderToReadableStream,\n  decodeReply,\n  decodeAction,\n  decodeFormState,\n} from 'react-server-dom-webpack/server.edge'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nexport { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge'\n\nimport LayoutRouter from '../../client/components/layout-router'\nimport RenderFromTemplateContext from '../../client/components/render-from-template-context'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { actionAsyncStorage } from '../app-render/action-async-storage.external'\nimport { ClientPageRoot } from '../../client/components/client-page'\nimport { ClientSegmentRoot } from '../../client/components/client-segment'\nimport {\n  createServerSearchParamsForServerPage,\n  createPrerenderSearchParamsForClientPage,\n} from '../request/search-params'\nimport {\n  createServerParamsForServerSegment,\n  createPrerenderParamsForClientSegment,\n} from '../request/params'\nimport * as serverHooks from '../../client/components/hooks-server-context'\nimport { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary'\nimport { createMetadataComponents } from '../../lib/metadata/metadata'\nimport { patchFetch as _patchFetch } from '../lib/patch-fetch'\n// not being used but needs to be included in the client manifest for /_not-found\nimport '../../client/components/error-boundary'\nimport {\n  MetadataBoundary,\n  ViewportBoundary,\n  OutletBoundary,\n} from '../../client/components/metadata/metadata-boundary'\n\nimport { preloadStyle, preloadFont, preconnect } from './rsc/preloads'\nimport { Postpone } from './rsc/postpone'\nimport { taintObjectReference } from './rsc/taint'\nexport { collectSegmentData } from './collect-segment-data'\n\n// patchFetch makes use of APIs such as `React.unstable_postpone` which are only available\n// in the experimental channel of React, so export it from here so that it comes from the bundled runtime\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  LayoutRouter,\n  RenderFromTemplateContext,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  actionAsyncStorage,\n  createServerSearchParamsForServerPage,\n  createPrerenderSearchParamsForClientPage,\n  createServerParamsForServerSegment,\n  createPrerenderParamsForClientSegment,\n  serverHooks,\n  preloadStyle,\n  preloadFont,\n  preconnect,\n  Postpone,\n  MetadataBoundary,\n  ViewportBoundary,\n  OutletBoundary,\n  taintObjectReference,\n  ClientPageRoot,\n  ClientSegmentRoot,\n  HTTPAccessFallbackBoundary,\n  patchFetch,\n  createMetadataComponents,\n}\n"],"names":["ClientPageRoot","ClientSegmentRoot","HTTPAccessFallbackBoundary","LayoutRouter","MetadataBoundary","OutletBoundary","Postpone","RenderFromTemplateContext","ViewportBoundary","actionAsyncStorage","collectSegmentData","createMetadataComponents","createPrerenderParamsForClientSegment","createPrerenderSearchParamsForClientPage","createServerParamsForServerSegment","createServerSearchParamsForServerPage","createTemporaryReferenceSet","decodeAction","decodeFormState","decodeReply","patchFetch","preconnect","preloadFont","preloadStyle","prerender","unstable_prerender","renderToReadableStream","serverHooks","taintObjectReference","workAsyncStorage","workUnitAsyncStorage","_patchFetch"],"mappings":"AAAA,6DAA6D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwE3DA,cAAc,EAAA;eAAdA,YAAAA,cAAc;;IACdC,iBAAiB,EAAA;eAAjBA,eAAAA,iBAAiB;;IACjBC,0BAA0B,EAAA;eAA1BA,eAAAA,0BAA0B;;IApB1BC,YAAY,EAAA;eAAZA,cAAAA,OAAY;;IAcZC,gBAAgB,EAAA;eAAhBA,kBAAAA,gBAAgB;;IAEhBC,cAAc,EAAA;eAAdA,kBAAAA,cAAc;;IAHdC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAZRC,yBAAyB,EAAA;eAAzBA,2BAAAA,OAAyB;;IAczBC,gBAAgB,EAAA;eAAhBA,kBAAAA,gBAAgB;;IAXhBC,kBAAkB,EAAA;eAAlBA,4BAAAA,kBAAkB;;IAhBXC,kBAAkB,EAAA;eAAlBA,oBAAAA,kBAAkB;;IAkCzBC,wBAAwB,EAAA;eAAxBA,UAAAA,wBAAwB;;IAdxBC,qCAAqC,EAAA;eAArCA,QAAAA,qCAAqC;;IAFrCC,wCAAwC,EAAA;eAAxCA,cAAAA,wCAAwC;;IACxCC,kCAAkC,EAAA;eAAlCA,QAAAA,kCAAkC;;IAFlCC,qCAAqC,EAAA;eAArCA,cAAAA,qCAAqC;;IAzDrCC,2BAA2B,EAAA;eAA3BA,YAAAA,2BAA2B;;IAG3BC,YAAY,EAAA;eAAZA,YAAAA,YAAY;;IACZC,eAAe,EAAA;eAAfA,YAAAA,eAAe;;IAFfC,WAAW,EAAA;eAAXA,YAAAA,WAAW;;IAuEXC,UAAU,EAAA;eAAVA;;IATAC,UAAU,EAAA;eAAVA,UAAAA,UAAU;;IADVC,WAAW,EAAA;eAAXA,UAAAA,WAAW;;IADXC,YAAY,EAAA;eAAZA,UAAAA,YAAY;;IAtDiBC,SAAS,EAAA;eAA/BC,YAAAA,kBAAkB;;IAPzBC,sBAAsB,EAAA;eAAtBA,YAAAA,sBAAsB;;IA4DtBC,WAAW,EAAA;eAAXA;;IAQAC,oBAAoB,EAAA;eAApBA,OAAAA,oBAAoB;;IAfpBC,gBAAgB,EAAA;eAAhBA,0BAAAA,gBAAgB;;IAChBC,oBAAoB,EAAA;eAApBA,8BAAAA,oBAAoB;;;4BAlDf;4BAGyC;qEAEvB;kFACa;0CACL;8CACI;4CACF;4BACJ;+BACG;8BAI3B;wBAIA;4EACsB;+BACc;0BACF;4BACC;;kCAOnC;0BAE+C;0BAC7B;uBACY;oCACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEnC,0FAA0F;AAC1F,yGAAyG;AACzG,SAASV;IACP,OAAOW,CAAAA,GAAAA,YAAAA,UAAW,EAAC;QACjBF,kBAAAA,0BAAAA,gBAAgB;QAChBC,sBAAAA,8BAAAA,oBAAoB;IACtB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7846, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/work-async-storage-instance.ts"],"sourcesContent":["import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;;+BAGaA,4BAAAA;;;eAAAA;;;mCAF2B;AAEjC,MAAMA,2BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7863, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Desktop/pet%20projects/FoodieHub/client/node_modules/next/src/server/app-render/work-unit-async-storage-instance.ts"],"sourcesContent":["import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n"],"names":["workUnitAsyncStorageInstance","createAsyncLocalStorage"],"mappings":";;;;+BAGaA,gCAAAA;;;eAAAA;;;mCAH2B;AAGjC,MAAMA,+BACXC,CAAAA,GAAAA,mBAAAA,uBAAuB","ignoreList":[0],"debugId":null}}]
}