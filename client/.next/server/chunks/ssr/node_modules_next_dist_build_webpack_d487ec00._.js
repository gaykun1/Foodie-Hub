module.exports = {

"[project]/node_modules/next/dist/build/webpack/plugins/define-env-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getDefineEnv: null,
    getDefineEnvPlugin: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getDefineEnv: function() {
        return getDefineEnv;
    },
    getDefineEnvPlugin: function() {
        return getDefineEnvPlugin;
    }
});
const _needsexperimentalreact = __turbopack_context__.r("[project]/node_modules/next/dist/lib/needs-experimental-react.js [app-rsc] (ecmascript)");
const _ppr = __turbopack_context__.r("[project]/node_modules/next/dist/server/lib/experimental/ppr.js [app-rsc] (ecmascript)");
const _staticenv = __turbopack_context__.r("[project]/node_modules/next/dist/lib/static-env.js [app-rsc] (ecmascript)");
const _getwebpackbundler = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-webpack-bundler.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Serializes the DefineEnv config so that it can be inserted into the code by Webpack/Turbopack, JSON stringifies each value.
 */ function serializeDefineEnv(defineEnv) {
    const defineEnvStringified = {};
    for(const key in defineEnv){
        const value = defineEnv[key];
        defineEnvStringified[key] = JSON.stringify(value);
    }
    return defineEnvStringified;
}
function getImageConfig(config, dev) {
    var _config_images, _config_images1, _config_images2;
    return {
        'process.env.__NEXT_IMAGE_OPTS': {
            deviceSizes: config.images.deviceSizes,
            imageSizes: config.images.imageSizes,
            qualities: config.images.qualities,
            path: config.images.path,
            loader: config.images.loader,
            dangerouslyAllowSVG: config.images.dangerouslyAllowSVG,
            unoptimized: config == null ? void 0 : (_config_images = config.images) == null ? void 0 : _config_images.unoptimized,
            ...dev ? {
                // additional config in dev to allow validating on the client
                domains: config.images.domains,
                remotePatterns: (_config_images1 = config.images) == null ? void 0 : _config_images1.remotePatterns,
                localPatterns: (_config_images2 = config.images) == null ? void 0 : _config_images2.localPatterns,
                output: config.output
            } : {}
        }
    };
}
function getDefineEnv({ isTurbopack, clientRouterFilters, config, dev, distDir, fetchCacheKeyPrefix, hasRewrites, isClient, isEdgeServer, isNodeOrEdgeCompilation, isNodeServer, middlewareMatchers, omitNonDeterministic }) {
    var _config_experimental_staleTimes, _config_experimental_staleTimes1, _config_experimental_staleTimes2, _config_experimental_staleTimes3, _config_i18n, _config_compiler;
    const nextPublicEnv = (0, _staticenv.getNextPublicEnvironmentVariables)();
    const nextConfigEnv = (0, _staticenv.getNextConfigEnv)(config);
    const isPPREnabled = (0, _ppr.checkIsAppPPREnabled)(config.experimental.ppr);
    const isDynamicIOEnabled = !!config.experimental.dynamicIO;
    const isUseCacheEnabled = !!config.experimental.useCache;
    const defineEnv = {
        // internal field to identify the plugin config
        __NEXT_DEFINE_ENV: true,
        ...nextPublicEnv,
        ...nextConfigEnv,
        ...!isEdgeServer ? {} : {
            EdgeRuntime: /**
             * Cloud providers can set this environment variable to allow users
             * and library authors to have different implementations based on
             * the runtime they are running with, if it's not using `edge-runtime`
             */ process.env.NEXT_EDGE_RUNTIME_PROVIDER ?? 'edge-runtime',
            // process should be only { env: {...} } for edge runtime.
            // For ignore avoid warn on `process.emit` usage but directly omit it.
            'process.emit': false
        },
        'process.turbopack': isTurbopack,
        'process.env.TURBOPACK': isTurbopack,
        'process.env.__NEXT_BUNDLER': isTurbopack ? 'Turbopack' : process.env.NEXT_RSPACK ? 'Rspack' : 'Webpack',
        // TODO: enforce `NODE_ENV` on `process.env`, and add a test:
        'process.env.NODE_ENV': dev || config.experimental.allowDevelopmentBuild ? 'development' : 'production',
        'process.env.NEXT_RUNTIME': isEdgeServer ? 'edge' : isNodeServer ? 'nodejs' : '',
        'process.env.NEXT_MINIMAL': '',
        'process.env.__NEXT_APP_NAV_FAIL_HANDLING': Boolean(config.experimental.appNavFailHandling),
        'process.env.__NEXT_PPR': isPPREnabled,
        'process.env.__NEXT_DYNAMIC_IO': isDynamicIOEnabled,
        'process.env.__NEXT_USE_CACHE': isUseCacheEnabled,
        'process.env.NEXT_DEPLOYMENT_ID': config.deploymentId || false,
        // Propagates the `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` environment
        // variable to the client.
        'process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING': ("TURBOPACK compile-time value", false) || false,
        'process.env.__NEXT_FETCH_CACHE_KEY_PREFIX': fetchCacheKeyPrefix ?? '',
        ...isTurbopack ? {} : {
            'process.env.__NEXT_MIDDLEWARE_MATCHERS': middlewareMatchers ?? []
        },
        'process.env.__NEXT_MANUAL_CLIENT_BASE_PATH': config.experimental.manualClientBasePath ?? false,
        'process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME': JSON.stringify(isNaN(Number((_config_experimental_staleTimes = config.experimental.staleTimes) == null ? void 0 : _config_experimental_staleTimes.dynamic)) ? 0 : (_config_experimental_staleTimes1 = config.experimental.staleTimes) == null ? void 0 : _config_experimental_staleTimes1.dynamic),
        'process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME': JSON.stringify(isNaN(Number((_config_experimental_staleTimes2 = config.experimental.staleTimes) == null ? void 0 : _config_experimental_staleTimes2.static)) ? 5 * 60 // 5 minutes
         : (_config_experimental_staleTimes3 = config.experimental.staleTimes) == null ? void 0 : _config_experimental_staleTimes3.static),
        'process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED': config.experimental.clientRouterFilter ?? true,
        'process.env.__NEXT_CLIENT_ROUTER_S_FILTER': (clientRouterFilters == null ? void 0 : clientRouterFilters.staticFilter) ?? false,
        'process.env.__NEXT_CLIENT_ROUTER_D_FILTER': (clientRouterFilters == null ? void 0 : clientRouterFilters.dynamicFilter) ?? false,
        'process.env.__NEXT_CLIENT_SEGMENT_CACHE': Boolean(config.experimental.clientSegmentCache),
        'process.env.__NEXT_DYNAMIC_ON_HOVER': Boolean(config.experimental.dynamicOnHover),
        'process.env.__NEXT_ROUTER_BF_CACHE': Boolean(config.experimental.routerBFCache),
        'process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE': config.experimental.optimisticClientCache ?? true,
        'process.env.__NEXT_MIDDLEWARE_PREFETCH': config.experimental.middlewarePrefetch ?? 'flexible',
        'process.env.__NEXT_CROSS_ORIGIN': config.crossOrigin,
        'process.browser': isClient,
        'process.env.__NEXT_TEST_MODE': ("TURBOPACK compile-time value", false) ?? false,
        // This is used in client/dev-error-overlay/hot-dev-client.js to replace the dist directory
        ...dev && (isClient ?? isEdgeServer) ? {
            'process.env.__NEXT_DIST_DIR': distDir
        } : {},
        'process.env.__NEXT_TRAILING_SLASH': config.trailingSlash,
        'process.env.__NEXT_DEV_INDICATOR': config.devIndicators !== false,
        'process.env.__NEXT_DEV_INDICATOR_POSITION': config.devIndicators === false ? 'bottom-left' // This will not be used as the indicator is disabled.
         : config.devIndicators.position ?? 'bottom-left',
        'process.env.__NEXT_STRICT_MODE': config.reactStrictMode === null ? false : config.reactStrictMode,
        'process.env.__NEXT_STRICT_MODE_APP': config.reactStrictMode === null ? true : config.reactStrictMode,
        'process.env.__NEXT_OPTIMIZE_CSS': (config.experimental.optimizeCss && !dev) ?? false,
        'process.env.__NEXT_SCRIPT_WORKERS': (config.experimental.nextScriptWorkers && !dev) ?? false,
        'process.env.__NEXT_SCROLL_RESTORATION': config.experimental.scrollRestoration ?? false,
        ...getImageConfig(config, dev),
        'process.env.__NEXT_ROUTER_BASEPATH': config.basePath,
        'process.env.__NEXT_STRICT_NEXT_HEAD': config.experimental.strictNextHead ?? true,
        'process.env.__NEXT_HAS_REWRITES': hasRewrites,
        'process.env.__NEXT_CONFIG_OUTPUT': config.output,
        'process.env.__NEXT_I18N_SUPPORT': !!config.i18n,
        'process.env.__NEXT_I18N_DOMAINS': ((_config_i18n = config.i18n) == null ? void 0 : _config_i18n.domains) ?? false,
        'process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE': config.skipMiddlewareUrlNormalize,
        'process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE': config.experimental.externalMiddlewareRewritesResolve ?? false,
        'process.env.__NEXT_MANUAL_TRAILING_SLASH': config.skipTrailingSlashRedirect,
        'process.env.__NEXT_HAS_WEB_VITALS_ATTRIBUTION': (config.experimental.webVitalsAttribution && config.experimental.webVitalsAttribution.length > 0) ?? false,
        'process.env.__NEXT_WEB_VITALS_ATTRIBUTION': config.experimental.webVitalsAttribution ?? false,
        'process.env.__NEXT_LINK_NO_TOUCH_START': config.experimental.linkNoTouchStart ?? false,
        'process.env.__NEXT_ASSET_PREFIX': config.assetPrefix,
        'process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS': !!config.experimental.authInterrupts,
        'process.env.__NEXT_TELEMETRY_DISABLED': Boolean(process.env.NEXT_TELEMETRY_DISABLED),
        ...isNodeOrEdgeCompilation ? {
            // Fix bad-actors in the npm ecosystem (e.g. `node-formidable`)
            // This is typically found in unmaintained modules from the
            // pre-webpack era (common in server-side code)
            'global.GENTLY': false
        } : undefined,
        ...isNodeOrEdgeCompilation ? {
            'process.env.__NEXT_EXPERIMENTAL_REACT': (0, _needsexperimentalreact.needsExperimentalReact)(config)
        } : undefined
    };
    const userDefines = ((_config_compiler = config.compiler) == null ? void 0 : _config_compiler.define) ?? {};
    for(const key in userDefines){
        if (defineEnv.hasOwnProperty(key)) {
            throw Object.defineProperty(new Error(`The \`compiler.define\` option is configured to replace the \`${key}\` variable. This variable is either part of a Next.js built-in or is already configured via the \`env\` option.`), "__NEXT_ERROR_CODE", {
                value: "E430",
                enumerable: false,
                configurable: true
            });
        }
        defineEnv[key] = userDefines[key];
    }
    const serializedDefineEnv = serializeDefineEnv(defineEnv);
    // we delay inlining these values until after the build
    // with flying shuttle enabled so we can update them
    // without invalidating entries
    if (!dev && omitNonDeterministic) {
        // client uses window. instead of leaving process.env
        // in case process isn't polyfilled on client already
        // since by this point it won't be added by webpack
        const safeKey = (key)=>isClient ? `window.${key.split('.').pop()}` : key;
        for(const key in nextPublicEnv){
            serializedDefineEnv[key] = safeKey(key);
        }
        for(const key in nextConfigEnv){
            serializedDefineEnv[key] = safeKey(key);
        }
        for (const key of [
            'process.env.NEXT_DEPLOYMENT_ID'
        ]){
            serializedDefineEnv[key] = safeKey(key);
        }
    }
    return serializedDefineEnv;
}
function getDefineEnvPlugin(options) {
    return new ((0, _getwebpackbundler.default)()).DefinePlugin(getDefineEnv(options));
} //# sourceMappingURL=define-env-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getModuleBuildInfo", {
    enumerable: true,
    get: function() {
        return getModuleBuildInfo;
    }
});
function getModuleBuildInfo(webpackModule) {
    return webpackModule.buildInfo;
} //# sourceMappingURL=get-module-build-info.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-middleware-loader.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decodeMatchers: null,
    default: null,
    encodeMatchers: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decodeMatchers: function() {
        return decodeMatchers;
    },
    default: function() {
        return middlewareLoader;
    },
    encodeMatchers: function() {
        return encodeMatchers;
    }
});
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _loadentrypoint = __turbopack_context__.r("[project]/node_modules/next/dist/build/load-entrypoint.js [app-rsc] (ecmascript)");
function encodeMatchers(matchers) {
    return Buffer.from(JSON.stringify(matchers)).toString('base64');
}
function decodeMatchers(encodedMatchers) {
    return JSON.parse(Buffer.from(encodedMatchers, 'base64').toString());
}
async function middlewareLoader() {
    const { absolutePagePath, page, rootDir, matchers: encodedMatchers, preferredRegion, middlewareConfig: middlewareConfigBase64 } = this.getOptions();
    const matchers = encodedMatchers ? decodeMatchers(encodedMatchers) : undefined;
    const pagePath = this.utils.contextify(this.context || this.rootContext, absolutePagePath);
    const middlewareConfig = JSON.parse(Buffer.from(middlewareConfigBase64, 'base64').toString());
    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(this._module);
    buildInfo.nextEdgeMiddleware = {
        matchers,
        page: page.replace(new RegExp(`/${_constants.MIDDLEWARE_LOCATION_REGEXP}$`), '') || '/'
    };
    buildInfo.rootDir = rootDir;
    buildInfo.route = {
        page,
        absolutePagePath,
        preferredRegion,
        middlewareConfig
    };
    return await (0, _loadentrypoint.loadEntrypoint)('middleware', {
        VAR_USERLAND: pagePath,
        VAR_DEFINITION_PAGE: page
    });
} //# sourceMappingURL=next-middleware-loader.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decodeFromBase64: null,
    encodeToBase64: null,
    getLoaderModuleNamedExports: null,
    isCSSMod: null,
    isClientComponentEntryModule: null,
    regexCSS: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decodeFromBase64: function() {
        return decodeFromBase64;
    },
    encodeToBase64: function() {
        return encodeToBase64;
    },
    getLoaderModuleNamedExports: function() {
        return getLoaderModuleNamedExports;
    },
    isCSSMod: function() {
        return isCSSMod;
    },
    isClientComponentEntryModule: function() {
        return isClientComponentEntryModule;
    },
    regexCSS: function() {
        return regexCSS;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const imageExtensions = [
    'jpg',
    'jpeg',
    'png',
    'webp',
    'avif',
    'ico',
    'svg'
];
const imageRegex = new RegExp(`\\.(${imageExtensions.join('|')})$`);
// Determine if the whole module is client action, 'use server' in nested closure in the client module
function isActionClientLayerModule(mod) {
    const rscInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc;
    return !!((rscInfo == null ? void 0 : rscInfo.actionIds) && (rscInfo == null ? void 0 : rscInfo.type) === _constants.RSC_MODULE_TYPES.client);
}
function isClientComponentEntryModule(mod) {
    const rscInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc;
    const hasClientDirective = rscInfo == null ? void 0 : rscInfo.isClientRef;
    const isActionLayerEntry = isActionClientLayerModule(mod);
    return hasClientDirective || isActionLayerEntry || imageRegex.test(mod.resource);
}
const regexCSS = /\.(css|scss|sass)(\?.*)?$/;
function isCSSMod(mod) {
    var _mod_loaders;
    return !!(mod.type === 'css/mini-extract' || mod.resource && regexCSS.test(mod.resource) || ((_mod_loaders = mod.loaders) == null ? void 0 : _mod_loaders.some(({ loader })=>loader.includes('next-style-loader/index.js') || process.env.NEXT_RSPACK && loader.includes('rspack.CssExtractRspackPlugin.loader') || loader.includes('mini-css-extract-plugin/loader.js') || loader.includes('@vanilla-extract/webpack-plugin/loader/'))));
}
function encodeToBase64(obj) {
    return Buffer.from(JSON.stringify(obj)).toString('base64');
}
function decodeFromBase64(str) {
    return JSON.parse(Buffer.from(str, 'base64').toString('utf8'));
}
async function getLoaderModuleNamedExports(resourcePath, context) {
    var _mod_dependencies;
    const mod = await new Promise((res, rej)=>{
        context.loadModule(resourcePath, (err, _source, _sourceMap, module1)=>{
            if (err) {
                return rej(err);
            }
            res(module1);
        });
    });
    const exportNames = ((_mod_dependencies = mod.dependencies) == null ? void 0 : _mod_dependencies.filter((dep)=>{
        return [
            'HarmonyExportImportedSpecifierDependency',
            'HarmonyExportSpecifierDependency'
        ].includes(dep.constructor.name) && 'name' in dep && dep.name !== 'default';
    }).map((dep)=>{
        return dep.name;
    })) || [];
    return exportNames;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getRouteLoaderEntry: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getRouteLoaderEntry: function() {
        return getRouteLoaderEntry;
    }
});
const _querystring = __turbopack_context__.r("[externals]/querystring [external] (querystring, cjs)");
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const _routekind = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-kind.js [app-rsc] (ecmascript)");
const _normalizepagepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-page-path.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/utils.js [app-rsc] (ecmascript)");
const _utils1 = __turbopack_context__.r("[project]/node_modules/next/dist/build/utils.js [app-rsc] (ecmascript)");
const _loadentrypoint = __turbopack_context__.r("[project]/node_modules/next/dist/build/load-entrypoint.js [app-rsc] (ecmascript)");
function getRouteLoaderEntry(options) {
    switch(options.kind){
        case _routekind.RouteKind.PAGES:
            {
                const query = {
                    kind: options.kind,
                    page: options.page,
                    preferredRegion: options.preferredRegion,
                    absolutePagePath: options.absolutePagePath,
                    // These are the path references to the internal components that may be
                    // overridden by userland components.
                    absoluteAppPath: options.pages['/_app'],
                    absoluteDocumentPath: options.pages['/_document'],
                    middlewareConfigBase64: (0, _utils.encodeToBase64)(options.middlewareConfig)
                };
                return `next-route-loader?${(0, _querystring.stringify)(query)}!`;
            }
        case _routekind.RouteKind.PAGES_API:
            {
                const query = {
                    kind: options.kind,
                    page: options.page,
                    preferredRegion: options.preferredRegion,
                    absolutePagePath: options.absolutePagePath,
                    middlewareConfigBase64: (0, _utils.encodeToBase64)(options.middlewareConfig)
                };
                return `next-route-loader?${(0, _querystring.stringify)(query)}!`;
            }
        default:
            {
                throw Object.defineProperty(new Error('Invariant: Unexpected route kind'), "__NEXT_ERROR_CODE", {
                    value: "E453",
                    enumerable: false,
                    configurable: true
                });
            }
    }
}
const loadPages = async ({ page, absolutePagePath, absoluteDocumentPath, absoluteAppPath, preferredRegion, middlewareConfigBase64 }, buildInfo)=>{
    const middlewareConfig = (0, _utils.decodeFromBase64)(middlewareConfigBase64);
    // Attach build info to the module.
    buildInfo.route = {
        page,
        absolutePagePath,
        preferredRegion,
        middlewareConfig
    };
    let file = await (0, _loadentrypoint.loadEntrypoint)('pages', {
        VAR_USERLAND: absolutePagePath,
        VAR_MODULE_DOCUMENT: absoluteDocumentPath,
        VAR_MODULE_APP: absoluteAppPath,
        VAR_DEFINITION_PAGE: (0, _normalizepagepath.normalizePagePath)(page),
        VAR_DEFINITION_PATHNAME: page
    });
    if ((0, _utils1.isInstrumentationHookFile)(page)) {
        // When we're building the instrumentation page (only when the
        // instrumentation file conflicts with a page also labeled
        // /instrumentation) hoist the `register` method.
        file += '\nexport const register = hoist(userland, "register")';
    }
    return file;
};
const loadPagesAPI = async ({ page, absolutePagePath, preferredRegion, middlewareConfigBase64 }, buildInfo)=>{
    const middlewareConfig = (0, _utils.decodeFromBase64)(middlewareConfigBase64);
    // Attach build info to the module.
    buildInfo.route = {
        page,
        absolutePagePath,
        preferredRegion,
        middlewareConfig
    };
    return await (0, _loadentrypoint.loadEntrypoint)('pages-api', {
        VAR_USERLAND: absolutePagePath,
        VAR_DEFINITION_PAGE: (0, _normalizepagepath.normalizePagePath)(page),
        VAR_DEFINITION_PATHNAME: page
    });
};
/**
 * Handles the `next-route-loader` options.
 * @returns the loader definition function
 */ const loader = async function() {
    if (!this._module) {
        throw Object.defineProperty(new Error('Invariant: expected this to reference a module'), "__NEXT_ERROR_CODE", {
            value: "E383",
            enumerable: false,
            configurable: true
        });
    }
    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(this._module);
    const opts = this.getOptions();
    switch(opts.kind){
        case _routekind.RouteKind.PAGES:
            {
                return await loadPages(opts, buildInfo);
            }
        case _routekind.RouteKind.PAGES_API:
            {
                return await loadPagesAPI(opts, buildInfo);
            }
        default:
            {
                throw Object.defineProperty(new Error('Invariant: Unexpected route kind'), "__NEXT_ERROR_CODE", {
                    value: "E453",
                    enumerable: false,
                    configurable: true
                });
            }
    }
};
const _default = loader; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/devtools-ignore-list-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Source: https://github.com/mondaychen/devtools-ignore-webpack-plugin/blob/e35ce41d9606a92a455ef247f509a1c2ccab5778/src/index.ts
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * This plugin adds a field to source maps that identifies which sources are
 * vendored or runtime-injected (aka third-party) sources. These are consumed by
 * Chrome DevTools to automatically ignore-list sources.
 */ "default", {
    enumerable: true,
    get: function() {
        return DevToolsIgnorePlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
// Following the naming conventions from
// https://tc39.es/source-map/#source-map-format
const IGNORE_LIST = 'ignoreList';
const PLUGIN_NAME = 'devtools-ignore-plugin';
function defaultShouldIgnorePath(path) {
    return path.includes('/node_modules/') || path.includes('/webpack/');
}
function defaultIsSourceMapAsset(name) {
    return name.endsWith('.map');
}
class DevToolsIgnorePlugin {
    constructor(options = {}){
        this.options = {
            shouldIgnorePath: options.shouldIgnorePath ?? defaultShouldIgnorePath,
            isSourceMapAsset: options.isSourceMapAsset ?? defaultIsSourceMapAsset
        };
    }
    apply(compiler) {
        const { RawSource } = compiler.webpack.sources;
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,
                additionalAssets: true
            }, (assets)=>{
                for (const [name, asset] of Object.entries(assets)){
                    // Instead of using `asset.map()` to fetch the source maps from
                    // SourceMapSource assets, process them directly as a RawSource.
                    // This is because `.map()` is slow and can take several seconds.
                    if (!this.options.isSourceMapAsset(name)) {
                        continue;
                    }
                    const mapContent = asset.source().toString();
                    if (!mapContent) {
                        continue;
                    }
                    const sourcemap = JSON.parse(mapContent);
                    const ignoreList = [];
                    for (const [index, path] of sourcemap.sources.entries()){
                        if (this.options.shouldIgnorePath(path)) {
                            ignoreList.push(index);
                        }
                    }
                    sourcemap[IGNORE_LIST] = ignoreList;
                    compilation.updateAsset(name, new RawSource(JSON.stringify(sourcemap)));
                }
            });
        });
    }
} //# sourceMappingURL=devtools-ignore-list-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/eval-source-map-dev-tool-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra

  Forked to add support for `ignoreList`.
  Keep in sync with packages/next/webpack-plugins/eval-source-map-dev-tool-plugin.js
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, // https://github.com/webpack/webpack/blob/e237b580e2bda705c5ab39973f786f7c5a7026bc/lib/EvalSourceMapDevToolPlugin.js#L37
"default", {
    enumerable: true,
    get: function() {
        return EvalSourceMapDevToolPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const cache = new WeakMap();
const devtoolWarningMessage = `/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
`;
class EvalSourceMapDevToolPlugin {
    /**
   * @param {SourceMapDevToolPluginOptions|string} inputOptions Options object
   */ constructor(inputOptions){
        let options;
        if (typeof inputOptions === 'string') {
            options = {
                append: inputOptions
            };
        } else {
            options = inputOptions;
        }
        this.sourceMapComment = options.append && typeof options.append !== 'function' ? options.append : '//# sourceURL=[module]\n//# sourceMappingURL=[url]';
        this.moduleFilenameTemplate = options.moduleFilenameTemplate || 'webpack://[namespace]/[resource-path]?[hash]';
        this.namespace = options.namespace || '';
        this.options = options;
        // fork
        this.shouldIgnorePath = options.shouldIgnorePath ?? (()=>false);
    }
    /**
   * Apply the plugin
   * @param compiler the compiler instance
   */ apply(compiler) {
        const options = this.options;
        compiler.hooks.compilation.tap('NextJSEvalSourceMapDevToolPlugin', (compilation)=>{
            const { JavascriptModulesPlugin } = compiler.webpack.javascript;
            const { RawSource, ConcatSource } = compiler.webpack.sources;
            const devtoolWarning = new RawSource(devtoolWarningMessage);
            const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
            new _webpack.SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
            const matchModule = _webpack.ModuleFilenameHelpers.matchObject.bind(_webpack.ModuleFilenameHelpers, options);
            hooks.renderModuleContent.tap('NextJSEvalSourceMapDevToolPlugin', (source, m, { chunk, runtimeTemplate, chunkGraph })=>{
                const cachedSource = cache.get(source);
                if (cachedSource !== undefined) {
                    return cachedSource;
                }
                const result = (r)=>{
                    cache.set(source, r);
                    return r;
                };
                if (m instanceof _webpack.NormalModule) {
                    const module = m;
                    if (!matchModule(module.resource)) {
                        return result(source);
                    }
                } else if (m instanceof _webpack.ConcatenatedModule) {
                    const concatModule = m;
                    if (concatModule.rootModule instanceof _webpack.NormalModule) {
                        const module = concatModule.rootModule;
                        if (!matchModule(module.resource)) {
                            return result(source);
                        }
                    } else {
                        return result(source);
                    }
                } else {
                    return result(source);
                }
                const namespace = compilation.getPath(this.namespace, {
                    chunk
                });
                let sourceMap;
                let content;
                if (source.sourceAndMap) {
                    const sourceAndMap = source.sourceAndMap(options);
                    sourceMap = sourceAndMap.map;
                    content = sourceAndMap.source;
                } else {
                    sourceMap = source.map(options);
                    content = source.source();
                }
                if (!sourceMap) {
                    return result(source);
                }
                // Clone (flat) the sourcemap to ensure that the mutations below do not persist.
                sourceMap = {
                    ...sourceMap
                };
                const context = compiler.options.context;
                const root = compiler.root;
                const modules = sourceMap.sources.map((sourceMapSource)=>{
                    if (!sourceMapSource.startsWith('webpack://')) return sourceMapSource;
                    sourceMapSource = (0, _webpack.makePathsAbsolute)(context, sourceMapSource.slice(10), root);
                    const module = compilation.findModule(sourceMapSource);
                    return module || sourceMapSource;
                });
                let moduleFilenames = modules.map((module)=>_webpack.ModuleFilenameHelpers.createFilename(module, {
                        moduleFilenameTemplate: this.moduleFilenameTemplate,
                        namespace
                    }, {
                        requestShortener: runtimeTemplate.requestShortener,
                        chunkGraph,
                        hashFunction: compilation.outputOptions.hashFunction
                    }));
                moduleFilenames = _webpack.ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, (filename, _i, n)=>{
                    for(let j = 0; j < n; j++)filename += '*';
                    return filename;
                });
                sourceMap.sources = moduleFilenames;
                sourceMap.ignoreList = [];
                for(let index = 0; index < moduleFilenames.length; index++){
                    if (this.shouldIgnorePath(moduleFilenames[index])) {
                        sourceMap.ignoreList.push(index);
                    }
                }
                if (options.noSources) {
                    sourceMap.sourcesContent = undefined;
                }
                sourceMap.sourceRoot = options.sourceRoot || '';
                const moduleId = /** @type {ModuleId} */ chunkGraph.getModuleId(m);
                if (moduleId) {
                    sourceMap.file = typeof moduleId === 'number' ? `${moduleId}.js` : moduleId;
                }
                const footer = `${this.sourceMapComment.replace(/\[url\]/g, `data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(sourceMap), 'utf8').toString('base64')}`)}\n//# sourceURL=webpack-internal:///${moduleId}\n` // workaround for chrome bug
                ;
                return result(new RawSource(`eval(${compilation.outputOptions.trustedTypes ? `${_webpack.RuntimeGlobals.createScript}(${JSON.stringify(content + footer)})` : JSON.stringify(content + footer)});`));
            });
            hooks.inlineInRuntimeBailout.tap('EvalDevToolModulePlugin', ()=>'the eval-source-map devtool is used.');
            hooks.render.tap('EvalSourceMapDevToolPlugin', (source)=>new ConcatSource(devtoolWarning, source));
            hooks.chunkHash.tap('EvalSourceMapDevToolPlugin', (_chunk, hash)=>{
                hash.update('EvalSourceMapDevToolPlugin');
                hash.update('2');
            });
            if (compilation.outputOptions.trustedTypes) {
                compilation.hooks.additionalModuleRuntimeRequirements.tap('EvalSourceMapDevToolPlugin', (_module, set, _context)=>{
                    set.add(_webpack.RuntimeGlobals.createScript);
                });
            }
        });
    }
} //# sourceMappingURL=eval-source-map-dev-tool-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/base.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "base", {
    enumerable: true,
    get: function() {
        return base;
    }
});
const _lodashcurry = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/lodash.curry/index.js [app-rsc] (ecmascript)"));
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _devtoolsignorelistplugin = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/devtools-ignore-list-plugin.js [app-rsc] (ecmascript)"));
const _evalsourcemapdevtoolplugin = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/eval-source-map-dev-tool-plugin.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function shouldIgnorePath(modulePath) {
    return modulePath.includes('node_modules') || // Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo
    modulePath.includes('next/dist');
}
const base = (0, _lodashcurry.default)(function base(ctx, config) {
    config.mode = ctx.isDevelopment ? 'development' : 'production';
    config.name = ctx.isServer ? ctx.isEdgeRuntime ? _constants.COMPILER_NAMES.edgeServer : _constants.COMPILER_NAMES.server : _constants.COMPILER_NAMES.client;
    config.target = !ctx.targetWeb ? 'node18.17' // Same version defined in packages/next/package.json#engines
     : ctx.isEdgeRuntime ? [
        'web',
        'es6'
    ] : [
        'web',
        'es6'
    ];
    // https://webpack.js.org/configuration/devtool/#development
    if (ctx.isDevelopment) {
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        } else {
            // `eval-source-map` provides full-fidelity source maps for the
            // original source, including columns and original variable names.
            // This is desirable so the in-browser debugger can correctly pause
            // and show scoped variables with their original names.
            config.devtool = 'eval-source-map';
        }
    } else {
        if (ctx.isEdgeRuntime || ctx.isServer && ctx.serverSourceMaps || // Enable browser sourcemaps:
        ctx.productionBrowserSourceMaps && ctx.isClient) {
            config.devtool = 'source-map';
        } else {
            config.devtool = false;
        }
    }
    if (!config.module) {
        config.module = {
            rules: []
        };
    }
    config.plugins ??= [];
    if (config.devtool === 'source-map' && !process.env.NEXT_RSPACK) {
        config.plugins.push(new _devtoolsignorelistplugin.default({
            shouldIgnorePath
        }));
    } else if (config.devtool === 'eval-source-map' && !process.env.NEXT_RSPACK) {
        var _config_output;
        // We're using a fork of `eval-source-map`
        config.devtool = false;
        config.plugins.push(new _evalsourcemapdevtoolplugin.default({
            moduleFilenameTemplate: (_config_output = config.output) == null ? void 0 : _config_output.devtoolModuleFilenameTemplate,
            shouldIgnorePath
        }));
    }
    // TODO: add codemod for "Should not import the named export" with JSON files
    // config.module.strictExportPresence = !isWebpack5
    return config;
}); //# sourceMappingURL=base.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/value-processor.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
The MIT License (MIT)

Copyright (c) 2016 Ben Holloway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _loaderutils2 = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/loader-utils2/index.js [app-rsc] (ecmascript)"));
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function valueProcessor(filename, options) {
    const URL_STATEMENT_REGEX = /(url\s*\()\s*(?:(['"])((?:(?!\2).)*)(\2)|([^'"](?:(?!\)).)*[^'"]))\s*(\))/g;
    const directory = _path.default.dirname(filename);
    const join = options.join(filename, options);
    /**
   * Process the given CSS declaration value.
   *
   */ return function transformValue(/** A declaration value that may or may not contain a url() statement */ value, /** An absolute path that may be the correct base or an Iterator thereof */ candidate) {
        // allow multiple url() values in the declaration
        //  split by url statements and process the content
        //  additional capture groups are needed to match quotations correctly
        //  escaped quotations are not considered
        return value.split(URL_STATEMENT_REGEX).map((token, i, arr)=>{
            // we can get groups as undefined under certain match circumstances
            const initialised = token || '';
            // the content of the url() statement is either in group 3 or group 5
            const mod = i % 7;
            if (mod === 3 || mod === 5) {
                // detect quoted url and unescape backslashes
                const before = arr[i - 1], after = arr[i + 1], isQuoted = before === after && (before === "'" || before === '"'), unescaped = isQuoted ? initialised.replace(/\\{2}/g, '\\') : initialised;
                // split into uri and query/hash and then find the absolute path to the uri
                const split = unescaped.split(/([?#])/g), uri = split[0], absolute = testIsRelative(uri) && join(uri, candidate) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
                testIsAbsolute(uri) && join(uri), query = options.keepQuery ? split.slice(1).join('') : '';
                // use the absolute path in absolute mode or else relative path (or default to initialised)
                // #6 - backslashes are not legal in URI
                if (!absolute) {
                    return initialised;
                } else if (options.absolute) {
                    return absolute.replace(/\\/g, '/') + query;
                } else {
                    return _loaderutils2.default.urlToRequest(_path.default.relative(directory, absolute).replace(/\\/g, '/') + query);
                }
            } else {
                return initialised;
            }
        }).join('');
    };
    "TURBOPACK unreachable";
    /**
   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that
   * dogma so we add path.isAbsolute() check to allow them.
   *
   * We also eliminate module relative (~) paths.
   *
   * Returns true for relative uri
   */ function testIsRelative(/** A uri string possibly empty or undefined */ uri) {
        return !!uri && _loaderutils2.default.isUrlRequest(uri, false) && !_path.default.isAbsolute(uri) && uri.indexOf('~') !== 0;
    }
    /**
   * The loaderUtils.isUrlRequest() doesn't support windows absolute paths on principle. We do not subscribe to that
   * dogma so we add path.isAbsolute() check to allow them.
   *
   * Returns true for absolute uri
   */ function testIsAbsolute(/** A uri string possibly empty or undefined */ uri) {
        return !!uri && typeof options.root === 'string' && _loaderutils2.default.isUrlRequest(uri, options.root) && (/^\//.test(uri) || _path.default.isAbsolute(uri));
    }
}
const _default = valueProcessor; //# sourceMappingURL=value-processor.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/join-function.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// TODO: Remove use of `any` type. Fix no-use-before-define violations.
/* eslint-disable @typescript-eslint/no-use-before-define */ /*
The MIT License (MIT)

Copyright (c) 2016 Ben Holloway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "defaultJoin", {
    enumerable: true,
    get: function() {
        return defaultJoin;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _fs = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const compose = (f, g)=>(...args)=>f(g(...args));
const simpleJoin = compose(_path.default.normalize, _path.default.join);
const defaultJoin = createJoinForPredicate(function predicate(_, uri, base, i, next) {
    const absolute = simpleJoin(base, uri);
    return _fs.default.existsSync(absolute) ? absolute : next(i === 0 ? absolute : null);
}, 'defaultJoin');
function* createIterator(arr) {
    for (const i of arr){
        yield i;
    }
}
/**
 * Define a join function by a predicate that tests possible base paths from an iterator.
 *
 * The `predicate` is of the form:
 *
 * ```
 * function(filename, uri, base, i, next):string|null
 * ```
 *
 * Given the uri and base it should either return:
 * - an absolute path success
 * - a call to `next(null)` as failure
 * - a call to `next(absolute)` where absolute is placeholder and the iterator continues
 *
 * The value given to `next(...)` is only used if success does not eventually occur.
 *
 * The `file` value is typically unused but useful if you would like to differentiate behaviour.
 *
 * You can write a much simpler function than this if you have specific requirements.
 *
 */ function createJoinForPredicate(/** predicate A function that tests values */ predicate, /** Optional name for the resulting join function */ name) {
    /**
   * A factory for a join function with logging.
   */ function join(/** The current file being processed */ filename, /** An options hash */ options) {
        const log = createDebugLogger(options.debug);
        /**
     * Join function proper.
     *
     * For absolute uri only `uri` will be provided. In this case we substitute any `root` given in options.
     *
     * Returns Just the uri where base is empty or the uri appended to the base
     */ return function joinProper(/** A uri path, relative or absolute */ uri, /** Optional absolute base path or iterator thereof */ baseOrIteratorOrAbsent) {
            const iterator = typeof baseOrIteratorOrAbsent === 'undefined' && createIterator([
                options.root
            ]) || typeof baseOrIteratorOrAbsent === 'string' && createIterator([
                baseOrIteratorOrAbsent
            ]) || baseOrIteratorOrAbsent;
            const result = runIterator([]);
            log(createJoinMsg, [
                filename,
                uri,
                result,
                result.isFound
            ]);
            return typeof result.absolute === 'string' ? result.absolute : uri;
            "TURBOPACK unreachable";
            function runIterator(accumulator) {
                const nextItem = iterator.next();
                var base = !nextItem.done && nextItem.value;
                if (typeof base === 'string') {
                    const element = predicate(filename, uri, base, accumulator.length, next);
                    if (typeof element === 'string' && _path.default.isAbsolute(element)) {
                        return Object.assign(accumulator.concat(base), {
                            isFound: true,
                            absolute: element
                        });
                    } else if (Array.isArray(element)) {
                        return element;
                    } else {
                        throw Object.defineProperty(new Error('predicate must return an absolute path or the result of calling next()'), "__NEXT_ERROR_CODE", {
                            value: "E313",
                            enumerable: false,
                            configurable: true
                        });
                    }
                } else {
                    return accumulator;
                }
                function next(fallback) {
                    return runIterator(Object.assign(accumulator.concat(base), typeof fallback === 'string' && {
                        absolute: fallback
                    }));
                }
            }
        };
    }
    function toString() {
        return '[Function: ' + name + ']';
    }
    return Object.assign(join, name && {
        valueOf: toString,
        toString: toString
    });
}
/**
 * Format a debug message.
 * Return Formatted message
 */ function createJoinMsg(/** The file being processed by webpack */ file, /**  A uri path, relative or absolute */ uri, /** Absolute base paths up to and including the found one */ bases, /** Indicates the last base was correct */ isFound) {
    return [
        'resolve-url-loader: ' + pathToString(file) + ': ' + uri,
        //
        ...bases.map(pathToString).filter(Boolean),
        ...isFound ? [
            'FOUND'
        ] : [
            'NOT FOUND'
        ]
    ].join('\n  ');
    "TURBOPACK unreachable";
    /**
   * If given path is within `process.cwd()` then show relative posix path, otherwise show absolute posix path.
   *
   * Returns A relative or absolute path
   */ function pathToString(/** An absolute path */ absolute) {
        if (!absolute) {
            return null;
        } else {
            const relative = _path.default.relative(process.cwd(), absolute).split(_path.default.sep);
            return (relative[0] === '..' ? absolute.split(_path.default.sep) : [
                '.'
            ].concat(relative).filter(Boolean)).join('/');
        }
    }
}
exports.createJoinMsg = createJoinMsg;
/**
 * A factory for a log function predicated on the given debug parameter.
 *
 * The logging function created accepts a function that formats a message and parameters that the function utilises.
 * Presuming the message function may be expensive we only call it if logging is enabled.
 *
 * The log messages are de-duplicated based on the parameters, so it is assumed they are simple types that stringify
 * well.
 *
 * Returns A logging function possibly degenerate
 */ function createDebugLogger(/** A boolean or debug function */ debug) {
    const log = !!debug && (typeof debug === 'function' ? debug : console.log);
    const cache = {};
    return log ? actuallyLog : noop;
    "TURBOPACK unreachable";
    function noop() {}
    function actuallyLog(msgFn, params) {
        const key = JSON.stringify(params);
        if (!cache[key]) {
            cache[key] = true;
            log(msgFn.apply(null, params));
        }
    }
}
exports.createDebugLogger = createDebugLogger; //# sourceMappingURL=join-function.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/file-protocol.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
The MIT License (MIT)

Copyright (c) 2016 Ben Holloway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ /**
 * Prepend file:// protocol to source path string or source-map sources.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    prepend: null,
    remove: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    prepend: function() {
        return prepend;
    },
    remove: function() {
        return remove;
    }
});
function prepend(candidate) {
    if (typeof candidate === 'string') {
        return 'file://' + candidate;
    } else if (candidate && typeof candidate === 'object' && Array.isArray(candidate.sources)) {
        return Object.assign({}, candidate, {
            sources: candidate.sources.map(prepend)
        });
    } else {
        throw Object.defineProperty(new Error('expected string|object'), "__NEXT_ERROR_CODE", {
            value: "E489",
            enumerable: false,
            configurable: true
        });
    }
}
function remove(candidate) {
    if (typeof candidate === 'string') {
        return candidate.replace(/^file:\/{2}/, '');
    } else if (candidate && typeof candidate === 'object' && Array.isArray(candidate.sources)) {
        return Object.assign({}, candidate, {
            sources: candidate.sources.map(remove)
        });
    } else {
        throw Object.defineProperty(new Error('expected string|object'), "__NEXT_ERROR_CODE", {
            value: "E489",
            enumerable: false,
            configurable: true
        });
    }
} //# sourceMappingURL=file-protocol.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/postcss.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
The MIT License (MIT)

Copyright (c) 2016 Ben Holloway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return process;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _fileprotocol = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/file-protocol.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const ORPHAN_CR_REGEX = /\r(?!\n)(.|\n)?/g;
function process(postcss, sourceFile, sourceContent, params) {
    // #107 libsass emits orphan CR not considered newline, postcss does consider newline (content vs source-map mismatch)
    postcssPlugin.postcss = true;
    // prepend file protocol to all sources to avoid problems with source map
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return postcss([
        postcssPlugin
    ]).process(sourceContent, {
        from: (0, _fileprotocol.prepend)(sourceFile),
        map: params.outputSourceMap && {
            prev: !!params.inputSourceMap && (0, _fileprotocol.prepend)(params.inputSourceMap),
            inline: false,
            annotation: false,
            sourcesContent: true
        }
    }).then((result)=>({
            content: result.css,
            map: params.outputSourceMap ? (0, _fileprotocol.remove)(result.map.toJSON()) : null
        }));
    "TURBOPACK unreachable";
    /**
   * Plugin for postcss that follows SASS transpilation.
   */ function postcssPlugin() {
        return {
            postcssPlugin: 'postcss-resolve-url',
            Once: function(root) {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                root.walkDecls(eachDeclaration);
            }
        };
        "TURBOPACK unreachable";
        /**
     * Process a declaration from the syntax tree.
     * @param declaration
     */ function eachDeclaration(declaration) {
            const isValid = declaration.value && declaration.value.indexOf('url') >= 0;
            if (isValid) {
                // reverse the original source-map to find the original source file before transpilation
                const startPosApparent = declaration.source.start, startPosOriginal = params.sourceMapConsumer && params.sourceMapConsumer.originalPositionFor(startPosApparent);
                // we require a valid directory for the specified file
                const directory = startPosOriginal && startPosOriginal.source && (0, _fileprotocol.remove)(_path.default.dirname(startPosOriginal.source));
                if (directory) {
                    declaration.value = params.transformDeclaration(declaration.value, directory);
                } else if (params.sourceMapConsumer) {
                    throw Object.defineProperty(new Error('source-map information is not available at url() declaration ' + (ORPHAN_CR_REGEX.test(sourceContent) ? '(found orphan CR, try removeCR option)' : '(no orphan CR found)')), "__NEXT_ERROR_CODE", {
                        value: "E34",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
} //# sourceMappingURL=postcss.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
The MIT License (MIT)

Copyright (c) 2016 Ben Holloway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * A webpack loader that resolves absolute url() paths relative to their original source file.
 * Requires source-maps to do any meaningful work.
 */ "default", {
    enumerable: true,
    get: function() {
        return resolveUrlLoader;
    }
});
const _sourcemap = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/source-map/source-map.js [app-rsc] (ecmascript)");
const _valueprocessor = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/value-processor.js [app-rsc] (ecmascript)"));
const _joinfunction = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/join-function.js [app-rsc] (ecmascript)");
const _postcss = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/lib/postcss.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function resolveUrlLoader(/** Css content */ content, /** The source-map */ sourceMap) {
    const options = Object.assign({
        sourceMap: this.sourceMap,
        silent: false,
        absolute: false,
        keepQuery: false,
        root: false,
        debug: false,
        join: _joinfunction.defaultJoin
    }, this.getOptions());
    let sourceMapConsumer;
    if (sourceMap) {
        sourceMapConsumer = new _sourcemap.SourceMapConsumer(sourceMap);
    }
    const callback = this.async();
    const { postcss } = options.postcss ? await options.postcss() : {
        postcss: __turbopack_context__.r("[project]/node_modules/next/node_modules/postcss/lib/postcss.js [app-rsc] (ecmascript)")
    };
    (0, _postcss.default)(postcss, this.resourcePath, content, {
        outputSourceMap: Boolean(options.sourceMap),
        transformDeclaration: (0, _valueprocessor.default)(this.resourcePath, options),
        inputSourceMap: sourceMap,
        sourceMapConsumer: sourceMapConsumer
    }) // eslint-disable-next-line @typescript-eslint/no-use-before-define
    .catch(onFailure) // eslint-disable-next-line @typescript-eslint/no-use-before-define
    .then(onSuccess);
    function onFailure(error) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        callback(encodeError('CSS error', error));
    }
    function onSuccess(reworked) {
        if (reworked) {
            // complete with source-map
            //  source-map sources are relative to the file being processed
            if (options.sourceMap) {
                callback(null, reworked.content, reworked.map);
            } else {
                callback(null, reworked.content);
            }
        }
    }
    function encodeError(label, exception) {
        return Object.defineProperty(new Error([
            'resolve-url-loader',
            ': ',
            [
                label
            ].concat(typeof exception === 'string' && exception || exception instanceof Error && [
                exception.message,
                exception.stack.split('\n', 2)[1].trim()
            ] || []).filter(Boolean).join('\n  ')
        ].join('')), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * For server-side CSS imports, we need to ignore the actual module content but
 * still trigger the hot-reloading diff mechanism. So here we put the content
 * inside a comment.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _crypto = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const NextServerCSSLoader = function(content) {
    this.cacheable && this.cacheable();
    const options = this.getOptions();
    let isCSSModule = options.cssModules;
    // Only add the checksum during development.
    if ("TURBOPACK compile-time truthy", 1) {
        // This check is only for backwards compatibility.
        // TODO: Remove this in the next major version (next 14)
        if (isCSSModule === undefined) {
            this.emitWarning(Object.defineProperty(new Error("No 'cssModules' option was found for the next-flight-css-loader plugin."), "__NEXT_ERROR_CODE", {
                value: "E8",
                enumerable: false,
                configurable: true
            }));
            isCSSModule = this.resourcePath.match(/\.module\.(css|sass|scss)$/) !== null;
        }
        const checksum = _crypto.default.createHash('sha1').update(typeof content === 'string' ? Buffer.from(content) : content).digest().toString('hex').substring(0, 12);
        if (isCSSModule) {
            return `\
${content}
module.exports.__checksum = ${JSON.stringify(checksum)}
`;
        }
        // Server CSS imports are always available for HMR, so we attach
        // `module.hot.accept()` to the generated module.
        const hmrCode = 'if (module.hot) { module.hot.accept() }';
        return `\
export default ${JSON.stringify(checksum)}
${hmrCode}
`;
    }
    "TURBOPACK unreachable";
};
const _default = NextServerCSSLoader; //# sourceMappingURL=next-flight-css-loader.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/mini-css-extract-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-ignore: TODO: remove when webpack 5 is stable
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return NextMiniCssExtractPlugin;
    }
});
const _minicssextractplugin = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/mini-css-extract-plugin/cjs.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class NextMiniCssExtractPlugin extends _minicssextractplugin.default {
    constructor(...args){
        super(...args), this.__next_css_remove = true;
    }
} //# sourceMappingURL=mini-css-extract-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/helpers.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    loader: null,
    plugin: null,
    unshiftLoader: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    loader: function() {
        return loader;
    },
    plugin: function() {
        return plugin;
    },
    unshiftLoader: function() {
        return unshiftLoader;
    }
});
const _lodashcurry = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/lodash.curry/index.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const loader = (0, _lodashcurry.default)(function loader(rule, config) {
    var _config_module_rules;
    if (!config.module) {
        config.module = {
            rules: []
        };
    }
    if (rule.oneOf) {
        var _config_module_rules1;
        const existing = (_config_module_rules1 = config.module.rules) == null ? void 0 : _config_module_rules1.find((arrayRule)=>arrayRule && typeof arrayRule === 'object' && arrayRule.oneOf);
        if (existing && typeof existing === 'object') {
            existing.oneOf.push(...rule.oneOf);
            return config;
        }
    }
    (_config_module_rules = config.module.rules) == null ? void 0 : _config_module_rules.push(rule);
    return config;
});
const unshiftLoader = (0, _lodashcurry.default)(function unshiftLoader(rule, config) {
    var _config_module_rules;
    if (!config.module) {
        config.module = {
            rules: []
        };
    }
    if (rule.oneOf) {
        var _config_module_rules1;
        const existing = (_config_module_rules1 = config.module.rules) == null ? void 0 : _config_module_rules1.find((arrayRule)=>arrayRule && typeof arrayRule === 'object' && arrayRule.oneOf);
        if (existing && typeof existing === 'object') {
            var _existing_oneOf;
            (_existing_oneOf = existing.oneOf) == null ? void 0 : _existing_oneOf.unshift(...rule.oneOf);
            return config;
        }
    }
    (_config_module_rules = config.module.rules) == null ? void 0 : _config_module_rules.unshift(rule);
    return config;
});
const plugin = (0, _lodashcurry.default)(function plugin(p, config) {
    if (!config.plugins) {
        config.plugins = [];
    }
    config.plugins.push(p);
    return config;
}); //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pipe", {
    enumerable: true,
    get: function() {
        return pipe;
    }
});
const pipe = (...fns)=>(param)=>fns.reduce(async (result, next)=>next(await result), param); //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/client.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getClientStyleLoader", {
    enumerable: true,
    get: function() {
        return getClientStyleLoader;
    }
});
const _getrspack = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-rspack.js [app-rsc] (ecmascript)");
function getClientStyleLoader({ hasAppDir, isAppDir, isDevelopment, assetPrefix }) {
    const isRspack = Boolean(process.env.NEXT_RSPACK);
    const shouldEnableApp = typeof isAppDir === 'boolean' ? isAppDir : hasAppDir;
    // Keep next-style-loader for development mode in `pages/`
    if (isDevelopment && !shouldEnableApp) {
        return {
            loader: 'next-style-loader',
            options: {
                insert: function(element) {
                    // By default, style-loader injects CSS into the bottom
                    // of <head>. This causes ordering problems between dev
                    // and prod. To fix this, we render a <noscript> tag as
                    // an anchor for the styles to be placed before. These
                    // styles will be applied _before_ <style jsx global>.
                    // These elements should always exist. If they do not,
                    // this code should fail.
                    var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                    var parentNode = anchorElement.parentNode // Normally <head>
                    ;
                    // Each style tag should be placed right before our
                    // anchor. By inserting before and not after, we do not
                    // need to track the last inserted element.
                    parentNode.insertBefore(element, anchorElement);
                }
            }
        };
    }
    const MiniCssExtractPlugin = isRspack ? (0, _getrspack.getRspackCore)().rspack.CssExtractRspackPlugin : __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/mini-css-extract-plugin.js [app-rsc] (ecmascript)").default;
    return {
        loader: MiniCssExtractPlugin.loader,
        options: {
            publicPath: `${assetPrefix}/_next/`,
            esModule: false
        }
    };
} //# sourceMappingURL=client.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/file-resolve.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "cssFileResolve", {
    enumerable: true,
    get: function() {
        return cssFileResolve;
    }
});
function cssFileResolve(url, _resourcePath, urlImports) {
    if (url.startsWith('/')) {
        return false;
    }
    if (!urlImports && /^[a-z][a-z0-9+.-]*:/i.test(url)) {
        return false;
    }
    return true;
} //# sourceMappingURL=file-resolve.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/CssSyntaxError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return CssSyntaxError;
    }
});
class CssSyntaxError extends Error {
    constructor(error){
        super(error);
        const { reason, line, column } = error;
        this.name = 'CssSyntaxError';
        // Based on https://github.com/postcss/postcss/blob/master/lib/css-syntax-error.es6#L132
        // We don't need `plugin` and `file` properties.
        this.message = `${this.name}\n\n`;
        if (typeof line !== 'undefined') {
            this.message += `(${line}:${column}) `;
        }
        this.message += reason;
        const code = error.showSourceCode();
        if (code) {
            this.message += `\n\n${code}\n`;
        }
        // We don't need stack https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md#31-dont-show-js-stack-for-csssyntaxerror
        this.stack = false;
    }
} //# sourceMappingURL=CssSyntaxError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/Warning.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * **PostCSS Plugin Warning**
 *
 * Loader wrapper for postcss plugin warnings (`root.messages`)
 *
 * @class Warning
 * @extends Error
 *
 * @param {Object} warning PostCSS Warning
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return Warning;
    }
});
class Warning extends Error {
    constructor(warning){
        super(warning);
        const { text, line, column, plugin } = warning;
        this.name = 'Warning';
        this.message = `${this.name}\n\n`;
        if (typeof line !== 'undefined') {
            this.message += `(${line}:${column}) `;
        }
        this.message += plugin ? `${plugin}: ` : '';
        this.message += text;
        this.stack = false;
    }
} //# sourceMappingURL=Warning.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/stringify-request.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "stringifyRequest", {
    enumerable: true,
    get: function() {
        return stringifyRequest;
    }
});
function stringifyRequest(loaderContext, request) {
    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context || loaderContext.rootContext, request));
} //# sourceMappingURL=stringify-request.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/camelcase.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const preserveCamelCase = (string, locale)=>{
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for(let i = 0; i < string.length; i++){
        const character = string[i];
        if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
            string = string.slice(0, i) + '-' + string.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
            string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
        } else {
            isLastCharLower = character.toLocaleLowerCase(locale) === character && character.toLocaleUpperCase(locale) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = character.toLocaleUpperCase(locale) === character && character.toLocaleLowerCase(locale) !== character;
        }
    }
    return string;
};
const preserveConsecutiveUppercase = (input)=>{
    return input.replace(/^[\p{Lu}](?![\p{Lu}])/gu, (m1)=>m1.toLowerCase());
};
const postProcess = (input, options)=>{
    return input.replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1)=>p1.toLocaleUpperCase(options.locale)).replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, (m)=>m.toLocaleUpperCase(options.locale));
};
const camelCase = (input, options)=>{
    if (!(typeof input === 'string' || Array.isArray(input))) {
        throw Object.defineProperty(new TypeError('Expected the input to be `string | string[]`'), "__NEXT_ERROR_CODE", {
            value: "E613",
            enumerable: false,
            configurable: true
        });
    }
    options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
    };
    if (Array.isArray(input)) {
        input = input.map((x)=>x.trim()).filter((x)=>x.length).join('-');
    } else {
        input = input.trim();
    }
    if (input.length === 0) {
        return '';
    }
    if (input.length === 1) {
        return options.pascalCase ? input.toLocaleUpperCase(options.locale) : input.toLocaleLowerCase(options.locale);
    }
    const hasUpperCase = input !== input.toLocaleLowerCase(options.locale);
    if (hasUpperCase) {
        input = preserveCamelCase(input, options.locale);
    }
    input = input.replace(/^[_.\- ]+/, '');
    if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input);
    } else {
        input = input.toLocaleLowerCase();
    }
    if (options.pascalCase) {
        input = input.charAt(0).toLocaleUpperCase(options.locale) + input.slice(1);
    }
    return postProcess(input, options);
};
const _default = camelCase; //# sourceMappingURL=camelcase.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    dashesCamelCase: null,
    getExportCode: null,
    getFilter: null,
    getImportCode: null,
    getModuleCode: null,
    getModulesPlugins: null,
    getPreRequester: null,
    isDataUrl: null,
    isUrlRequestable: null,
    normalizeSourceMap: null,
    normalizeSourceMapForRuntime: null,
    normalizeUrl: null,
    requestify: null,
    resolveRequests: null,
    shouldUseIcssPlugin: null,
    shouldUseImportPlugin: null,
    shouldUseModulesPlugins: null,
    shouldUseURLPlugin: null,
    sort: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    dashesCamelCase: function() {
        return dashesCamelCase;
    },
    getExportCode: function() {
        return getExportCode;
    },
    getFilter: function() {
        return getFilter;
    },
    getImportCode: function() {
        return getImportCode;
    },
    getModuleCode: function() {
        return getModuleCode;
    },
    getModulesPlugins: function() {
        return getModulesPlugins;
    },
    getPreRequester: function() {
        return getPreRequester;
    },
    isDataUrl: function() {
        return isDataUrl;
    },
    isUrlRequestable: function() {
        return isUrlRequestable;
    },
    normalizeSourceMap: function() {
        return normalizeSourceMap;
    },
    // For lightningcss-loader
    normalizeSourceMapForRuntime: function() {
        return normalizeSourceMapForRuntime;
    },
    normalizeUrl: function() {
        return normalizeUrl;
    },
    requestify: function() {
        return requestify;
    },
    resolveRequests: function() {
        return resolveRequests;
    },
    shouldUseIcssPlugin: function() {
        return shouldUseIcssPlugin;
    },
    shouldUseImportPlugin: function() {
        return shouldUseImportPlugin;
    },
    shouldUseModulesPlugins: function() {
        return shouldUseModulesPlugins;
    },
    shouldUseURLPlugin: function() {
        return shouldUseURLPlugin;
    },
    sort: function() {
        return sort;
    }
});
const _url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _loaderutils3 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/loader-utils3/index.js [app-rsc] (ecmascript)");
const _postcssmodulesvalues = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-modules-values/index.js [app-rsc] (ecmascript)"));
const _postcssmoduleslocalbydefault = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-modules-local-by-default/index.js [app-rsc] (ecmascript)"));
const _postcssmodulesextractimports = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-modules-extract-imports/index.js [app-rsc] (ecmascript)"));
const _postcssmodulesscope = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-modules-scope/index.js [app-rsc] (ecmascript)"));
const _camelcase = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/camelcase.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const whitespace = '[\\x20\\t\\r\\n\\f]';
const unescapeRegExp = new RegExp(`\\\\([\\da-f]{1,6}${whitespace}?|(${whitespace})|.)`, 'ig');
const matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
function unescape(str) {
    return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace)=>{
        const high = `0x${escaped}` - 0x10000;
        /* eslint-disable line-comment-position */ // NaN means non-codepoint
        // Workaround erroneous numeric interpretation of +"0x"
        // eslint-disable-next-line no-self-compare
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
    /* eslint-enable line-comment-position */ });
}
function normalizePath(file) {
    return _path.default.sep === '\\' ? file.replace(/\\/g, '/') : file;
}
function fixedEncodeURIComponent(str) {
    return str.replace(/[!'()*]/g, (c)=>`%${c.charCodeAt(0).toString(16)}`);
}
function normalizeUrl(url, isStringValue) {
    let normalizedUrl = url;
    if (isStringValue && /\\(\n|\r\n|\r|\f)/.test(normalizedUrl)) {
        normalizedUrl = normalizedUrl.replace(/\\(\n|\r\n|\r|\f)/g, '');
    }
    if (matchNativeWin32Path.test(url)) {
        try {
            normalizedUrl = decodeURIComponent(normalizedUrl);
        } catch (error) {
        // Ignores invalid and broken URLs and try to resolve them as is
        }
        return normalizedUrl;
    }
    normalizedUrl = unescape(normalizedUrl);
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (isDataUrl(url)) {
        return fixedEncodeURIComponent(normalizedUrl);
    }
    try {
        normalizedUrl = decodeURI(normalizedUrl);
    } catch (error) {
    // Ignores invalid and broken URLs and try to resolve them as is
    }
    return normalizedUrl;
}
function requestify(url, rootContext) {
    if (/^file:/i.test(url)) {
        return (0, _url.fileURLToPath)(url);
    }
    if (/^[a-z][a-z0-9+.-]*:/i.test(url)) {
        return url;
    }
    return url.charAt(0) === '/' ? (0, _loaderutils3.urlToRequest)(url, rootContext) : (0, _loaderutils3.urlToRequest)(url);
}
function getFilter(filter, resourcePath) {
    return (...args)=>{
        if (typeof filter === 'function') {
            return filter(...args, resourcePath);
        }
        return true;
    };
}
function shouldUseImportPlugin(options) {
    if (options.modules.exportOnlyLocals) {
        return false;
    }
    if (typeof options.import === 'boolean') {
        return options.import;
    }
    return true;
}
function shouldUseURLPlugin(options) {
    if (options.modules.exportOnlyLocals) {
        return false;
    }
    if (typeof options.url === 'boolean') {
        return options.url;
    }
    return true;
}
function shouldUseModulesPlugins(options) {
    return options.modules.compileType === 'module';
}
function shouldUseIcssPlugin(options) {
    return options.icss === true || Boolean(options.modules);
}
function getModulesPlugins(options, loaderContext, meta) {
    const { mode, getLocalIdent, localIdentName, localIdentContext, localIdentHashPrefix, localIdentRegExp } = options.modules;
    let plugins = [];
    try {
        plugins = [
            _postcssmodulesvalues.default,
            (0, _postcssmoduleslocalbydefault.default)({
                mode
            }),
            (0, _postcssmodulesextractimports.default)(),
            (0, _postcssmodulesscope.default)({
                generateScopedName (exportName) {
                    return getLocalIdent(loaderContext, localIdentName, exportName, {
                        context: localIdentContext,
                        hashPrefix: localIdentHashPrefix,
                        regExp: localIdentRegExp
                    }, meta);
                },
                exportGlobals: options.modules.exportGlobals
            })
        ];
    } catch (error) {
        loaderContext.emitError(error);
    }
    return plugins;
}
const IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\]|^\\\\/i;
const ABSOLUTE_SCHEME = /^[a-z0-9+\-.]+:/i;
function getURLType(source) {
    if (source[0] === '/') {
        if (source[1] === '/') {
            return 'scheme-relative';
        }
        return 'path-absolute';
    }
    if (IS_NATIVE_WIN32_PATH.test(source)) {
        return 'path-absolute';
    }
    return ABSOLUTE_SCHEME.test(source) ? 'absolute' : 'path-relative';
}
function normalizeSourceMap(map, resourcePath) {
    let newMap = map;
    // Some loader emit source map as string
    // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.
    if (typeof newMap === 'string') {
        newMap = JSON.parse(newMap);
    }
    delete newMap.file;
    const { sourceRoot } = newMap;
    delete newMap.sourceRoot;
    if (newMap.sources) {
        // Source maps should use forward slash because it is URLs (https://github.com/mozilla/source-map/issues/91)
        // We should normalize path because previous loaders like `sass-loader` using backslash when generate source map
        newMap.sources = newMap.sources.map((source)=>{
            // Non-standard syntax from `postcss`
            if (source.startsWith('<')) {
                return source;
            }
            const sourceType = getURLType(source);
            // Do no touch `scheme-relative` and `absolute` URLs
            if (sourceType === 'path-relative' || sourceType === 'path-absolute') {
                const absoluteSource = sourceType === 'path-relative' && sourceRoot ? _path.default.resolve(sourceRoot, normalizePath(source)) : normalizePath(source);
                return _path.default.relative(_path.default.dirname(resourcePath), absoluteSource);
            }
            return source;
        });
    }
    return newMap;
}
function getPreRequester({ loaders, loaderIndex }) {
    const cache = Object.create(null);
    return (number)=>{
        if (cache[number]) {
            return cache[number];
        }
        if (number === false) {
            cache[number] = '';
        } else {
            const loadersRequest = loaders.slice(loaderIndex, loaderIndex + 1 + (typeof number !== 'number' ? 0 : number)).map((x)=>x.request).join('!');
            cache[number] = `-!${loadersRequest}!`;
        }
        return cache[number];
    };
}
function getImportCode(imports, options) {
    let code = '';
    for (const item of imports){
        const { importName, url, icss } = item;
        if (options.esModule) {
            if (icss && options.modules.namedExport) {
                code += `import ${options.modules.exportOnlyLocals ? '' : `${importName}, `}* as ${importName}_NAMED___ from ${url};\n`;
            } else {
                code += `import ${importName} from ${url};\n`;
            }
        } else {
            code += `var ${importName} = require(${url});\n`;
        }
    }
    return code ? `// Imports\n${code}` : '';
}
function normalizeSourceMapForRuntime(map, loaderContext) {
    const resultMap = map ? map.toJSON() : null;
    if (resultMap) {
        delete resultMap.file;
        resultMap.sourceRoot = '';
        resultMap.sources = resultMap.sources.map((source)=>{
            // Non-standard syntax from `postcss`
            if (source.startsWith('<')) {
                return source;
            }
            const sourceType = getURLType(source);
            if (sourceType !== 'path-relative') {
                return source;
            }
            const resourceDirname = _path.default.dirname(loaderContext.resourcePath);
            const absoluteSource = _path.default.resolve(resourceDirname, source);
            const contextifyPath = normalizePath(_path.default.relative(loaderContext.rootContext, absoluteSource));
            return `webpack://${contextifyPath}`;
        });
    }
    return JSON.stringify(resultMap);
}
function getModuleCode(result, api, replacements, options, loaderContext) {
    if (options.modules.exportOnlyLocals === true) {
        return '';
    }
    const sourceMapValue = options.sourceMap ? `,${normalizeSourceMapForRuntime(result.map, loaderContext)}` : '';
    let code = JSON.stringify(result.css);
    let beforeCode = `var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(${options.sourceMap});\n`;
    for (const item of api){
        const { url, media, dedupe } = item;
        beforeCode += url ? `___CSS_LOADER_EXPORT___.push([module.id, ${JSON.stringify(`@import url(${url});`)}${media ? `, ${JSON.stringify(media)}` : ''}]);\n` : `___CSS_LOADER_EXPORT___.i(${item.importName}${media ? `, ${JSON.stringify(media)}` : dedupe ? ', ""' : ''}${dedupe ? ', true' : ''});\n`;
    }
    for (const item of replacements){
        const { replacementName, importName, localName } = item;
        if (localName) {
            code = code.replace(new RegExp(replacementName, 'g'), ()=>options.modules.namedExport ? `" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + "` : `" + ${importName}.locals[${JSON.stringify(localName)}] + "`);
        } else {
            const { hash, needQuotes } = item;
            const getUrlOptions = [
                ...hash ? [
                    `hash: ${JSON.stringify(hash)}`
                ] : [],
                ...needQuotes ? 'needQuotes: true' : []
            ];
            const preparedOptions = getUrlOptions.length > 0 ? `, { ${getUrlOptions.join(', ')} }` : '';
            beforeCode += `var ${replacementName} = ___CSS_LOADER_GET_URL_IMPORT___(${importName}${preparedOptions});\n`;
            code = code.replace(new RegExp(replacementName, 'g'), ()=>`" + ${replacementName} + "`);
        }
    }
    return `${beforeCode}// Module\n___CSS_LOADER_EXPORT___.push([module.id, ${code}, ""${sourceMapValue}]);\n`;
}
function dashesCamelCase(str) {
    return str.replace(/-+(\w)/g, (_match, firstLetter)=>firstLetter.toUpperCase());
}
function getExportCode(exports1, replacements, options) {
    let code = '// Exports\n';
    let localsCode = '';
    const addExportToLocalsCode = (name, value)=>{
        if (options.modules.namedExport) {
            localsCode += `export const ${(0, _camelcase.default)(name)} = ${JSON.stringify(value)};\n`;
        } else {
            if (localsCode) {
                localsCode += `,\n`;
            }
            localsCode += `\t${JSON.stringify(name)}: ${JSON.stringify(value)}`;
        }
    };
    for (const { name, value } of exports1){
        switch(options.modules.exportLocalsConvention){
            case 'camelCase':
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = (0, _camelcase.default)(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case 'camelCaseOnly':
                {
                    addExportToLocalsCode((0, _camelcase.default)(name), value);
                    break;
                }
            case 'dashes':
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = dashesCamelCase(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case 'dashesOnly':
                {
                    addExportToLocalsCode(dashesCamelCase(name), value);
                    break;
                }
            case 'asIs':
            default:
                addExportToLocalsCode(name, value);
                break;
        }
    }
    for (const item of replacements){
        const { replacementName, localName } = item;
        if (localName) {
            const { importName } = item;
            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>{
                if (options.modules.namedExport) {
                    return `" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + "`;
                } else if (options.modules.exportOnlyLocals) {
                    return `" + ${importName}[${JSON.stringify(localName)}] + "`;
                }
                return `" + ${importName}.locals[${JSON.stringify(localName)}] + "`;
            });
        } else {
            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>`" + ${replacementName} + "`);
        }
    }
    if (options.modules.exportOnlyLocals) {
        code += options.modules.namedExport ? localsCode : `${options.esModule ? 'export default' : 'module.exports ='} {\n${localsCode}\n};\n`;
        return code;
    }
    if (localsCode) {
        code += options.modules.namedExport ? localsCode : `___CSS_LOADER_EXPORT___.locals = {\n${localsCode}\n};\n`;
    }
    code += `${options.esModule ? 'export default' : 'module.exports ='} ___CSS_LOADER_EXPORT___;\n`;
    return code;
}
async function resolveRequests(resolve, context, possibleRequests) {
    return resolve(context, possibleRequests[0]).then((result)=>{
        return result;
    }).catch((error)=>{
        const [, ...tailPossibleRequests] = possibleRequests;
        if (tailPossibleRequests.length === 0) {
            throw error;
        }
        return resolveRequests(resolve, context, tailPossibleRequests);
    });
}
function isUrlRequestable(url) {
    // Protocol-relative URLs
    if (/^\/\//.test(url)) {
        return false;
    }
    // `file:` protocol
    if (/^file:/i.test(url)) {
        return true;
    }
    // Absolute URLs
    if (/^[a-z][a-z0-9+.-]*:/i.test(url)) {
        return true;
    }
    // `#` URLs
    if (/^#/.test(url)) {
        return false;
    }
    return true;
}
function sort(a, b) {
    return a.index - b.index;
}
function isDataUrl(url) {
    if (/^data:/i.test(url)) {
        return true;
    }
    return false;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-import-parser.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _postcssvalueparser = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-value-parser/index.js [app-rsc] (ecmascript)"));
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parseNode(atRule, key) {
    // Convert only top-level @import
    if (atRule.parent.type !== 'root') {
        return;
    }
    if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {
        const lastCommentIndex = atRule.raws.afterName.lastIndexOf('/*');
        const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched && matched[2] === 'true') {
            return;
        }
    }
    const prevNode = atRule.prev();
    if (prevNode && prevNode.type === 'comment') {
        const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched && matched[2] === 'true') {
            return;
        }
    }
    // Nodes do not exists - `@import url('http://') :root {}`
    if (atRule.nodes) {
        const error = Object.defineProperty(new Error("It looks like you didn't end your @import statement correctly. Child nodes are attached to it."), "__NEXT_ERROR_CODE", {
            value: "E341",
            enumerable: false,
            configurable: true
        });
        error.node = atRule;
        throw error;
    }
    const { nodes: paramsNodes } = (0, _postcssvalueparser.default)(atRule[key]);
    // No nodes - `@import ;`
    // Invalid type - `@import foo-bar;`
    if (paramsNodes.length === 0 || paramsNodes[0].type !== 'string' && paramsNodes[0].type !== 'function') {
        const error = Object.defineProperty(new Error(`Unable to find uri in "${atRule.toString()}"`), "__NEXT_ERROR_CODE", {
            value: "E215",
            enumerable: false,
            configurable: true
        });
        error.node = atRule;
        throw error;
    }
    let isStringValue;
    let url;
    if (paramsNodes[0].type === 'string') {
        isStringValue = true;
        url = paramsNodes[0].value;
    } else {
        // Invalid function - `@import nourl(test.css);`
        if (paramsNodes[0].value.toLowerCase() !== 'url') {
            const error = Object.defineProperty(new Error(`Unable to find uri in "${atRule.toString()}"`), "__NEXT_ERROR_CODE", {
                value: "E215",
                enumerable: false,
                configurable: true
            });
            error.node = atRule;
            throw error;
        }
        isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === 'string';
        url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssvalueparser.default.stringify(paramsNodes[0].nodes);
    }
    url = (0, _utils.normalizeUrl)(url, isStringValue);
    const isRequestable = (0, _utils.isUrlRequestable)(url);
    let prefix;
    if (isRequestable) {
        const queryParts = url.split('!');
        if (queryParts.length > 1) {
            url = queryParts.pop();
            prefix = queryParts.join('!');
        }
    }
    // Empty url - `@import "";` or `@import url();`
    if (url.trim().length === 0) {
        const error = Object.defineProperty(new Error(`Unable to find uri in "${atRule.toString()}"`), "__NEXT_ERROR_CODE", {
            value: "E215",
            enumerable: false,
            configurable: true
        });
        error.node = atRule;
        throw error;
    }
    const mediaNodes = paramsNodes.slice(1);
    let media;
    if (mediaNodes.length > 0) {
        media = _postcssvalueparser.default.stringify(mediaNodes).trim().toLowerCase();
    }
    // eslint-disable-next-line consistent-return
    return {
        atRule,
        prefix,
        url,
        media,
        isRequestable
    };
}
const plugin = (options = {})=>{
    return {
        postcssPlugin: 'postcss-import-parser',
        prepare (result) {
            const parsedAtRules = [];
            return {
                AtRule: {
                    import (atRule) {
                        let parsedAtRule;
                        try {
                            // @ts-expect-error TODO: there is no third argument?
                            parsedAtRule = parseNode(atRule, 'params', result);
                        } catch (error) {
                            result.warn(error.message, {
                                node: error.node
                            });
                        }
                        if (!parsedAtRule) {
                            return;
                        }
                        parsedAtRules.push(parsedAtRule);
                    }
                },
                async OnceExit () {
                    if (parsedAtRules.length === 0) {
                        return;
                    }
                    const resolvedAtRules = await Promise.all(parsedAtRules.map(async (parsedAtRule)=>{
                        const { atRule, isRequestable, prefix, url, media } = parsedAtRule;
                        if (options.filter) {
                            const needKeep = await options.filter(url, media);
                            if (!needKeep) {
                                return;
                            }
                        }
                        if (isRequestable) {
                            const request = (0, _utils.requestify)(url, options.rootContext);
                            const { resolver, context } = options;
                            const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                                ...new Set([
                                    request,
                                    url
                                ])
                            ]);
                            if (!resolvedUrl) {
                                return;
                            }
                            if (resolvedUrl === options.resourcePath) {
                                atRule.remove();
                                return;
                            }
                            atRule.remove();
                            // eslint-disable-next-line consistent-return
                            return {
                                url: resolvedUrl,
                                media,
                                prefix,
                                isRequestable
                            };
                        }
                        atRule.remove();
                        // eslint-disable-next-line consistent-return
                        return {
                            url,
                            media,
                            prefix,
                            isRequestable
                        };
                    }));
                    const urlToNameMap = new Map();
                    for(let index = 0; index <= resolvedAtRules.length - 1; index++){
                        const resolvedAtRule = resolvedAtRules[index];
                        if (!resolvedAtRule) {
                            continue;
                        }
                        const { url, isRequestable, media } = resolvedAtRule;
                        if (!isRequestable) {
                            options.api.push({
                                url,
                                media,
                                index
                            });
                            continue;
                        }
                        const { prefix } = resolvedAtRule;
                        const newUrl = prefix ? `${prefix}!${url}` : url;
                        let importName = urlToNameMap.get(newUrl);
                        if (!importName) {
                            importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;
                            urlToNameMap.set(newUrl, importName);
                            options.imports.push({
                                type: 'rule_import',
                                importName,
                                url: options.urlHandler(newUrl),
                                index
                            });
                        }
                        options.api.push({
                            importName,
                            media,
                            index
                        });
                    }
                }
            };
        }
    };
};
plugin.postcss = true;
const _default = plugin; //# sourceMappingURL=postcss-import-parser.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-icss-parser.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _icssutils = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/icss-utils/index.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
const plugin = (options = {})=>{
    return {
        postcssPlugin: 'postcss-icss-parser',
        async OnceExit (root) {
            const importReplacements = Object.create(null);
            const { icssImports, icssExports } = (0, _icssutils.extractICSS)(root);
            const imports = new Map();
            const tasks = [];
            // eslint-disable-next-line guard-for-in
            for(const url in icssImports){
                const tokens = icssImports[url];
                if (Object.keys(tokens).length === 0) {
                    continue;
                }
                let normalizedUrl = url;
                let prefix = '';
                const queryParts = normalizedUrl.split('!');
                if (queryParts.length > 1) {
                    normalizedUrl = queryParts.pop();
                    prefix = queryParts.join('!');
                }
                const request = (0, _utils.requestify)((0, _utils.normalizeUrl)(normalizedUrl, true), options.rootContext);
                const doResolve = async ()=>{
                    const { resolver, context } = options;
                    const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                        ...new Set([
                            normalizedUrl,
                            request
                        ])
                    ]);
                    if (!resolvedUrl) {
                        return;
                    }
                    // eslint-disable-next-line consistent-return
                    return {
                        url: resolvedUrl,
                        prefix,
                        tokens
                    };
                };
                tasks.push(doResolve());
            }
            const results = await Promise.all(tasks);
            for(let index = 0; index <= results.length - 1; index++){
                const item = results[index];
                if (!item) {
                    continue;
                }
                const newUrl = item.prefix ? `${item.prefix}!${item.url}` : item.url;
                const importKey = newUrl;
                let importName = imports.get(importKey);
                if (!importName) {
                    importName = `___CSS_LOADER_ICSS_IMPORT_${imports.size}___`;
                    imports.set(importKey, importName);
                    options.imports.push({
                        type: 'icss_import',
                        importName,
                        url: options.urlHandler(newUrl),
                        icss: true,
                        index
                    });
                    options.api.push({
                        importName,
                        dedupe: true,
                        index
                    });
                }
                for (const [replacementIndex, token] of Object.keys(item.tokens).entries()){
                    const replacementName = `___CSS_LOADER_ICSS_IMPORT_${index}_REPLACEMENT_${replacementIndex}___`;
                    const localName = item.tokens[token];
                    importReplacements[token] = replacementName;
                    options.replacements.push({
                        replacementName,
                        importName,
                        localName
                    });
                }
            }
            if (Object.keys(importReplacements).length > 0) {
                (0, _icssutils.replaceSymbols)(root, importReplacements);
            }
            for (const name of Object.keys(icssExports)){
                const value = (0, _icssutils.replaceValueSymbols)(icssExports[name], importReplacements);
                options.exports.push({
                    name,
                    value
                });
            }
        }
    };
};
plugin.postcss = true;
const _default = plugin; //# sourceMappingURL=postcss-icss-parser.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = function(url, options) {
    if (!options) {
        // eslint-disable-next-line no-param-reassign
        options = {};
    } // eslint-disable-next-line no-underscore-dangle, no-param-reassign
    url = url && url.__esModule ? url.default : url;
    if (typeof url !== 'string') {
        return url;
    } // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        // eslint-disable-next-line no-param-reassign
        url = url.slice(1, -1);
    }
    if (options.hash) {
        // eslint-disable-next-line no-param-reassign
        url += options.hash;
    } // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url) || options.needQuotes) {
        return '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), '"');
    }
    return url;
}; //# sourceMappingURL=getUrl.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-url-parser.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _postcssvalueparser = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-value-parser/index.js [app-rsc] (ecmascript)"));
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const isUrlFunc = /url/i;
const isImageSetFunc = /^(?:-webkit-)?image-set$/i;
const needParseDeclaration = /(?:url|(?:-webkit-)?image-set)\(/i;
function getNodeFromUrlFunc(node) {
    return node.nodes && node.nodes[0];
}
function getWebpackIgnoreCommentValue(index, nodes, inBetween) {
    if (index === 0 && typeof inBetween !== 'undefined') {
        return inBetween;
    }
    let prevValueNode = nodes[index - 1];
    if (!prevValueNode) {
        // eslint-disable-next-line consistent-return
        return;
    }
    if (prevValueNode.type === 'space') {
        if (!nodes[index - 2]) {
            // eslint-disable-next-line consistent-return
            return;
        }
        prevValueNode = nodes[index - 2];
    }
    if (prevValueNode.type !== 'comment') {
        // eslint-disable-next-line consistent-return
        return;
    }
    const matched = prevValueNode.value.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
    return matched && matched[2] === 'true';
}
function shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL) {
    if (url.length === 0) {
        result.warn(`Unable to find uri in '${declaration.toString()}'`, {
            node: declaration
        });
        return false;
    }
    if ((0, _utils.isDataUrl)(url) && isSupportDataURLInNewURL) {
        try {
            decodeURIComponent(url);
        } catch (ignoreError) {
            return false;
        }
        return true;
    }
    if (!(0, _utils.isUrlRequestable)(url)) {
        return false;
    }
    return true;
}
function parseDeclaration(declaration, key, result, isSupportDataURLInNewURL) {
    if (!needParseDeclaration.test(declaration[key])) {
        return;
    }
    const parsed = (0, _postcssvalueparser.default)(declaration.raws && declaration.raws.value && declaration.raws.value.raw ? declaration.raws.value.raw : declaration[key]);
    let inBetween;
    if (declaration.raws && declaration.raws.between) {
        const lastCommentIndex = declaration.raws.between.lastIndexOf('/*');
        const matched = declaration.raws.between.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched) {
            inBetween = matched[2] === 'true';
        }
    }
    let isIgnoreOnDeclaration = false;
    const prevNode = declaration.prev();
    if (prevNode && prevNode.type === 'comment') {
        const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);
        if (matched) {
            isIgnoreOnDeclaration = matched[2] === 'true';
        }
    }
    let needIgnore;
    const parsedURLs = [];
    parsed.walk((valueNode, index, valueNodes)=>{
        if (valueNode.type !== 'function') {
            return;
        }
        if (isUrlFunc.test(valueNode.value)) {
            needIgnore = getWebpackIgnoreCommentValue(index, valueNodes, inBetween);
            if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {
                if (needIgnore) {
                    // eslint-disable-next-line no-undefined
                    needIgnore = undefined;
                }
                return;
            }
            const { nodes } = valueNode;
            const isStringValue = nodes.length !== 0 && nodes[0].type === 'string';
            let url = isStringValue ? nodes[0].value : _postcssvalueparser.default.stringify(nodes);
            url = (0, _utils.normalizeUrl)(url, isStringValue);
            // Do not traverse inside `url`
            if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {
                // eslint-disable-next-line consistent-return
                return false;
            }
            const queryParts = url.split('!');
            let prefix;
            if (queryParts.length > 1) {
                url = queryParts.pop();
                prefix = queryParts.join('!');
            }
            parsedURLs.push({
                declaration,
                parsed,
                node: getNodeFromUrlFunc(valueNode),
                prefix,
                url,
                needQuotes: false
            });
            // eslint-disable-next-line consistent-return
            return false;
        } else if (isImageSetFunc.test(valueNode.value)) {
            for (const [innerIndex, nNode] of valueNode.nodes.entries()){
                const { type, value } = nNode;
                if (type === 'function' && isUrlFunc.test(value)) {
                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);
                    if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {
                        if (needIgnore) {
                            // eslint-disable-next-line no-undefined
                            needIgnore = undefined;
                        }
                        continue;
                    }
                    const { nodes } = nNode;
                    const isStringValue = nodes.length !== 0 && nodes[0].type === 'string';
                    let url = isStringValue ? nodes[0].value : _postcssvalueparser.default.stringify(nodes);
                    url = (0, _utils.normalizeUrl)(url, isStringValue);
                    // Do not traverse inside `url`
                    if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {
                        // eslint-disable-next-line consistent-return
                        return false;
                    }
                    const queryParts = url.split('!');
                    let prefix;
                    if (queryParts.length > 1) {
                        url = queryParts.pop();
                        prefix = queryParts.join('!');
                    }
                    parsedURLs.push({
                        declaration,
                        parsed,
                        node: getNodeFromUrlFunc(nNode),
                        prefix,
                        url,
                        needQuotes: false
                    });
                } else if (type === 'string') {
                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);
                    if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {
                        if (needIgnore) {
                            // eslint-disable-next-line no-undefined
                            needIgnore = undefined;
                        }
                        continue;
                    }
                    let url = (0, _utils.normalizeUrl)(value, true);
                    // Do not traverse inside `url`
                    if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {
                        // eslint-disable-next-line consistent-return
                        return false;
                    }
                    const queryParts = url.split('!');
                    let prefix;
                    if (queryParts.length > 1) {
                        url = queryParts.pop();
                        prefix = queryParts.join('!');
                    }
                    parsedURLs.push({
                        declaration,
                        parsed,
                        node: nNode,
                        prefix,
                        url,
                        needQuotes: true
                    });
                }
            }
            // Do not traverse inside `image-set`
            // eslint-disable-next-line consistent-return
            return false;
        }
    });
    // eslint-disable-next-line consistent-return
    return parsedURLs;
}
const plugin = (options = {})=>{
    return {
        postcssPlugin: 'postcss-url-parser',
        prepare (result) {
            const parsedDeclarations = [];
            return {
                Declaration (declaration) {
                    const { isSupportDataURLInNewURL } = options;
                    const parsedURL = parseDeclaration(declaration, 'value', result, isSupportDataURLInNewURL);
                    if (!parsedURL) {
                        return;
                    }
                    parsedDeclarations.push(...parsedURL);
                },
                async OnceExit () {
                    if (parsedDeclarations.length === 0) {
                        return;
                    }
                    const resolvedDeclarations = await Promise.all(parsedDeclarations.map(async (parsedDeclaration)=>{
                        const { url } = parsedDeclaration;
                        if (options.filter) {
                            const needKeep = await options.filter(url);
                            if (!needKeep) {
                                // eslint-disable-next-line consistent-return
                                return;
                            }
                        }
                        if ((0, _utils.isDataUrl)(url)) {
                            // eslint-disable-next-line consistent-return
                            return parsedDeclaration;
                        }
                        const [pathname, query, hashOrQuery] = url.split(/(\?)?#/, 3);
                        let hash = query ? '?' : '';
                        hash += hashOrQuery ? `#${hashOrQuery}` : '';
                        const { needToResolveURL, rootContext } = options;
                        const request = (0, _utils.requestify)(pathname, rootContext, needToResolveURL);
                        if (!needToResolveURL) {
                            // eslint-disable-next-line consistent-return
                            return {
                                ...parsedDeclaration,
                                url: request,
                                hash
                            };
                        }
                        const { resolver, context } = options;
                        const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [
                            ...new Set([
                                request,
                                url
                            ])
                        ]);
                        if (!resolvedUrl) {
                            // eslint-disable-next-line consistent-return
                            return;
                        }
                        // eslint-disable-next-line consistent-return
                        return {
                            ...parsedDeclaration,
                            url: resolvedUrl,
                            hash
                        };
                    }));
                    const urlToNameMap = new Map();
                    const urlToReplacementMap = new Map();
                    let hasUrlImportHelper = false;
                    for(let index = 0; index <= resolvedDeclarations.length - 1; index++){
                        const item = resolvedDeclarations[index];
                        if (!item) {
                            continue;
                        }
                        if (!hasUrlImportHelper) {
                            options.imports.push({
                                type: 'get_url_import',
                                importName: '___CSS_LOADER_GET_URL_IMPORT___',
                                url: options.urlHandler("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js [app-rsc] (ecmascript)"),
                                index: -1
                            });
                            hasUrlImportHelper = true;
                        }
                        const { url, prefix } = item;
                        const newUrl = prefix ? `${prefix}!${url}` : url;
                        let importName = urlToNameMap.get(newUrl);
                        if (!importName) {
                            importName = `___CSS_LOADER_URL_IMPORT_${urlToNameMap.size}___`;
                            urlToNameMap.set(newUrl, importName);
                            options.imports.push({
                                type: 'url',
                                importName,
                                url: options.needToResolveURL ? options.urlHandler(newUrl) : JSON.stringify(newUrl),
                                index
                            });
                        }
                        const { hash, needQuotes } = item;
                        const replacementKey = JSON.stringify({
                            newUrl,
                            hash,
                            needQuotes
                        });
                        let replacementName = urlToReplacementMap.get(replacementKey);
                        if (!replacementName) {
                            replacementName = `___CSS_LOADER_URL_REPLACEMENT_${urlToReplacementMap.size}___`;
                            urlToReplacementMap.set(replacementKey, replacementName);
                            options.replacements.push({
                                replacementName,
                                importName,
                                hash,
                                needQuotes
                            });
                        }
                        // eslint-disable-next-line no-param-reassign
                        item.node.type = 'word';
                        // eslint-disable-next-line no-param-reassign
                        item.node.value = replacementName;
                        // eslint-disable-next-line no-param-reassign
                        item.declaration.value = item.parsed.toString();
                    }
                }
            };
        }
    };
};
plugin.postcss = true;
const _default = plugin; //# sourceMappingURL=postcss-url-parser.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    icssParser: null,
    importParser: null,
    urlParser: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    icssParser: function() {
        return _postcssicssparser.default;
    },
    importParser: function() {
        return _postcssimportparser.default;
    },
    urlParser: function() {
        return _postcssurlparser.default;
    }
});
const _postcssimportparser = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-import-parser.js [app-rsc] (ecmascript)"));
const _postcssicssparser = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-icss-parser.js [app-rsc] (ecmascript)"));
const _postcssurlparser = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/postcss-url-parser.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ // css base code, injected by the css-loader
// eslint-disable-next-line func-names
"use strict";
module.exports = function(useSourceMap) {
    var list = [] // return the list of modules as css string
    ;
    list.toString = function toString() {
        return this.map(function(item) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            var content = cssWithMappingToString(item, useSourceMap);
            if (item[2]) {
                return '@media '.concat(item[2], ' {').concat(content, '}');
            }
            return content;
        }).join('');
    } // import a list of modules into the list
    ;
    // eslint-disable-next-line func-names
    // @ts-expect-error TODO: fix type
    list.i = function(modules, mediaQuery, dedupe) {
        if (typeof modules === 'string') {
            // eslint-disable-next-line no-param-reassign
            modules = [
                [
                    null,
                    modules,
                    ''
                ]
            ];
        }
        var alreadyImportedModules = {};
        if (dedupe) {
            for(var i = 0; i < this.length; i++){
                // eslint-disable-next-line prefer-destructuring
                var id = this[i][0];
                if (id != null) {
                    alreadyImportedModules[id] = true;
                }
            }
        }
        for(var _i = 0; _i < modules.length; _i++){
            var item = [].concat(modules[_i]);
            if (dedupe && alreadyImportedModules[item[0]]) {
                continue;
            }
            if (mediaQuery) {
                if (!item[2]) {
                    item[2] = mediaQuery;
                } else {
                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);
                }
            }
            list.push(item);
        }
    };
    return list;
};
function cssWithMappingToString(item, useSourceMap) {
    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring
    ;
    var cssMapping = item[3];
    if (!cssMapping) {
        return content;
    }
    if (useSourceMap && typeof btoa === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        var sourceMapping = toComment(cssMapping);
        var sourceURLs = cssMapping.sources.map(function(source) {
            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');
        });
        return [
            content
        ].concat(sourceURLs).concat([
            sourceMapping
        ]).join('\n');
    }
    return [
        content
    ].join('\n');
} // Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);
    return '/*# '.concat(data, ' */');
} //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return loader;
    }
});
const _CssSyntaxError = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/CssSyntaxError.js [app-rsc] (ecmascript)"));
const _Warning = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/Warning.js [app-rsc] (ecmascript)"));
const _stringifyrequest = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/stringify-request.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const moduleRegExp = /\.module\.\w+$/i;
function getModulesOptions(rawOptions, loaderContext) {
    const { resourcePath } = loaderContext;
    if (typeof rawOptions.modules === 'undefined') {
        const isModules = moduleRegExp.test(resourcePath);
        if (!isModules) {
            return false;
        }
    } else if (typeof rawOptions.modules === 'boolean' && rawOptions.modules === false) {
        return false;
    }
    let modulesOptions = {
        compileType: rawOptions.icss ? 'icss' : 'module',
        auto: true,
        mode: 'local',
        exportGlobals: false,
        localIdentName: '[hash:base64]',
        localIdentContext: loaderContext.rootContext,
        localIdentHashPrefix: '',
        // eslint-disable-next-line no-undefined
        localIdentRegExp: undefined,
        namedExport: false,
        exportLocalsConvention: 'asIs',
        exportOnlyLocals: false
    };
    if (typeof rawOptions.modules === 'boolean' || typeof rawOptions.modules === 'string') {
        modulesOptions.mode = typeof rawOptions.modules === 'string' ? rawOptions.modules : 'local';
    } else {
        if (rawOptions.modules) {
            if (typeof rawOptions.modules.auto === 'boolean') {
                const isModules = rawOptions.modules.auto && moduleRegExp.test(resourcePath);
                if (!isModules) {
                    return false;
                }
            } else if (rawOptions.modules.auto instanceof RegExp) {
                const isModules = rawOptions.modules.auto.test(resourcePath);
                if (!isModules) {
                    return false;
                }
            } else if (typeof rawOptions.modules.auto === 'function') {
                const isModule = rawOptions.modules.auto(resourcePath);
                if (!isModule) {
                    return false;
                }
            }
            if (rawOptions.modules.namedExport === true && typeof rawOptions.modules.exportLocalsConvention === 'undefined') {
                modulesOptions.exportLocalsConvention = 'camelCaseOnly';
            }
        }
        modulesOptions = {
            ...modulesOptions,
            ...rawOptions.modules || {}
        };
    }
    if (typeof modulesOptions.mode === 'function') {
        modulesOptions.mode = modulesOptions.mode(loaderContext.resourcePath);
    }
    if (modulesOptions.namedExport === true) {
        if (rawOptions.esModule === false) {
            throw Object.defineProperty(new Error('The "modules.namedExport" option requires the "esModules" option to be enabled'), "__NEXT_ERROR_CODE", {
                value: "E103",
                enumerable: false,
                configurable: true
            });
        }
        if (modulesOptions.exportLocalsConvention !== 'camelCaseOnly') {
            throw Object.defineProperty(new Error('The "modules.namedExport" option requires the "modules.exportLocalsConvention" option to be "camelCaseOnly"'), "__NEXT_ERROR_CODE", {
                value: "E23",
                enumerable: false,
                configurable: true
            });
        }
    }
    return modulesOptions;
}
function normalizeOptions(rawOptions, loaderContext) {
    if (rawOptions.icss) {
        loaderContext.emitWarning(Object.defineProperty(new Error('The "icss" option is deprecated, use "modules.compileType: "icss"" instead'), "__NEXT_ERROR_CODE", {
            value: "E476",
            enumerable: false,
            configurable: true
        }));
    }
    const modulesOptions = getModulesOptions(rawOptions, loaderContext);
    return {
        url: typeof rawOptions.url === 'undefined' ? true : rawOptions.url,
        import: typeof rawOptions.import === 'undefined' ? true : rawOptions.import,
        modules: modulesOptions,
        // TODO remove in the next major release
        icss: typeof rawOptions.icss === 'undefined' ? false : rawOptions.icss,
        sourceMap: typeof rawOptions.sourceMap === 'boolean' ? rawOptions.sourceMap : loaderContext.sourceMap,
        importLoaders: typeof rawOptions.importLoaders === 'string' ? parseInt(rawOptions.importLoaders, 10) : rawOptions.importLoaders,
        esModule: typeof rawOptions.esModule === 'undefined' ? true : rawOptions.esModule,
        fontLoader: rawOptions.fontLoader
    };
}
async function loader(content, map, meta) {
    const rawOptions = this.getOptions();
    const plugins = [];
    const callback = this.async();
    const loaderSpan = this.currentTraceSpan.traceChild('css-loader');
    loaderSpan.traceAsyncFn(async ()=>{
        let options;
        try {
            options = normalizeOptions(rawOptions, this);
        } catch (error) {
            throw error;
        }
        const { postcss } = await rawOptions.postcss();
        const { shouldUseModulesPlugins, shouldUseImportPlugin, shouldUseURLPlugin, shouldUseIcssPlugin, getPreRequester, getExportCode, getFilter, getImportCode, getModuleCode, getModulesPlugins, normalizeSourceMap, sort } = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
        const { icssParser, importParser, urlParser } = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/plugins/index.js [app-rsc] (ecmascript)");
        const replacements = [];
        // if it's a font loader next-font-loader will have exports that should be exported as is
        const exports1 = options.fontLoader ? meta.exports : [];
        if (shouldUseModulesPlugins(options)) {
            plugins.push(...getModulesPlugins(options, this, meta));
        }
        const importPluginImports = [];
        const importPluginApi = [];
        if (shouldUseImportPlugin(options)) {
            const resolver = this.getResolve({
                conditionNames: [
                    'style'
                ],
                extensions: [
                    '.css'
                ],
                mainFields: [
                    'css',
                    'style',
                    'main',
                    '...'
                ],
                mainFiles: [
                    'index',
                    '...'
                ],
                restrictions: [
                    /\.css$/i
                ]
            });
            plugins.push(importParser({
                imports: importPluginImports,
                api: importPluginApi,
                context: this.context,
                rootContext: this.rootContext,
                filter: getFilter(options.import, this.resourcePath),
                resolver,
                urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, getPreRequester(this)(options.importLoaders) + url)
            }));
        }
        const urlPluginImports = [];
        if (shouldUseURLPlugin(options)) {
            const urlResolver = this.getResolve({
                conditionNames: [
                    'asset'
                ],
                mainFields: [
                    'asset'
                ],
                mainFiles: [],
                extensions: []
            });
            plugins.push(urlParser({
                imports: urlPluginImports,
                replacements,
                context: this.context,
                rootContext: this.rootContext,
                filter: getFilter(options.url, this.resourcePath),
                resolver: urlResolver,
                urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, url)
            }));
        }
        const icssPluginImports = [];
        const icssPluginApi = [];
        if (shouldUseIcssPlugin(options)) {
            const icssResolver = this.getResolve({
                conditionNames: [
                    'style'
                ],
                extensions: [],
                mainFields: [
                    'css',
                    'style',
                    'main',
                    '...'
                ],
                mainFiles: [
                    'index',
                    '...'
                ]
            });
            plugins.push(icssParser({
                imports: icssPluginImports,
                api: icssPluginApi,
                replacements,
                exports: exports1,
                context: this.context,
                rootContext: this.rootContext,
                resolver: icssResolver,
                urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, getPreRequester(this)(options.importLoaders) + url)
            }));
        }
        // Reuse CSS AST (PostCSS AST e.g 'postcss-loader') to avoid reparsing
        if (meta) {
            const { ast } = meta;
            if (ast && ast.type === 'postcss') {
                // eslint-disable-next-line no-param-reassign
                content = ast.root;
                loaderSpan.setAttribute('astUsed', 'true');
            }
        }
        const { resourcePath } = this;
        let result;
        try {
            result = await postcss(plugins).process(content, {
                from: resourcePath,
                to: resourcePath,
                map: options.sourceMap ? {
                    prev: map ? normalizeSourceMap(map, resourcePath) : null,
                    inline: false,
                    annotation: false
                } : false
            });
        } catch (error) {
            if (error.file) {
                this.addDependency(error.file);
            }
            throw error.name === 'CssSyntaxError' ? Object.defineProperty(new _CssSyntaxError.default(error), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            }) : error;
        }
        for (const warning of result.warnings()){
            this.emitWarning(Object.defineProperty(new _Warning.default(warning), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            }));
        }
        const imports = [
            ...icssPluginImports.sort(sort),
            ...importPluginImports.sort(sort),
            ...urlPluginImports.sort(sort)
        ];
        const api = [
            ...importPluginApi.sort(sort),
            ...icssPluginApi.sort(sort)
        ];
        if (options.modules.exportOnlyLocals !== true) {
            imports.unshift({
                importName: '___CSS_LOADER_API_IMPORT___',
                url: (0, _stringifyrequest.stringifyRequest)(this, "[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js [app-rsc] (ecmascript)")
            });
        }
        const importCode = getImportCode(imports, options);
        const moduleCode = getModuleCode(result, api, replacements, options, this);
        const exportCode = getExportCode(exports1, replacements, options);
        return `${importCode}${moduleCode}${exportCode}`;
    }).then((code)=>{
        callback(null, code);
    }, (err)=>{
        callback(err);
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/Error.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * **PostCSS Syntax Error**
 *
 * Loader wrapper for postcss syntax errors
 *
 * @class SyntaxError
 * @extends Error
 *
 * @param {Object} err CssSyntaxError
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return PostCSSSyntaxError;
    }
});
class PostCSSSyntaxError extends Error {
    constructor(error){
        super(error);
        const { line, column, reason, plugin, file } = error;
        this.name = 'SyntaxError';
        this.message = `${this.name}\n\n`;
        if (typeof line !== 'undefined') {
            this.message += `(${line}:${column}) `;
        }
        this.message += plugin ? `${plugin}: ` : '';
        this.message += file ? `${file} ` : '<css input> ';
        this.message += reason;
        const code = error.showSourceCode();
        if (code) {
            this.message += `\n\n${code}\n`;
        }
        this.stack = false;
    }
} //# sourceMappingURL=Error.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    normalizeSourceMap: null,
    normalizeSourceMapAfterPostcss: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeSourceMap: function() {
        return normalizeSourceMap;
    },
    normalizeSourceMapAfterPostcss: function() {
        return normalizeSourceMapAfterPostcss;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\]|^\\\\/i;
const ABSOLUTE_SCHEME = /^[a-z0-9+\-.]+:/i;
function getURLType(source) {
    if (source[0] === '/') {
        if (source[1] === '/') {
            return 'scheme-relative';
        }
        return 'path-absolute';
    }
    if (IS_NATIVE_WIN32_PATH.test(source)) {
        return 'path-absolute';
    }
    return ABSOLUTE_SCHEME.test(source) ? 'absolute' : 'path-relative';
}
function normalizeSourceMap(map, resourceContext) {
    let newMap = map;
    // Some loader emit source map as string
    // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.
    if (typeof newMap === 'string') {
        newMap = JSON.parse(newMap);
    }
    delete newMap.file;
    const { sourceRoot } = newMap;
    delete newMap.sourceRoot;
    if (newMap.sources) {
        newMap.sources = newMap.sources.map((source)=>{
            const sourceType = getURLType(source);
            // Do no touch `scheme-relative` and `absolute` URLs
            if (sourceType === 'path-relative' || sourceType === 'path-absolute') {
                const absoluteSource = sourceType === 'path-relative' && sourceRoot ? _path.default.resolve(sourceRoot, _path.default.normalize(source)) : _path.default.normalize(source);
                return _path.default.relative(resourceContext, absoluteSource);
            }
            return source;
        });
    }
    return newMap;
}
function normalizeSourceMapAfterPostcss(map, resourceContext) {
    const newMap = map;
    // result.map.file is an optional property that provides the output filename.
    // Since we don't know the final filename in the webpack build chain yet, it makes no sense to have it.
    // eslint-disable-next-line no-param-reassign
    delete newMap.file;
    // eslint-disable-next-line no-param-reassign
    newMap.sourceRoot = '';
    // eslint-disable-next-line no-param-reassign
    newMap.sources = newMap.sources.map((source)=>{
        if (source.startsWith('<')) {
            return source;
        }
        const sourceType = getURLType(source);
        // Do no touch `scheme-relative`, `path-absolute` and `absolute` types
        if (sourceType === 'path-relative') {
            return _path.default.resolve(resourceContext, source);
        }
        return source;
    });
    return newMap;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * **PostCSS Loader**
 *
 * Loads && processes CSS with [PostCSS](https://github.com/postcss/postcss)
 */ "default", {
    enumerable: true,
    get: function() {
        return loader;
    }
});
const _Warning = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/Warning.js [app-rsc] (ecmascript)"));
const _Error = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/Error.js [app-rsc] (ecmascript)"));
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function loader(/** Source */ content, /** Source Map */ sourceMap, meta) {
    const loaderSpan = this.currentTraceSpan.traceChild('postcss-loader');
    const callback = this.async();
    loaderSpan.traceAsyncFn(async ()=>{
        const options = this.getOptions();
        const file = this.resourcePath;
        const useSourceMap = typeof options.sourceMap !== 'undefined' ? options.sourceMap : this.sourceMap;
        const processOptions = {
            from: file,
            to: file
        };
        if (useSourceMap) {
            processOptions.map = {
                inline: false,
                annotation: false,
                ...processOptions.map
            };
        }
        if (sourceMap && processOptions.map) {
            processOptions.map.prev = loaderSpan.traceChild('normalize-source-map').traceFn(()=>(0, _utils.normalizeSourceMap)(sourceMap, this.context));
        }
        let root;
        // Reuse PostCSS AST from other loaders
        if (meta && meta.ast && meta.ast.type === 'postcss') {
            ;
            ({ root } = meta.ast);
            loaderSpan.setAttribute('astUsed', 'true');
        }
        // Initializes postcss with plugins
        const { postcssWithPlugins } = await options.postcss();
        let result;
        try {
            result = await loaderSpan.traceChild('postcss-process').traceAsyncFn(()=>postcssWithPlugins.process(root || content, processOptions));
        } catch (error) {
            if (error.file) {
                this.addDependency(error.file);
            }
            if (error.name === 'CssSyntaxError') {
                throw Object.defineProperty(new _Error.default(error), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            }
            throw error;
        }
        for (const warning of result.warnings()){
            this.emitWarning(Object.defineProperty(new _Warning.default(warning), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            }));
        }
        for (const message of result.messages){
            // eslint-disable-next-line default-case
            switch(message.type){
                case 'dependency':
                    this.addDependency(message.file);
                    break;
                case 'build-dependency':
                    this.addBuildDependency(message.file);
                    break;
                case 'missing-dependency':
                    this.addMissingDependency(message.file);
                    break;
                case 'context-dependency':
                    this.addContextDependency(message.file);
                    break;
                case 'dir-dependency':
                    this.addContextDependency(message.dir);
                    break;
                case 'asset':
                    if (message.content && message.file) {
                        this.emitFile(message.file, message.content, message.sourceMap, message.info);
                    }
            }
        }
        // eslint-disable-next-line no-undefined
        let map = result.map ? result.map.toJSON() : undefined;
        if (map && useSourceMap) {
            map = (0, _utils.normalizeSourceMapAfterPostcss)(map, this.context);
        }
        const ast = {
            type: 'postcss',
            version: result.processor.version,
            root: result.root
        };
        return [
            result.css,
            map,
            {
                ast
            }
        ];
    }).then(([css, map, { ast }])=>{
        callback == null ? void 0 : callback(null, css, map, {
            ast
        });
    }, (err)=>{
        callback == null ? void 0 : callback(err);
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getTargets", {
    enumerable: true,
    get: function() {
        return getTargets;
    }
});
let targetsCache = {};
/**
 * Convert a version number to a single 24-bit number
 *
 * https://github.com/lumeland/lume/blob/4cc75599006df423a14befc06d3ed8493c645b09/plugins/lightningcss.ts#L160
 */ function version(major, minor = 0, patch = 0) {
    return major << 16 | minor << 8 | patch;
}
function parseVersion(v) {
    return v.split('.').reduce((acc, val)=>{
        if (!acc) {
            return null;
        }
        const parsed = parseInt(val, 10);
        if (isNaN(parsed)) {
            return null;
        }
        acc.push(parsed);
        return acc;
    }, []);
}
function browserslistToTargets(targets) {
    return targets.reduce((acc, value)=>{
        const [name, v] = value.split(' ');
        const parsedVersion = parseVersion(v);
        if (!parsedVersion) {
            return acc;
        }
        const versionDigit = version(parsedVersion[0], parsedVersion[1], parsedVersion[2]);
        if (name === 'and_qq' || name === 'and_uc' || name === 'baidu' || name === 'bb' || name === 'kaios' || name === 'op_mini') {
            return acc;
        }
        if (acc[name] == null || versionDigit < acc[name]) {
            acc[name] = versionDigit;
        }
        return acc;
    }, {});
}
const getTargets = (opts)=>{
    const cache = targetsCache[opts.key];
    if (cache) {
        return cache;
    }
    const result = browserslistToTargets(opts.targets ?? []);
    return targetsCache[opts.key] = result;
}; //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/codegen.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getExportCode: null,
    getImportCode: null,
    getModuleCode: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getExportCode: function() {
        return getExportCode;
    },
    getImportCode: function() {
        return getImportCode;
    },
    getModuleCode: function() {
        return getModuleCode;
    }
});
const _camelcase = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/camelcase.js [app-rsc] (ecmascript)"));
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function getImportCode(imports, options) {
    let code = '';
    for (const item of imports){
        const { importName, url, icss } = item;
        if (options.esModule) {
            if (icss && options.modules.namedExport) {
                code += `import ${options.modules.exportOnlyLocals ? '' : `${importName}, `}* as ${importName}_NAMED___ from ${url};\n`;
            } else {
                code += `import ${importName} from ${url};\n`;
            }
        } else {
            code += `var ${importName} = require(${url});\n`;
        }
    }
    return code ? `// Imports\n${code}` : '';
}
function getModuleCode(result, api, replacements, options, loaderContext) {
    if (options.modules.exportOnlyLocals === true) {
        return '';
    }
    const sourceMapValue = options.sourceMap ? `,${(0, _utils.normalizeSourceMapForRuntime)(result.map, loaderContext)}` : '';
    let code = JSON.stringify(result.css);
    let beforeCode = `var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(${options.sourceMap});\n`;
    for (const item of api){
        const { url, media, dedupe } = item;
        beforeCode += url ? `___CSS_LOADER_EXPORT___.push([module.id, ${JSON.stringify(`@import url(${url});`)}${media ? `, ${JSON.stringify(media)}` : ''}]);\n` : `___CSS_LOADER_EXPORT___.i(${item.importName}${media ? `, ${JSON.stringify(media)}` : dedupe ? ', ""' : ''}${dedupe ? ', true' : ''});\n`;
    }
    for (const item of replacements){
        const { replacementName, importName, localName } = item;
        if (localName) {
            code = code.replace(new RegExp(replacementName, 'g'), ()=>options.modules.namedExport ? `" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + "` : `" + ${importName}.locals[${JSON.stringify(localName)}] + "`);
        } else {
            const { hash, needQuotes } = item;
            const getUrlOptions = [
                ...hash ? [
                    `hash: ${JSON.stringify(hash)}`
                ] : [],
                ...needQuotes ? 'needQuotes: true' : []
            ];
            const preparedOptions = getUrlOptions.length > 0 ? `, { ${getUrlOptions.join(', ')} }` : '';
            beforeCode += `var ${replacementName} = ___CSS_LOADER_GET_URL_IMPORT___(${importName}${preparedOptions});\n`;
            code = code.replace(new RegExp(replacementName, 'g'), ()=>`" + ${replacementName} + "`);
        }
    }
    return `${beforeCode}// Module\n___CSS_LOADER_EXPORT___.push([module.id, ${code}, ""${sourceMapValue}]);\n`;
}
function getExportCode(exports1, replacements, options) {
    let code = '// Exports\n';
    let localsCode = '';
    const addExportToLocalsCode = (name, value)=>{
        if (options.modules.namedExport) {
            localsCode += `export const ${(0, _camelcase.default)(name)} = ${JSON.stringify(value)};\n`;
        } else {
            if (localsCode) {
                localsCode += `,\n`;
            }
            localsCode += `\t${JSON.stringify(name)}: ${JSON.stringify(value)}`;
        }
    };
    for (const { name, value } of exports1){
        switch(options.modules.exportLocalsConvention){
            case 'camelCase':
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = (0, _camelcase.default)(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case 'camelCaseOnly':
                {
                    addExportToLocalsCode((0, _camelcase.default)(name), value);
                    break;
                }
            case 'dashes':
                {
                    addExportToLocalsCode(name, value);
                    const modifiedName = (0, _utils.dashesCamelCase)(name);
                    if (modifiedName !== name) {
                        addExportToLocalsCode(modifiedName, value);
                    }
                    break;
                }
            case 'dashesOnly':
                {
                    addExportToLocalsCode((0, _utils.dashesCamelCase)(name), value);
                    break;
                }
            case 'asIs':
            default:
                addExportToLocalsCode(name, value);
                break;
        }
    }
    for (const item of replacements){
        const { replacementName, localName } = item;
        if (localName) {
            const { importName } = item;
            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>{
                if (options.modules.namedExport) {
                    return `" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + "`;
                } else if (options.modules.exportOnlyLocals) {
                    return `" + ${importName}[${JSON.stringify(localName)}] + "`;
                }
                return `" + ${importName}.locals[${JSON.stringify(localName)}] + "`;
            });
        } else {
            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>`" + ${replacementName} + "`);
        }
    }
    if (options.modules.exportOnlyLocals) {
        code += options.modules.namedExport ? localsCode : `${options.esModule ? 'export default' : 'module.exports ='} {\n${localsCode}\n};\n`;
        return code;
    }
    if (localsCode) {
        code += options.modules.namedExport ? localsCode : `___CSS_LOADER_EXPORT___.locals = {\n${localsCode}\n};\n`;
    }
    code += `${options.esModule ? 'export default' : 'module.exports ='} ___CSS_LOADER_EXPORT___;\n`;
    return code;
} //# sourceMappingURL=codegen.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/interface.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ECacheKey", {
    enumerable: true,
    get: function() {
        return ECacheKey;
    }
});
var ECacheKey = /*#__PURE__*/ function(ECacheKey) {
    ECacheKey["loader"] = "loader";
    ECacheKey["minify"] = "minify";
    return ECacheKey;
}({}); //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/loader.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    LightningCssLoader: null,
    raw: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LightningCssLoader: function() {
        return LightningCssLoader;
    },
    raw: function() {
        return raw;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/utils.js [app-rsc] (ecmascript)");
const _codegen = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/codegen.js [app-rsc] (ecmascript)");
const _utils1 = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js [app-rsc] (ecmascript)");
const _stringifyrequest = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/stringify-request.js [app-rsc] (ecmascript)");
const _interface = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/interface.js [app-rsc] (ecmascript)");
const encoder = new TextEncoder();
function createUrlAndImportVisitor(visitorOptions, apis, imports, replacements, replacedUrls, replacedImportUrls) {
    const importUrlToNameMap = new Map();
    let hasUrlImportHelper = false;
    const urlToNameMap = new Map();
    const urlToReplacementMap = new Map();
    let urlIndex = -1;
    let importUrlIndex = -1;
    function handleUrl(u) {
        let url = u.url;
        const needKeep = visitorOptions.urlFilter(url);
        if (!needKeep) {
            return u;
        }
        if ((0, _utils1.isDataUrl)(url)) {
            return u;
        }
        urlIndex++;
        replacedUrls.set(urlIndex, url);
        url = `__NEXT_LIGHTNINGCSS_LOADER_URL_REPLACE_${urlIndex}__`;
        const [, query, hashOrQuery] = url.split(/(\?)?#/, 3);
        const queryParts = url.split('!');
        let prefix;
        if (queryParts.length > 1) {
            url = queryParts.pop();
            prefix = queryParts.join('!');
        }
        let hash = query ? '?' : '';
        hash += hashOrQuery ? `#${hashOrQuery}` : '';
        if (!hasUrlImportHelper) {
            imports.push({
                type: 'get_url_import',
                importName: '___CSS_LOADER_GET_URL_IMPORT___',
                url: JSON.stringify("[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/getUrl.js [app-rsc] (ecmascript)"),
                index: -1
            });
            hasUrlImportHelper = true;
        }
        const newUrl = prefix ? `${prefix}!${url}` : url;
        let importName = urlToNameMap.get(newUrl);
        if (!importName) {
            importName = `___CSS_LOADER_URL_IMPORT_${urlToNameMap.size}___`;
            urlToNameMap.set(newUrl, importName);
            imports.push({
                type: 'url',
                importName,
                url: JSON.stringify(newUrl),
                index: urlIndex
            });
        }
        // This should be true for string-urls in image-set
        const needQuotes = false;
        const replacementKey = JSON.stringify({
            newUrl,
            hash,
            needQuotes
        });
        let replacementName = urlToReplacementMap.get(replacementKey);
        if (!replacementName) {
            replacementName = `___CSS_LOADER_URL_REPLACEMENT_${urlToReplacementMap.size}___`;
            urlToReplacementMap.set(replacementKey, replacementName);
            replacements.push({
                replacementName,
                importName,
                hash,
                needQuotes
            });
        }
        return {
            loc: u.loc,
            url: replacementName
        };
    }
    return {
        Rule: {
            import (node) {
                if (visitorOptions.importFilter) {
                    const needKeep = visitorOptions.importFilter(node.value.url, node.value.media);
                    if (!needKeep) {
                        return node;
                    }
                }
                let url = node.value.url;
                importUrlIndex++;
                replacedImportUrls.set(importUrlIndex, url);
                url = `__NEXT_LIGHTNINGCSS_LOADER_IMPORT_URL_REPLACE_${importUrlIndex}__`;
                // TODO: Use identical logic as valueParser.stringify()
                const media = node.value.media.mediaQueries.length ? JSON.stringify(node.value.media.mediaQueries) : undefined;
                const isRequestable = (0, _utils1.isUrlRequestable)(url);
                let prefix;
                if (isRequestable) {
                    const queryParts = url.split('!');
                    if (queryParts.length > 1) {
                        url = queryParts.pop();
                        prefix = queryParts.join('!');
                    }
                }
                if (!isRequestable) {
                    apis.push({
                        url,
                        media
                    });
                    // Bug of lightningcss
                    return {
                        type: 'ignored',
                        value: ''
                    };
                }
                const newUrl = prefix ? `${prefix}!${url}` : url;
                let importName = importUrlToNameMap.get(newUrl);
                if (!importName) {
                    importName = `___CSS_LOADER_AT_RULE_IMPORT_${importUrlToNameMap.size}___`;
                    importUrlToNameMap.set(newUrl, importName);
                    const importUrl = visitorOptions.urlHandler(newUrl);
                    imports.push({
                        type: 'rule_import',
                        importName,
                        url: importUrl
                    });
                }
                apis.push({
                    importName,
                    media
                });
                // Bug of lightningcss
                return {
                    type: 'ignored',
                    value: ''
                };
            }
        },
        Url (node) {
            return handleUrl(node);
        }
    };
}
function createIcssVisitor({ apis, imports, replacements, replacedUrls, urlHandler }) {
    let index = -1;
    let replacementIndex = -1;
    return {
        Declaration: {
            composes (node) {
                if (node.property === 'unparsed') {
                    return;
                }
                const specifier = node.value.from;
                if ((specifier == null ? void 0 : specifier.type) !== 'file') {
                    return;
                }
                let url = specifier.value;
                if (!url) {
                    return;
                }
                index++;
                replacedUrls.set(index, url);
                url = `__NEXT_LIGHTNINGCSS_LOADER_ICSS_URL_REPLACE_${index}__`;
                const importName = `___CSS_LOADER_ICSS_IMPORT_${imports.length}___`;
                imports.push({
                    type: 'icss_import',
                    importName,
                    icss: true,
                    url: urlHandler(url),
                    index
                });
                apis.push({
                    importName,
                    dedupe: true,
                    index
                });
                const newNames = [];
                for (const localName of node.value.names){
                    replacementIndex++;
                    const replacementName = `___CSS_LOADER_ICSS_IMPORT_${index}_REPLACEMENT_${replacementIndex}___`;
                    replacements.push({
                        replacementName,
                        importName,
                        localName
                    });
                    newNames.push(replacementName);
                }
                return {
                    property: 'composes',
                    value: {
                        loc: node.value.loc,
                        names: newNames,
                        from: specifier
                    }
                };
            }
        }
    };
}
const LOADER_NAME = `lightningcss-loader`;
async function LightningCssLoader(source, prevMap) {
    var _options_modules;
    const done = this.async();
    const options = this.getOptions();
    const { implementation, targets: userTargets, ...opts } = options;
    options.modules ??= {};
    if (implementation && typeof implementation.transformCss !== 'function') {
        done(Object.defineProperty(new TypeError(`[${LOADER_NAME}]: options.implementation.transformCss must be an 'lightningcss' transform function. Received ${typeof implementation.transformCss}`), "__NEXT_ERROR_CODE", {
            value: "E560",
            enumerable: false,
            configurable: true
        }));
        return;
    }
    if (options.postcss) {
        var _postcssWithPlugins_plugins;
        const { postcssWithPlugins } = await options.postcss();
        if ((postcssWithPlugins == null ? void 0 : (_postcssWithPlugins_plugins = postcssWithPlugins.plugins) == null ? void 0 : _postcssWithPlugins_plugins.length) > 0) {
            throw Object.defineProperty(new Error(`[${LOADER_NAME}]: experimental.useLightningcss does not work with postcss plugins. Please remove 'useLightningcss: true' from your configuration.`), "__NEXT_ERROR_CODE", {
                value: "E519",
                enumerable: false,
                configurable: true
            });
        }
    }
    const exports1 = [];
    const imports = [];
    const icssImports = [];
    const apis = [];
    const replacements = [];
    if (((_options_modules = options.modules) == null ? void 0 : _options_modules.exportOnlyLocals) !== true) {
        imports.unshift({
            type: 'api_import',
            importName: '___CSS_LOADER_API_IMPORT___',
            url: (0, _stringifyrequest.stringifyRequest)(this, "[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js [app-rsc] (ecmascript)")
        });
    }
    const { loadBindings } = __turbopack_context__.r("[project]/node_modules/next/dist/build/swc/index.js [app-rsc] (ecmascript)");
    const transform = (implementation == null ? void 0 : implementation.transformCss) ?? (await loadBindings()).css.lightning.transform;
    const replacedUrls = new Map();
    const icssReplacedUrls = new Map();
    const replacedImportUrls = new Map();
    const urlImportVisitor = createUrlAndImportVisitor({
        urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, (0, _utils1.getPreRequester)(this)(options.importLoaders ?? 0) + url),
        urlFilter: (0, _utils1.getFilter)(options.url, this.resourcePath),
        importFilter: (0, _utils1.getFilter)(options.import, this.resourcePath),
        context: this.context
    }, apis, imports, replacements, replacedUrls, replacedImportUrls);
    const icssVisitor = createIcssVisitor({
        apis,
        imports: icssImports,
        replacements,
        replacedUrls: icssReplacedUrls,
        urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, (0, _utils1.getPreRequester)(this)(options.importLoaders) + url)
    });
    // This works by returned visitors are not conflicting.
    // naive workaround for composeVisitors, as we do not directly depends on lightningcss's npm pkg
    // but next-swc provides bindings
    const visitor = {
        ...urlImportVisitor,
        ...icssVisitor
    };
    try {
        const { code, map, exports: moduleExports } = transform({
            ...opts,
            visitor,
            cssModules: options.modules ? {
                pattern: ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : '[name]__[hash]__[local]'
            } : undefined,
            filename: this.resourcePath,
            code: encoder.encode(source),
            sourceMap: this.sourceMap,
            targets: (0, _utils.getTargets)({
                targets: userTargets,
                key: _interface.ECacheKey.loader
            }),
            inputSourceMap: this.sourceMap && prevMap ? JSON.stringify(prevMap) : undefined,
            include: 1
        });
        let cssCodeAsString = code.toString();
        if (moduleExports) {
            for(const name in moduleExports){
                if (Object.prototype.hasOwnProperty.call(moduleExports, name)) {
                    const v = moduleExports[name];
                    let value = v.name;
                    for (const compose of v.composes){
                        value += ` ${compose.name}`;
                    }
                    exports1.push({
                        name,
                        value
                    });
                }
            }
        }
        if (replacedUrls.size !== 0) {
            const urlResolver = this.getResolve({
                conditionNames: [
                    'asset'
                ],
                mainFields: [
                    'asset'
                ],
                mainFiles: [],
                extensions: []
            });
            for (const [index, url] of replacedUrls.entries()){
                const [pathname] = url.split(/(\?)?#/, 3);
                const request = (0, _utils1.requestify)(pathname, this.rootContext);
                const resolvedUrl = await (0, _utils1.resolveRequests)(urlResolver, this.context, [
                    ...new Set([
                        request,
                        url
                    ])
                ]);
                for (const importItem of imports){
                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_URL_REPLACE_${index}__`, resolvedUrl ?? url);
                }
            }
        }
        if (replacedImportUrls.size !== 0) {
            const importResolver = this.getResolve({
                conditionNames: [
                    'style'
                ],
                extensions: [
                    '.css'
                ],
                mainFields: [
                    'css',
                    'style',
                    'main',
                    '...'
                ],
                mainFiles: [
                    'index',
                    '...'
                ],
                restrictions: [
                    /\.css$/i
                ]
            });
            for (const [index, url] of replacedImportUrls.entries()){
                const [pathname] = url.split(/(\?)?#/, 3);
                const request = (0, _utils1.requestify)(pathname, this.rootContext);
                const resolvedUrl = await (0, _utils1.resolveRequests)(importResolver, this.context, [
                    ...new Set([
                        request,
                        url
                    ])
                ]);
                for (const importItem of imports){
                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_IMPORT_URL_REPLACE_${index}__`, resolvedUrl ?? url);
                }
            }
        }
        if (icssReplacedUrls.size !== 0) {
            const icssResolver = this.getResolve({
                conditionNames: [
                    'style'
                ],
                extensions: [],
                mainFields: [
                    'css',
                    'style',
                    'main',
                    '...'
                ],
                mainFiles: [
                    'index',
                    '...'
                ]
            });
            for (const [index, url] of icssReplacedUrls.entries()){
                const [pathname] = url.split(/(\?)?#/, 3);
                const request = (0, _utils1.requestify)(pathname, this.rootContext);
                const resolvedUrl = await (0, _utils1.resolveRequests)(icssResolver, this.context, [
                    ...new Set([
                        url,
                        request
                    ])
                ]);
                for (const importItem of icssImports){
                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_ICSS_URL_REPLACE_${index}__`, resolvedUrl ?? url);
                }
            }
        }
        imports.push(...icssImports);
        const importCode = (0, _codegen.getImportCode)(imports, options);
        const moduleCode = (0, _codegen.getModuleCode)({
            css: cssCodeAsString,
            map
        }, apis, replacements, options, this);
        const exportCode = (0, _codegen.getExportCode)(exports1, replacements, options);
        const esCode = `${importCode}${moduleCode}${exportCode}`;
        done(null, esCode, map && JSON.parse(map.toString()));
    } catch (error) {
        console.error('lightningcss-loader error', error);
        done(error);
    }
}
const raw = true; //# sourceMappingURL=loader.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/minify.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// @ts-ignore
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LightningCssMinifyPlugin", {
    enumerable: true,
    get: function() {
        return LightningCssMinifyPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _webpacksources3 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack-sources3/index.js [app-rsc] (ecmascript)");
const _interface = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/interface.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/utils.js [app-rsc] (ecmascript)");
const _buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const PLUGIN_NAME = 'lightning-css-minify';
const CSS_FILE_REG = /\.css(?:\?.*)?$/i;
class LightningCssMinifyPlugin {
    constructor(opts = {}){
        const { implementation, ...otherOpts } = opts;
        if (implementation && typeof implementation.transformCss !== 'function') {
            throw Object.defineProperty(new TypeError(`[LightningCssMinifyPlugin]: implementation.transformCss must be an 'lightningcss' transform function. Received ${typeof implementation.transformCss}`), "__NEXT_ERROR_CODE", {
                value: "E561",
                enumerable: false,
                configurable: true
            });
        }
        this.transform = implementation == null ? void 0 : implementation.transformCss;
        this.options = otherOpts;
    }
    apply(compiler) {
        const meta = JSON.stringify({
            name: '@next/lightningcss-loader',
            version: '0.0.0',
            options: this.options
        });
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.chunkHash.tap(PLUGIN_NAME, (_, hash)=>hash.update(meta));
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE,
                additionalAssets: true
            }, async ()=>await this.transformAssets(compilation));
            compilation.hooks.statsPrinter.tap(PLUGIN_NAME, (statsPrinter)=>{
                statsPrinter.hooks.print.for('asset.info.minimized') // @ts-ignore
                .tap(PLUGIN_NAME, (minimized, { green, formatFlag })=>{
                    // @ts-ignore
                    return minimized ? green(formatFlag('minimized')) : undefined;
                });
            });
        });
    }
    async transformAssets(compilation) {
        const { options: { devtool } } = compilation.compiler;
        if (!this.transform) {
            const { loadBindings } = __turbopack_context__.r("[project]/node_modules/next/dist/build/swc/index.js [app-rsc] (ecmascript)");
            this.transform = (await loadBindings()).css.lightning.transform;
        }
        const sourcemap = this.options.sourceMap === undefined ? devtool && devtool.includes('source-map') : this.options.sourceMap;
        const { include, exclude, test: testRegExp, targets: userTargets, ...transformOptions } = this.options;
        const assets = compilation.getAssets().filter((asset)=>!asset.info.minimized && // Filter out by file type
            (testRegExp || CSS_FILE_REG).test(asset.name) && _webpack.ModuleFilenameHelpers.matchObject({
                include,
                exclude
            }, asset.name));
        await Promise.all(assets.map(async (asset)=>{
            const { source, map } = asset.source.sourceAndMap();
            const sourceAsString = source.toString();
            const code = typeof source === 'string' ? _buffer.Buffer.from(source) : source;
            const targets = (0, _utils.getTargets)({
                targets: userTargets,
                key: _interface.ECacheKey.minify
            });
            const result = await this.transform({
                filename: asset.name,
                code,
                minify: true,
                sourceMap: sourcemap,
                targets,
                ...transformOptions
            });
            const codeString = result.code.toString();
            compilation.updateAsset(asset.name, sourcemap ? new _webpacksources3.SourceMapSource(codeString, asset.name, JSON.parse(result.map.toString()), sourceAsString, map, true) : new _webpacksources3.RawSource(codeString), {
                ...asset.info,
                minimized: true
            });
        }));
    }
} //# sourceMappingURL=minify.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    LightningCssMinifyPlugin: null,
    default: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LightningCssMinifyPlugin: function() {
        return _minify.LightningCssMinifyPlugin;
    },
    default: function() {
        return _default;
    }
});
const _loader = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/loader.js [app-rsc] (ecmascript)");
const _minify = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/minify.js [app-rsc] (ecmascript)");
const _default = _loader.LightningCssLoader; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/global.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getGlobalCssLoader", {
    enumerable: true,
    get: function() {
        return getGlobalCssLoader;
    }
});
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/client.js [app-rsc] (ecmascript)");
const _fileresolve = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/file-resolve.js [app-rsc] (ecmascript)");
function getGlobalCssLoader(ctx, postcss, preProcessors = []) {
    const loaders = [];
    if (ctx.isClient) {
        // Add appropriate development more or production mode style
        // loader
        loaders.push((0, _client.getClientStyleLoader)({
            hasAppDir: ctx.hasAppDir,
            isAppDir: ctx.isAppDir,
            isDevelopment: ctx.isDevelopment,
            assetPrefix: ctx.assetPrefix
        }));
    }
    if (ctx.experimental.useLightningcss) {
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                importLoaders: 1 + preProcessors.length,
                url: (url, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                import: (url, _, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                modules: false,
                targets: ctx.supportedBrowsers,
                postcss
            }
        });
    } else {
        // Resolve CSS `@import`s and `url()`s
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                postcss,
                importLoaders: 1 + preProcessors.length,
                // Next.js controls CSS Modules eligibility:
                modules: false,
                url: (url, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                import: (url, _, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports)
            }
        });
        // Compile CSS
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                postcss
            }
        });
    }
    loaders.push(// order of preprocessors.
    ...preProcessors.slice().reverse());
    return loaders;
} //# sourceMappingURL=global.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/getCssModuleLocalIdent.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getCssModuleLocalIdent", {
    enumerable: true,
    get: function() {
        return getCssModuleLocalIdent;
    }
});
const _loaderutils3 = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/loader-utils3/index.js [app-rsc] (ecmascript)"));
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const regexLikeIndexModule = /(?<!pages[\\/])index\.module\.(scss|sass|css)$/;
function getCssModuleLocalIdent(context, _, exportName, options) {
    const relativePath = _path.default.relative(context.rootContext, context.resourcePath).replace(/\\+/g, '/');
    // Generate a more meaningful name (parent folder) when the user names the
    // file `index.module.css`.
    const fileNameOrFolder = regexLikeIndexModule.test(relativePath) ? '[folder]' : '[name]';
    // Generate a hash to make the class name unique.
    const hash = _loaderutils3.default.getHashDigest(Buffer.from(`filePath:${relativePath}#className:${exportName}`), 'sha1', 'base64', 5);
    // Have webpack interpolate the `[folder]` or `[name]` to its real value.
    return _loaderutils3.default.interpolateName(context, fileNameOrFolder + '_' + exportName + '__' + hash, options).replace(// `.root {}` inside a file named `about.module.css`. Let's simplify
    // this.
    /\.module_/, '_') // Replace invalid symbols with underscores instead of escaping
    // https://mathiasbynens.be/notes/css-escapes#identifiers-strings
    .replace(/[^a-zA-Z0-9-_]/g, '_') // "they cannot start with a digit, two hyphens, or a hyphen followed by a digit [sic]"
    // https://www.w3.org/TR/CSS21/syndata.html#characters
    .replace(/^(\d|--|-\d)/, '__$1');
} //# sourceMappingURL=getCssModuleLocalIdent.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/modules.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getCssModuleLoader", {
    enumerable: true,
    get: function() {
        return getCssModuleLoader;
    }
});
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/client.js [app-rsc] (ecmascript)");
const _fileresolve = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/file-resolve.js [app-rsc] (ecmascript)");
const _getCssModuleLocalIdent = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/getCssModuleLocalIdent.js [app-rsc] (ecmascript)");
function getCssModuleLoader(ctx, postcss, preProcessors = []) {
    const loaders = [];
    if (ctx.isClient) {
        // Add appropriate development more or production mode style
        // loader
        loaders.push((0, _client.getClientStyleLoader)({
            hasAppDir: ctx.hasAppDir,
            isAppDir: ctx.isAppDir,
            isDevelopment: ctx.isDevelopment,
            assetPrefix: ctx.assetPrefix
        }));
    }
    if (ctx.experimental.useLightningcss) {
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                importLoaders: 1 + preProcessors.length,
                url: (url, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                import: (url, _, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                modules: {
                    // Do not transform class names (CJS mode backwards compatibility):
                    exportLocalsConvention: 'asIs',
                    // Server-side (Node.js) rendering support:
                    exportOnlyLocals: ctx.isServer
                },
                targets: ctx.supportedBrowsers,
                postcss
            }
        });
    } else {
        // Resolve CSS `@import`s and `url()`s
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                postcss,
                importLoaders: 1 + preProcessors.length,
                // Use CJS mode for backwards compatibility:
                esModule: false,
                url: (url, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                import: (url, _, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
                modules: {
                    // Do not transform class names (CJS mode backwards compatibility):
                    exportLocalsConvention: 'asIs',
                    // Server-side (Node.js) rendering support:
                    exportOnlyLocals: ctx.isServer,
                    // Disallow global style exports so we can code-split CSS and
                    // not worry about loading order.
                    mode: 'pure',
                    // Generate a friendly production-ready name so it's
                    // reasonably understandable. The same name is used for
                    // development.
                    // TODO: Consider making production reduce this to a single
                    // character?
                    getLocalIdent: _getCssModuleLocalIdent.getCssModuleLocalIdent
                }
            }
        });
        // Compile CSS
        loaders.push({
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js [app-rsc] (ecmascript)",
            options: {
                postcss
            }
        });
    }
    loaders.push(// order of preprocessors.
    ...preProcessors.slice().reverse());
    return loaders;
} //# sourceMappingURL=modules.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && __export(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/global.js [app-rsc] (ecmascript)")) && __export(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/modules.js [app-rsc] (ecmascript)"));
_export_star(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/global.js [app-rsc] (ecmascript)"), exports);
_export_star(__turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/modules.js [app-rsc] (ecmascript)"), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/next-font.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextFontLoader", {
    enumerable: true,
    get: function() {
        return getNextFontLoader;
    }
});
const _client = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/client.js [app-rsc] (ecmascript)");
const _fileresolve = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/file-resolve.js [app-rsc] (ecmascript)");
function getNextFontLoader(ctx, postcss, fontLoaderPath) {
    const loaders = [];
    if (ctx.isClient) {
        // Add appropriate development mode or production mode style
        // loader
        loaders.push((0, _client.getClientStyleLoader)({
            hasAppDir: ctx.hasAppDir,
            isDevelopment: ctx.isDevelopment,
            assetPrefix: ctx.assetPrefix
        }));
    }
    loaders.push({
        loader: "[project]/node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js [app-rsc] (ecmascript)",
        options: {
            postcss,
            importLoaders: 1,
            // Use CJS mode for backwards compatibility:
            esModule: false,
            url: (url, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
            import: (url, _, resourcePath)=>(0, _fileresolve.cssFileResolve)(url, resourcePath, ctx.experimental.urlImports),
            modules: {
                // Do not transform class names (CJS mode backwards compatibility):
                exportLocalsConvention: 'asIs',
                // Server-side (Node.js) rendering support:
                exportOnlyLocals: ctx.isServer,
                // Disallow global style exports so we can code-split CSS and
                // not worry about loading order.
                mode: 'pure',
                getLocalIdent: (_context, _localIdentName, exportName, _options, meta)=>{
                    // hash from next-font-loader
                    return `__${exportName}_${meta.fontFamilyHash}`;
                }
            },
            fontLoader: true
        }
    });
    loaders.push({
        loader: 'next-font-loader',
        options: {
            isDev: ctx.isDevelopment,
            isServer: ctx.isServer,
            assetPrefix: ctx.assetPrefix,
            fontLoaderPath,
            postcss
        }
    });
    return loaders;
} //# sourceMappingURL=next-font.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/messages.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getCustomDocumentError: null,
    getGlobalImportError: null,
    getGlobalModuleImportError: null,
    getLocalModuleImportError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCustomDocumentError: function() {
        return getCustomDocumentError;
    },
    getGlobalImportError: function() {
        return getGlobalImportError;
    },
    getGlobalModuleImportError: function() {
        return getGlobalModuleImportError;
    },
    getLocalModuleImportError: function() {
        return getLocalModuleImportError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
function getGlobalImportError() {
    return `Global CSS ${(0, _picocolors.bold)('cannot')} be imported from files other than your ${(0, _picocolors.bold)('Custom <App>')}. Due to the Global nature of stylesheets, and to avoid conflicts, Please move all first-party global CSS imports to ${(0, _picocolors.cyan)('pages/_app.js')}. Or convert the import to Component-Level CSS (CSS Modules).\nRead more: https://nextjs.org/docs/messages/css-global`;
}
function getGlobalModuleImportError() {
    return `Global CSS ${(0, _picocolors.bold)('cannot')} be imported from within ${(0, _picocolors.bold)('node_modules')}.\nRead more: https://nextjs.org/docs/messages/css-npm`;
}
function getLocalModuleImportError() {
    return `CSS Modules ${(0, _picocolors.bold)('cannot')} be imported from within ${(0, _picocolors.bold)('node_modules')}.\nRead more: https://nextjs.org/docs/messages/css-modules-npm`;
}
function getCustomDocumentError() {
    return `CSS ${(0, _picocolors.bold)('cannot')} be imported within ${(0, _picocolors.cyan)('pages/_document.js')}. Please move global styles to ${(0, _picocolors.cyan)('pages/_app.js')}.`;
} //# sourceMappingURL=messages.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/plugins.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getPostCssPlugins", {
    enumerable: true,
    get: function() {
        return getPostCssPlugins;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const _findconfig = __turbopack_context__.r("[project]/node_modules/next/dist/lib/find-config.js [app-rsc] (ecmascript)");
const genericErrorText = 'Malformed PostCSS Configuration';
function getError_NullConfig(pluginName) {
    return `${(0, _picocolors.red)((0, _picocolors.bold)('Error'))}: Your PostCSS configuration for '${pluginName}' cannot have ${(0, _picocolors.bold)('null')} configuration.\nTo disable '${pluginName}', pass ${(0, _picocolors.bold)('false')}, otherwise, pass ${(0, _picocolors.bold)('true')} or a configuration object.`;
}
function isIgnoredPlugin(pluginPath) {
    const ignoredRegex = /(?:^|[\\/])(postcss-modules-values|postcss-modules-scope|postcss-modules-extract-imports|postcss-modules-local-by-default|postcss-modules)(?:[\\/]|$)/i;
    const match = ignoredRegex.exec(pluginPath);
    if (match == null) {
        return false;
    }
    const plugin = match.pop();
    console.warn(`${(0, _picocolors.yellow)((0, _picocolors.bold)('Warning'))}: Please remove the ${(0, _picocolors.underline)(plugin)} plugin from your PostCSS configuration. ` + `This plugin is automatically configured by Next.js.\n` + 'Read more: https://nextjs.org/docs/messages/postcss-ignored-plugin');
    return true;
}
const createLazyPostCssPlugin = (fn)=>{
    let result = undefined;
    const plugin = (...args)=>{
        if (result === undefined) result = fn();
        if (result.postcss === true) {
            return result(...args);
        } else if (result.postcss) {
            return result.postcss;
        }
        return result;
    };
    plugin.postcss = true;
    return plugin;
};
async function loadPlugin(dir, pluginName, options) {
    if (options === false || isIgnoredPlugin(pluginName)) {
        return false;
    }
    if (options == null) {
        console.error(getError_NullConfig(pluginName));
        throw Object.defineProperty(new Error(genericErrorText), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    const pluginPath = (()=>{
        const e = new Error("Cannot find module as expression is too dynamic");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
    if (isIgnoredPlugin(pluginPath)) {
        return false;
    } else if (options === true) {
        return createLazyPostCssPlugin(()=>(()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })());
    } else {
        if (typeof options === 'object' && Object.keys(options).length === 0) {
            return createLazyPostCssPlugin(()=>(()=>{
                    const e = new Error("Cannot find module as expression is too dynamic");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })());
        }
        return createLazyPostCssPlugin(()=>(()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })()(options));
    }
}
function getDefaultPlugins(supportedBrowsers, disablePostcssPresetEnv) {
    return [
        "[project]/node_modules/next/dist/compiled/postcss-flexbugs-fixes/index.js [app-rsc] (ecmascript)",
        disablePostcssPresetEnv ? false : [
            "[project]/node_modules/next/dist/compiled/postcss-preset-env/index.cjs [app-rsc] (ecmascript)",
            {
                browsers: supportedBrowsers ?? [
                    'defaults'
                ],
                autoprefixer: {
                    // Disable legacy flexbox support
                    flexbox: 'no-2009'
                },
                // Enable CSS features that have shipped to the
                // web platform, i.e. in 2+ browsers unflagged.
                stage: 3,
                features: {
                    'custom-properties': false
                }
            }
        ]
    ].filter(Boolean);
}
async function getPostCssPlugins(dir, supportedBrowsers, disablePostcssPresetEnv = false, useLightningcss = false) {
    let config = await (0, _findconfig.findConfig)(dir, 'postcss');
    if (config == null) {
        config = {
            plugins: useLightningcss ? [] : getDefaultPlugins(supportedBrowsers, disablePostcssPresetEnv)
        };
    }
    if (typeof config === 'function') {
        throw Object.defineProperty(new Error(`Your custom PostCSS configuration may not export a function. Please export a plain object instead.\n` + 'Read more: https://nextjs.org/docs/messages/postcss-function'), "__NEXT_ERROR_CODE", {
            value: "E323",
            enumerable: false,
            configurable: true
        });
    }
    // Warn user about configuration keys which are not respected
    const invalidKey = Object.keys(config).find((key)=>key !== 'plugins');
    if (invalidKey) {
        console.warn(`${(0, _picocolors.yellow)((0, _picocolors.bold)('Warning'))}: Your PostCSS configuration defines a field which is not supported (\`${invalidKey}\`). ` + `Please remove this configuration value.`);
    }
    // Enforce the user provided plugins if the configuration file is present
    let plugins = config.plugins;
    if (plugins == null || typeof plugins !== 'object') {
        throw Object.defineProperty(new Error(`Your custom PostCSS configuration must export a \`plugins\` key.`), "__NEXT_ERROR_CODE", {
            value: "E347",
            enumerable: false,
            configurable: true
        });
    }
    if (!Array.isArray(plugins)) {
        // Capture variable so TypeScript is happy
        const pc = plugins;
        plugins = Object.keys(plugins).reduce((acc, curr)=>{
            const p = pc[curr];
            if (typeof p === 'undefined') {
                console.error(getError_NullConfig(curr));
                throw Object.defineProperty(new Error(genericErrorText), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            }
            acc.push([
                curr,
                p
            ]);
            return acc;
        }, []);
    }
    const parsed = [];
    plugins.forEach((plugin)=>{
        if (plugin == null) {
            console.warn(`${(0, _picocolors.yellow)((0, _picocolors.bold)('Warning'))}: A ${(0, _picocolors.bold)('null')} PostCSS plugin was provided. This entry will be ignored.`);
        } else if (typeof plugin === 'string') {
            parsed.push([
                plugin,
                true
            ]);
        } else if (Array.isArray(plugin)) {
            const pluginName = plugin[0];
            const pluginConfig = plugin[1];
            if (typeof pluginName === 'string' && (typeof pluginConfig === 'boolean' || typeof pluginConfig === 'object' || typeof pluginConfig === 'string')) {
                parsed.push([
                    pluginName,
                    pluginConfig
                ]);
            } else {
                if (typeof pluginName !== 'string') {
                    console.error(`${(0, _picocolors.red)((0, _picocolors.bold)('Error'))}: A PostCSS Plugin must be provided as a ${(0, _picocolors.bold)('string')}. Instead, we got: '${pluginName}'.\n` + 'Read more: https://nextjs.org/docs/messages/postcss-shape');
                } else {
                    console.error(`${(0, _picocolors.red)((0, _picocolors.bold)('Error'))}: A PostCSS Plugin was passed as an array but did not provide its configuration ('${pluginName}').\n` + 'Read more: https://nextjs.org/docs/messages/postcss-shape');
                }
                throw Object.defineProperty(new Error(genericErrorText), "__NEXT_ERROR_CODE", {
                    value: "E394",
                    enumerable: false,
                    configurable: true
                });
            }
        } else if (typeof plugin === 'function') {
            console.error(`${(0, _picocolors.red)((0, _picocolors.bold)('Error'))}: A PostCSS Plugin was passed as a function using require(), but it must be provided as a ${(0, _picocolors.bold)('string')}.\nRead more: https://nextjs.org/docs/messages/postcss-shape`);
            throw Object.defineProperty(new Error(genericErrorText), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        } else {
            console.error(`${(0, _picocolors.red)((0, _picocolors.bold)('Error'))}: An unknown PostCSS plugin was provided (${plugin}).\n` + 'Read more: https://nextjs.org/docs/messages/postcss-shape');
            throw Object.defineProperty(new Error(genericErrorText), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    });
    const resolved = await Promise.all(parsed.map((p)=>loadPlugin(dir, p[0], p[1])));
    const filtered = resolved.filter(Boolean);
    return filtered;
} //# sourceMappingURL=plugins.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/css/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    css: null,
    lazyPostCSS: null,
    regexLikeCss: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    css: function() {
        return css;
    },
    lazyPostCSS: function() {
        return lazyPostCSS;
    },
    regexLikeCss: function() {
        return regexLikeCss;
    }
});
const _lodashcurry = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/lodash.curry/index.js [app-rsc] (ecmascript)"));
const _helpers = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/helpers.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/utils.js [app-rsc] (ecmascript)");
const _loaders = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/index.js [app-rsc] (ecmascript)");
const _nextfont = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/loaders/next-font.js [app-rsc] (ecmascript)");
const _messages = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/messages.js [app-rsc] (ecmascript)");
const _plugins = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/plugins.js [app-rsc] (ecmascript)");
const _nonnullable = __turbopack_context__.r("[project]/node_modules/next/dist/lib/non-nullable.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _getrspack = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-rspack.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const regexLikeCss = /\.(css|scss|sass)$/;
// RegExps for Style Sheets
const regexCssGlobal = /(?<!\.module)\.css$/;
const regexCssModules = /\.module\.css$/;
// RegExps for Syntactically Awesome Style Sheets
const regexSassGlobal = /(?<!\.module)\.(scss|sass)$/;
const regexSassModules = /\.module\.(scss|sass)$/;
const APP_LAYER_RULE = {
    or: [
        _constants.WEBPACK_LAYERS.reactServerComponents,
        _constants.WEBPACK_LAYERS.serverSideRendering,
        _constants.WEBPACK_LAYERS.appPagesBrowser
    ]
};
const PAGES_LAYER_RULE = {
    not: [
        _constants.WEBPACK_LAYERS.reactServerComponents,
        _constants.WEBPACK_LAYERS.serverSideRendering,
        _constants.WEBPACK_LAYERS.appPagesBrowser
    ]
};
/**
 * Mark a rule as removable if built-in CSS support is disabled
 */ function markRemovable(r) {
    Object.defineProperty(r, Symbol.for('__next_css_remove'), {
        enumerable: false,
        value: true
    });
    return r;
}
let postcssInstancePromise;
async function lazyPostCSS(rootDirectory, supportedBrowsers, disablePostcssPresetEnv, useLightningcss) {
    if (!postcssInstancePromise) {
        postcssInstancePromise = (async ()=>{
            const postcss = __turbopack_context__.r("[project]/node_modules/next/node_modules/postcss/lib/postcss.js [app-rsc] (ecmascript)");
            // @ts-ignore backwards compat
            postcss.plugin = function postcssPlugin(name, initializer) {
                function creator(...args) {
                    let transformer = initializer(...args);
                    transformer.postcssPlugin = name;
                    // transformer.postcssVersion = new Processor().version
                    return transformer;
                }
                let cache;
                Object.defineProperty(creator, 'postcss', {
                    get () {
                        if (!cache) cache = creator();
                        return cache;
                    }
                });
                creator.process = function(css, processOpts, pluginOpts) {
                    return postcss([
                        creator(pluginOpts)
                    ]).process(css, processOpts);
                };
                return creator;
            };
            // @ts-ignore backwards compat
            postcss.vendor = {
                /**
         * Returns the vendor prefix extracted from an input string.
         *
         * @example
         * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
         * postcss.vendor.prefix('tab-size')      //=> ''
         */ prefix: function prefix(prop) {
                    const match = prop.match(/^(-\w+-)/);
                    if (match) {
                        return match[0];
                    }
                    return '';
                },
                /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @example
         * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */ unprefixed: function unprefixed(/**
           * String with or without vendor prefix.
           */ prop) {
                    return prop.replace(/^-\w+-/, '');
                }
            };
            const postCssPlugins = await (0, _plugins.getPostCssPlugins)(rootDirectory, supportedBrowsers, disablePostcssPresetEnv, useLightningcss);
            return {
                postcss,
                postcssWithPlugins: postcss(postCssPlugins)
            };
        })();
    }
    return postcssInstancePromise;
}
const css = (0, _lodashcurry.default)(async function css(ctx, config) {
    const isRspack = Boolean(process.env.NEXT_RSPACK);
    const { prependData: sassPrependData, additionalData: sassAdditionalData, implementation: sassImplementation, ...sassOptions } = ctx.sassOptions;
    const lazyPostCSSInitializer = ()=>lazyPostCSS(ctx.rootDirectory, ctx.supportedBrowsers, ctx.experimental.disablePostcssPresetEnv, ctx.experimental.useLightningcss);
    const sassPreprocessors = [
        // First, process files with `sass-loader`: this inlines content, and
        // compiles away the proprietary syntax.
        {
            loader: "[project]/node_modules/next/dist/compiled/sass-loader/cjs.js [app-rsc] (ecmascript)",
            options: {
                implementation: sassImplementation,
                // Source maps are required so that `resolve-url-loader` can locate
                // files original to their source directory.
                sourceMap: true,
                sassOptions: {
                    // The "fibers" option is not needed for Node.js 16+, but it's causing
                    // problems for Node.js <= 14 users as you'll have to manually install
                    // the `fibers` package:
                    // https://github.com/webpack-contrib/sass-loader#:~:text=We%20automatically%20inject%20the%20fibers%20package
                    // https://github.com/vercel/next.js/issues/45052
                    // Since it's optional and not required, we'll disable it by default
                    // to avoid the confusion.
                    fibers: false,
                    // TODO: Remove this once we upgrade to sass-loader 16
                    silenceDeprecations: [
                        'legacy-js-api'
                    ],
                    ...sassOptions
                },
                additionalData: sassPrependData || sassAdditionalData
            }
        },
        // Then, `sass-loader` will have passed-through CSS imports as-is instead
        // of inlining them. Because they were inlined, the paths are no longer
        // correct.
        // To fix this, we use `resolve-url-loader` to rewrite the CSS
        // imports to real file paths.
        {
            loader: "[project]/node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js [app-rsc] (ecmascript)",
            options: {
                postcss: lazyPostCSSInitializer,
                // Source maps are not required here, but we may as well emit
                // them.
                sourceMap: true
            }
        }
    ];
    const fns = [];
    const googleLoader = "[project]/node_modules/next/dist/compiled/@next/font/google/loader.js [app-rsc] (ecmascript)";
    const localLoader = "[project]/node_modules/next/dist/compiled/@next/font/local/loader.js [app-rsc] (ecmascript)";
    const nextFontLoaders = [
        [
            (()=>{
                const e = new Error("Cannot find module 'next/font/google/target.css'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            googleLoader
        ],
        [
            (()=>{
                const e = new Error("Cannot find module 'next/font/local/target.css'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            localLoader
        ]
    ];
    nextFontLoaders.forEach(([fontLoaderTarget, fontLoaderPath])=>{
        // Matches the resolved font loaders noop files to run next-font-loader
        fns.push((0, _helpers.loader)({
            oneOf: [
                markRemovable({
                    sideEffects: false,
                    test: fontLoaderTarget,
                    use: (0, _nextfont.getNextFontLoader)(ctx, lazyPostCSSInitializer, fontLoaderPath)
                })
            ]
        }));
    });
    // CSS cannot be imported in _document. This comes before everything because
    // global CSS nor CSS modules work in said file.
    fns.push((0, _helpers.loader)({
        oneOf: [
            markRemovable({
                test: regexLikeCss,
                // Use a loose regex so we don't have to crawl the file system to
                // find the real file name (if present).
                issuer: /pages[\\/]_document\./,
                use: {
                    loader: 'error-loader',
                    options: {
                        reason: (0, _messages.getCustomDocumentError)()
                    }
                }
            })
        ]
    }));
    const shouldIncludeExternalCSSImports = !!ctx.experimental.craCompat || !!ctx.transpilePackages;
    // CSS modules & SASS modules support. They are allowed to be imported in anywhere.
    fns.push(// allow unused CSS to be removed from the production build.
    // We ensure this by disallowing `:global()` CSS at the top-level
    // via the `pure` mode in `css-loader`.
    (0, _helpers.loader)({
        oneOf: [
            // For app dir, we need to match the specific app layer.
            ctx.hasAppDir ? markRemovable({
                sideEffects: true,
                test: regexCssModules,
                issuerLayer: APP_LAYER_RULE,
                use: [
                    {
                        loader: "[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)",
                        options: {
                            cssModules: true
                        }
                    },
                    ...(0, _loaders.getCssModuleLoader)({
                        ...ctx,
                        isAppDir: true
                    }, lazyPostCSSInitializer)
                ]
            }) : null,
            markRemovable({
                sideEffects: true,
                test: regexCssModules,
                issuerLayer: PAGES_LAYER_RULE,
                use: (0, _loaders.getCssModuleLoader)({
                    ...ctx,
                    isAppDir: false
                }, lazyPostCSSInitializer)
            })
        ].filter(_nonnullable.nonNullable)
    }), // Sass Modules should never have side effects. This setting will
    // allow unused Sass to be removed from the production build.
    // We ensure this by disallowing `:global()` Sass at the top-level
    // via the `pure` mode in `css-loader`.
    (0, _helpers.loader)({
        oneOf: [
            // For app dir, we need to match the specific app layer.
            ctx.hasAppDir ? markRemovable({
                sideEffects: true,
                test: regexSassModules,
                issuerLayer: APP_LAYER_RULE,
                use: [
                    {
                        loader: "[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)",
                        options: {
                            cssModules: true
                        }
                    },
                    ...(0, _loaders.getCssModuleLoader)({
                        ...ctx,
                        isAppDir: true
                    }, lazyPostCSSInitializer, sassPreprocessors)
                ]
            }) : null,
            markRemovable({
                sideEffects: true,
                test: regexSassModules,
                issuerLayer: PAGES_LAYER_RULE,
                use: (0, _loaders.getCssModuleLoader)({
                    ...ctx,
                    isAppDir: false
                }, lazyPostCSSInitializer, sassPreprocessors)
            })
        ].filter(_nonnullable.nonNullable)
    }), (0, _helpers.loader)({
        oneOf: [
            markRemovable({
                test: [
                    regexCssModules,
                    regexSassModules
                ],
                use: {
                    loader: 'error-loader',
                    options: {
                        reason: (0, _messages.getLocalModuleImportError)()
                    }
                }
            })
        ]
    }));
    // Global CSS and SASS support.
    if (ctx.isServer) {
        fns.push((0, _helpers.loader)({
            oneOf: [
                ctx.hasAppDir && !ctx.isProduction ? markRemovable({
                    sideEffects: true,
                    test: [
                        regexCssGlobal,
                        regexSassGlobal
                    ],
                    issuerLayer: APP_LAYER_RULE,
                    use: {
                        loader: "[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)",
                        options: {
                            cssModules: false
                        }
                    }
                }) : null,
                markRemovable({
                    // CSS imports have side effects, even on the server side.
                    sideEffects: true,
                    test: [
                        regexCssGlobal,
                        regexSassGlobal
                    ],
                    use: "[project]/node_modules/next/dist/compiled/ignore-loader/index.js [app-rsc] (ecmascript)"
                })
            ].filter(_nonnullable.nonNullable)
        }));
    } else {
        // External CSS files are allowed to be loaded when any of the following is true:
        // - hasAppDir: all CSS files are allowed
        // - If the CSS file is located in `node_modules`
        // - If the CSS file is located in another package in a monorepo (outside of the current rootDir)
        // - If the issuer is pages/_app (matched later)
        const allowedPagesGlobalCSSPath = ctx.hasAppDir ? undefined : {
            and: [
                {
                    or: [
                        /node_modules/,
                        {
                            not: [
                                ctx.rootDirectory
                            ]
                        }
                    ]
                }
            ]
        };
        const allowedPagesGlobalCSSIssuer = ctx.hasAppDir ? undefined : shouldIncludeExternalCSSImports ? undefined : {
            and: [
                ctx.rootDirectory
            ],
            not: [
                /node_modules/
            ]
        };
        fns.push((0, _helpers.loader)({
            oneOf: [
                ...ctx.hasAppDir ? [
                    markRemovable({
                        sideEffects: true,
                        test: regexCssGlobal,
                        issuerLayer: APP_LAYER_RULE,
                        use: [
                            {
                                loader: "[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)",
                                options: {
                                    cssModules: false
                                }
                            },
                            ...(0, _loaders.getGlobalCssLoader)({
                                ...ctx,
                                isAppDir: true
                            }, lazyPostCSSInitializer)
                        ]
                    }),
                    markRemovable({
                        sideEffects: true,
                        test: regexSassGlobal,
                        issuerLayer: APP_LAYER_RULE,
                        use: [
                            {
                                loader: "[project]/node_modules/next/dist/build/webpack/loaders/next-flight-css-loader.js [app-rsc] (ecmascript)",
                                options: {
                                    cssModules: false
                                }
                            },
                            ...(0, _loaders.getGlobalCssLoader)({
                                ...ctx,
                                isAppDir: true
                            }, lazyPostCSSInitializer, sassPreprocessors)
                        ]
                    })
                ] : [],
                markRemovable({
                    sideEffects: true,
                    test: regexCssGlobal,
                    include: allowedPagesGlobalCSSPath,
                    issuer: allowedPagesGlobalCSSIssuer,
                    issuerLayer: PAGES_LAYER_RULE,
                    use: (0, _loaders.getGlobalCssLoader)({
                        ...ctx,
                        isAppDir: false
                    }, lazyPostCSSInitializer)
                }),
                markRemovable({
                    sideEffects: true,
                    test: regexSassGlobal,
                    include: allowedPagesGlobalCSSPath,
                    issuer: allowedPagesGlobalCSSIssuer,
                    issuerLayer: PAGES_LAYER_RULE,
                    use: (0, _loaders.getGlobalCssLoader)({
                        ...ctx,
                        isAppDir: false
                    }, lazyPostCSSInitializer, sassPreprocessors)
                })
            ].filter(_nonnullable.nonNullable)
        }));
        if (ctx.customAppFile) {
            fns.push((0, _helpers.loader)({
                oneOf: [
                    markRemovable({
                        sideEffects: true,
                        test: regexCssGlobal,
                        issuer: {
                            and: [
                                ctx.customAppFile
                            ]
                        },
                        use: (0, _loaders.getGlobalCssLoader)({
                            ...ctx,
                            isAppDir: false
                        }, lazyPostCSSInitializer)
                    })
                ]
            }), (0, _helpers.loader)({
                oneOf: [
                    markRemovable({
                        sideEffects: true,
                        test: regexSassGlobal,
                        issuer: {
                            and: [
                                ctx.customAppFile
                            ]
                        },
                        use: (0, _loaders.getGlobalCssLoader)({
                            ...ctx,
                            isAppDir: false
                        }, lazyPostCSSInitializer, sassPreprocessors)
                    })
                ]
            }));
        }
    }
    // Throw an error for Global CSS used inside of `node_modules`
    if (!shouldIncludeExternalCSSImports) {
        fns.push((0, _helpers.loader)({
            oneOf: [
                markRemovable({
                    test: [
                        regexCssGlobal,
                        regexSassGlobal
                    ],
                    issuer: {
                        and: [
                            /node_modules/
                        ]
                    },
                    use: {
                        loader: 'error-loader',
                        options: {
                            reason: (0, _messages.getGlobalModuleImportError)()
                        }
                    }
                })
            ]
        }));
    }
    // Throw an error for Global CSS used outside of our custom <App> file
    fns.push((0, _helpers.loader)({
        oneOf: [
            markRemovable({
                test: [
                    regexCssGlobal,
                    regexSassGlobal
                ],
                issuer: ctx.hasAppDir ? {
                    // If it's inside the app dir, but not importing from a layout file,
                    // throw an error.
                    and: [
                        ctx.rootDirectory
                    ],
                    not: [
                        /layout\.(js|mjs|jsx|ts|tsx)$/
                    ]
                } : undefined,
                use: {
                    loader: 'error-loader',
                    options: {
                        reason: (0, _messages.getGlobalImportError)()
                    }
                }
            })
        ]
    }));
    if (ctx.isClient) {
        // Automatically transform references to files (i.e. url()) into URLs
        // e.g. url(./logo.svg)
        fns.push((0, _helpers.loader)({
            oneOf: [
                markRemovable({
                    // This should only be applied to CSS files
                    issuer: regexLikeCss,
                    // Exclude extensions that webpack handles by default
                    exclude: [
                        /\.(js|mjs|jsx|ts|tsx)$/,
                        /\.html$/,
                        /\.json$/,
                        /\.webpack\[[^\]]+\]$/
                    ],
                    // `asset/resource` always emits a URL reference, where `asset`
                    // might inline the asset as a data URI
                    type: 'asset/resource'
                })
            ]
        }));
    }
    // Enable full mini-css-extract-plugin hmr for prod mode pages or app dir
    if (ctx.isClient && (ctx.isProduction || ctx.hasAppDir)) {
        // Extract CSS as CSS file(s) in the client-side production bundle.
        const MiniCssExtractPlugin = isRspack ? (0, _getrspack.getRspackCore)().CssExtractRspackPlugin : __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/mini-css-extract-plugin.js [app-rsc] (ecmascript)").default;
        fns.push((0, _helpers.plugin)(new MiniCssExtractPlugin({
            filename: ctx.isProduction ? 'static/css/[contenthash].css' : 'static/css/[name].css',
            chunkFilename: ctx.isProduction ? 'static/css/[contenthash].css' : 'static/css/[name].css',
            // Next.js guarantees that CSS order "doesn't matter", due to imposed
            // restrictions:
            // 1. Global CSS can only be defined in a single entrypoint (_app)
            // 2. CSS Modules generate scoped class names by default and cannot
            //    include Global CSS (:global() selector).
            //
            // While not a perfect guarantee (e.g. liberal use of `:global()`
            // selector), this assumption is required to code-split CSS.
            //
            // If this warning were to trigger, it'd be unactionable by the user,
            // but likely not valid -- so we disable it.
            ignoreOrder: true,
            insert: function(linkTag) {
                if (typeof _N_E_STYLE_LOAD === 'function') {
                    const { href, onload, onerror } = linkTag;
                    _N_E_STYLE_LOAD(href.indexOf(window.location.origin) === 0 ? new URL(href).pathname : href).then(()=>onload == null ? void 0 : onload.call(linkTag, {
                            type: 'load'
                        }), ()=>onerror == null ? void 0 : onerror.call(linkTag, {}));
                } else {
                    document.head.appendChild(linkTag);
                }
            }
        })));
    }
    const fn = (0, _utils.pipe)(...fns);
    return fn(config);
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/images/messages.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getCustomDocumentImageError", {
    enumerable: true,
    get: function() {
        return getCustomDocumentImageError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
function getCustomDocumentImageError() {
    return `Images ${(0, _picocolors.bold)('cannot')} be imported within ${(0, _picocolors.cyan)('pages/_document.js')}. Please move image imports that need to be displayed on every page into ${(0, _picocolors.cyan)('pages/_app.js')}.\nRead more: https://nextjs.org/docs/messages/custom-document-image-import`;
} //# sourceMappingURL=messages.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/blocks/images/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "images", {
    enumerable: true,
    get: function() {
        return images;
    }
});
const _lodashcurry = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/lodash.curry/index.js [app-rsc] (ecmascript)"));
const _webpackconfig = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack-config.js [app-rsc] (ecmascript)");
const _helpers = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/helpers.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/utils.js [app-rsc] (ecmascript)");
const _messages = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/images/messages.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const images = (0, _lodashcurry.default)(async function images(_ctx, config) {
    const fns = [
        (0, _helpers.loader)({
            oneOf: [
                {
                    test: _webpackconfig.nextImageLoaderRegex,
                    use: {
                        loader: 'error-loader',
                        options: {
                            reason: (0, _messages.getCustomDocumentImageError)()
                        }
                    },
                    issuer: /pages[\\/]_document\./
                }
            ]
        })
    ];
    const fn = (0, _utils.pipe)(...fns);
    return fn(config);
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/config/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "buildConfiguration", {
    enumerable: true,
    get: function() {
        return buildConfiguration;
    }
});
const _base = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/base.js [app-rsc] (ecmascript)");
const _css = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/css/index.js [app-rsc] (ecmascript)");
const _images = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/blocks/images/index.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/config/utils.js [app-rsc] (ecmascript)");
async function buildConfiguration(config, { hasAppDir, supportedBrowsers, rootDirectory, customAppFile, isDevelopment, isServer, isEdgeRuntime, targetWeb, assetPrefix, sassOptions, productionBrowserSourceMaps, future, transpilePackages, experimental, disableStaticImages, serverSourceMaps }) {
    const ctx = {
        hasAppDir,
        supportedBrowsers,
        rootDirectory,
        customAppFile,
        isDevelopment,
        isProduction: !isDevelopment,
        isServer,
        isEdgeRuntime,
        isClient: !isServer,
        targetWeb,
        assetPrefix: assetPrefix ? assetPrefix.endsWith('/') ? assetPrefix.slice(0, -1) : assetPrefix : '',
        sassOptions,
        productionBrowserSourceMaps,
        transpilePackages,
        future,
        experimental,
        serverSourceMaps: serverSourceMaps ?? false
    };
    let fns = [
        (0, _base.base)(ctx),
        (0, _css.css)(ctx)
    ];
    if (!disableStaticImages) {
        fns.push((0, _images.images)(ctx));
    }
    const fn = (0, _utils.pipe)(...fns);
    return fn(config);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/getModuleTrace.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatModuleTrace: null,
    getModuleTrace: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatModuleTrace: function() {
        return formatModuleTrace;
    },
    getModuleTrace: function() {
        return getModuleTrace;
    }
});
const _loaderutils3 = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/loader-utils3/index.js [app-rsc] (ecmascript)"));
const _path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function formatModule(compiler, module1) {
    const relativePath = (0, _path.relative)(compiler.context, module1.resource).replace(/\?.+$/, '');
    return _loaderutils3.default.isUrlRequest(relativePath) ? _loaderutils3.default.urlToRequest(relativePath) : relativePath;
}
function formatModuleTrace(compiler, moduleTrace) {
    let importTrace = [];
    let firstExternalModule;
    for(let i = moduleTrace.length - 1; i >= 0; i--){
        const mod = moduleTrace[i];
        if (!mod.resource) continue;
        if (!mod.resource.includes('node_modules/')) {
            importTrace.unshift(formatModule(compiler, mod));
        } else {
            firstExternalModule = mod;
            break;
        }
    }
    let invalidImportMessage = '';
    if (firstExternalModule) {
        var _firstExternalModule_resourceResolveData_descriptionFileData, _firstExternalModule_resourceResolveData;
        const firstExternalPackageName = (_firstExternalModule_resourceResolveData = firstExternalModule.resourceResolveData) == null ? void 0 : (_firstExternalModule_resourceResolveData_descriptionFileData = _firstExternalModule_resourceResolveData.descriptionFileData) == null ? void 0 : _firstExternalModule_resourceResolveData_descriptionFileData.name;
        if (firstExternalPackageName === 'styled-jsx') {
            invalidImportMessage += `\n\nThe error was caused by using 'styled-jsx' in '${importTrace[0]}'. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.`;
        } else {
            let formattedExternalFile = firstExternalModule.resource.split('node_modules');
            formattedExternalFile = formattedExternalFile[formattedExternalFile.length - 1];
            invalidImportMessage += `\n\nThe error was caused by importing '${formattedExternalFile.slice(1)}' in '${importTrace[0]}'.`;
        }
    }
    return {
        lastInternalFileName: importTrace[0],
        invalidImportMessage,
        formattedModuleTrace: importTrace.map((mod)=>'  ' + mod).join('\n')
    };
}
function getModuleTrace(module1, compilation, compiler) {
    // Get the module trace:
    // https://cs.github.com/webpack/webpack/blob/9fcaa243573005d6fdece9a3f8d89a0e8b399613/lib/stats/DefaultStatsFactoryPlugin.js#L414
    const visitedModules = new Set();
    const moduleTrace = [];
    let current = module1;
    let isPagesDir = false;
    while(current){
        if (visitedModules.has(current)) break;
        if (/[\\/]pages/.test(current.resource.replace(compiler.context, ''))) {
            isPagesDir = true;
        }
        visitedModules.add(current);
        moduleTrace.push(current);
        const origin = compilation.moduleGraph.getIssuer(current);
        if (!origin) break;
        current = origin;
    }
    return {
        moduleTrace,
        isPagesDir
    };
} //# sourceMappingURL=getModuleTrace.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SimpleWebpackError", {
    enumerable: true,
    get: function() {
        return SimpleWebpackError;
    }
});
class SimpleWebpackError extends Error {
    constructor(file, message){
        super(message);
        this.file = file;
    }
} //# sourceMappingURL=simpleWebpackError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parse-dynamic-code-evaluation-error.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getDynamicCodeEvaluationError", {
    enumerable: true,
    get: function() {
        return getDynamicCodeEvaluationError;
    }
});
const _getModuleTrace = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/getModuleTrace.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
function getDynamicCodeEvaluationError(message, module, compilation, compiler) {
    const { moduleTrace } = (0, _getModuleTrace.getModuleTrace)(module, compilation, compiler);
    const { formattedModuleTrace, lastInternalFileName, invalidImportMessage } = (0, _getModuleTrace.formatModuleTrace)(compiler, moduleTrace);
    return new _simpleWebpackError.SimpleWebpackError(lastInternalFileName, message + invalidImportMessage + '\n\nImport trace for requested module:\n' + formattedModuleTrace);
} //# sourceMappingURL=parse-dynamic-code-evaluation-error.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/profiling-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ProfilingPlugin: null,
    spans: null,
    webpackInvalidSpans: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ProfilingPlugin: function() {
        return ProfilingPlugin;
    },
    spans: function() {
        return spans;
    },
    webpackInvalidSpans: function() {
        return webpackInvalidSpans;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const pluginName = 'ProfilingPlugin';
const spans = new WeakMap();
const moduleSpansByCompilation = new WeakMap();
const makeSpanByCompilation = new WeakMap();
const sealSpanByCompilation = new WeakMap();
const webpackInvalidSpans = new WeakMap();
const TRACE_LABELS_SEAL = [
    'module assets',
    'create chunk assets',
    'asset render',
    'asset emit',
    'store asset'
];
function inTraceLabelsSeal(label) {
    return TRACE_LABELS_SEAL.some((l)=>label.startsWith(l));
}
class ProfilingPlugin {
    constructor({ runWebpackSpan, rootDir }){
        this.runWebpackSpan = runWebpackSpan;
        this.rootDir = rootDir;
    }
    apply(compiler) {
        this.traceTopLevelHooks(compiler);
        this.traceCompilationHooks(compiler);
        this.compiler = compiler;
    }
    traceHookPair(spanName, startHook, stopHook, { parentSpan, attrs, onStart, onStop } = {}) {
        let span;
        startHook.tap({
            name: pluginName,
            stage: -Infinity
        }, (...params)=>{
            const name = typeof spanName === 'function' ? spanName() : spanName;
            const attributes = attrs ? attrs(...params) : attrs;
            span = parentSpan ? parentSpan(...params).traceChild(name, attributes) : this.runWebpackSpan.traceChild(name, attributes);
            if (onStart) onStart(span, ...params);
        });
        stopHook.tap({
            name: pluginName,
            stage: Infinity
        }, (...params)=>{
            // `stopHook` may be triggered when `startHook` has not in cases
            // where `stopHook` is used as the terminating event for more
            // than one pair of hooks.
            if (!span) {
                return;
            }
            if (onStop) onStop(span, ...params);
            span.stop();
        });
    }
    traceTopLevelHooks(compiler) {
        this.traceHookPair('webpack-compilation', compiler.hooks.compilation, compiler.hooks.afterCompile, {
            parentSpan: ()=>webpackInvalidSpans.get(compiler) || this.runWebpackSpan,
            attrs: ()=>({
                    name: compiler.name
                }),
            onStart: (span, compilation)=>{
                spans.set(compilation, span);
                spans.set(compiler, span);
                moduleSpansByCompilation.set(compilation, new WeakMap());
            }
        });
        if (compiler.options.mode === 'development') {
            this.traceHookPair(()=>`webpack-invalidated-${compiler.name}`, compiler.hooks.invalid, compiler.hooks.done, {
                onStart: (span)=>webpackInvalidSpans.set(compiler, span),
                onStop: ()=>webpackInvalidSpans.delete(compiler),
                attrs: (fileName)=>({
                        trigger: fileName ? _path.default.relative(this.rootDir, fileName).replaceAll(_path.default.sep, '/') : 'manual'
                    })
            });
        }
    }
    traceCompilationHooks(compiler) {
        this.traceHookPair('emit', compiler.hooks.emit, compiler.hooks.afterEmit, {
            parentSpan: ()=>webpackInvalidSpans.get(compiler) || this.runWebpackSpan
        });
        this.traceHookPair('make', compiler.hooks.make, compiler.hooks.finishMake, {
            parentSpan: (compilation)=>{
                const compilationSpan = spans.get(compilation);
                if (!compilationSpan) {
                    return webpackInvalidSpans.get(compiler) || this.runWebpackSpan;
                }
                return compilationSpan;
            },
            onStart: (span, compilation)=>{
                makeSpanByCompilation.set(compilation, span);
            },
            onStop: (_span, compilation)=>{
                makeSpanByCompilation.delete(compilation);
            }
        });
        compiler.hooks.compilation.tap({
            name: pluginName,
            stage: -Infinity
        }, (compilation)=>{
            compilation.hooks.buildModule.tap(pluginName, (module1)=>{
                var _compilation_moduleGraph;
                const moduleType = (()=>{
                    const r = module1.userRequest;
                    if (!r || r.endsWith('!')) {
                        return '';
                    } else {
                        const resource = r.split('!').pop();
                        const match = /^[^?]+\.([^?]+)$/.exec(resource);
                        return match ? match[1] : '';
                    }
                })();
                const issuerModule = compilation == null ? void 0 : (_compilation_moduleGraph = compilation.moduleGraph) == null ? void 0 : _compilation_moduleGraph.getIssuer(module1);
                let span;
                const moduleSpans = moduleSpansByCompilation.get(compilation);
                const spanName = `build-module${moduleType ? `-${moduleType}` : ''}`;
                const issuerSpan = issuerModule && (moduleSpans == null ? void 0 : moduleSpans.get(issuerModule));
                if (issuerSpan) {
                    span = issuerSpan.traceChild(spanName);
                } else {
                    let parentSpan;
                    for (const incomingConnection of compilation.moduleGraph.getIncomingConnections(module1)){
                        const entrySpan = spans.get(incomingConnection.dependency);
                        if (entrySpan) {
                            parentSpan = entrySpan;
                            break;
                        }
                    }
                    if (!parentSpan) {
                        const compilationSpan = spans.get(compilation);
                        if (!compilationSpan) {
                            return;
                        }
                        parentSpan = compilationSpan;
                    }
                    span = parentSpan.traceChild(spanName);
                }
                span.setAttribute('name', module1.userRequest);
                span.setAttribute('layer', module1.layer);
                moduleSpans.set(module1, span);
            });
            const moduleHooks = _webpack.NormalModule.getCompilationHooks(compilation);
            moduleHooks.readResource.for(undefined).intercept({
                register (tapInfo) {
                    const fn = tapInfo.fn;
                    tapInfo.fn = (loaderContext, callback)=>{
                        fn(loaderContext, (err, result)=>{
                            callback(err, result);
                        });
                    };
                    return tapInfo;
                }
            });
            moduleHooks.loader.tap(pluginName, (loaderContext, module1)=>{
                var _moduleSpansByCompilation_get;
                const moduleSpan = (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : _moduleSpansByCompilation_get.get(module1);
                loaderContext.currentTraceSpan = moduleSpan;
            });
            compilation.hooks.succeedModule.tap(pluginName, (module1)=>{
                var _moduleSpansByCompilation_get_get, _moduleSpansByCompilation_get;
                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : (_moduleSpansByCompilation_get_get = _moduleSpansByCompilation_get.get(module1)) == null ? void 0 : _moduleSpansByCompilation_get_get.stop();
            });
            compilation.hooks.failedModule.tap(pluginName, (module1)=>{
                var _moduleSpansByCompilation_get_get, _moduleSpansByCompilation_get;
                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : (_moduleSpansByCompilation_get_get = _moduleSpansByCompilation_get.get(module1)) == null ? void 0 : _moduleSpansByCompilation_get_get.stop();
            });
            this.traceHookPair('seal', compilation.hooks.seal, compilation.hooks.afterSeal, {
                parentSpan: ()=>spans.get(compilation),
                onStart (span) {
                    sealSpanByCompilation.set(compilation, span);
                },
                onStop () {
                    sealSpanByCompilation.delete(compilation);
                }
            });
            compilation.hooks.addEntry.tap(pluginName, (entry)=>{
                const parentSpan = makeSpanByCompilation.get(compilation) || spans.get(compilation);
                if (!parentSpan) {
                    return;
                }
                const addEntrySpan = parentSpan.traceChild('add-entry');
                addEntrySpan.setAttribute('request', entry.request);
                spans.set(entry, addEntrySpan);
            });
            compilation.hooks.succeedEntry.tap(pluginName, (entry)=>{
                var _spans_get;
                (_spans_get = spans.get(entry)) == null ? void 0 : _spans_get.stop();
                spans.delete(entry);
            });
            compilation.hooks.failedEntry.tap(pluginName, (entry)=>{
                var _spans_get;
                (_spans_get = spans.get(entry)) == null ? void 0 : _spans_get.stop();
                spans.delete(entry);
            });
            this.traceHookPair('chunk-graph', compilation.hooks.beforeChunks, compilation.hooks.afterChunks, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('optimize', compilation.hooks.optimize, compilation.hooks.reviveModules, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('optimize-modules', compilation.hooks.optimizeModules, compilation.hooks.afterOptimizeModules, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('optimize-chunks', compilation.hooks.optimizeChunks, compilation.hooks.afterOptimizeChunks, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('optimize-tree', compilation.hooks.optimizeTree, compilation.hooks.afterOptimizeTree, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('optimize-chunk-modules', compilation.hooks.optimizeChunkModules, compilation.hooks.afterOptimizeChunkModules, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('module-hash', compilation.hooks.beforeModuleHash, compilation.hooks.afterModuleHash, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('code-generation', compilation.hooks.beforeCodeGeneration, compilation.hooks.afterCodeGeneration, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('hash', compilation.hooks.beforeHash, compilation.hooks.afterHash, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            this.traceHookPair('code-generation-jobs', compilation.hooks.afterHash, compilation.hooks.beforeModuleAssets, {
                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)
            });
            const logs = new Map();
            const originalTime = compilation.logger.time;
            const originalTimeEnd = compilation.logger.timeEnd;
            compilation.logger.time = (label)=>{
                if (!inTraceLabelsSeal(label)) {
                    return originalTime.call(compilation.logger, label);
                }
                const span = sealSpanByCompilation.get(compilation);
                if (span) {
                    logs.set(label, span.traceChild(label.replace(/ /g, '-')));
                }
                return originalTime.call(compilation.logger, label);
            };
            compilation.logger.timeEnd = (label)=>{
                if (!inTraceLabelsSeal(label)) {
                    return originalTimeEnd.call(compilation.logger, label);
                }
                const span = logs.get(label);
                if (span) {
                    span.stop();
                    logs.delete(label);
                }
                return originalTimeEnd.call(compilation.logger, label);
            };
        });
    }
} //# sourceMappingURL=profiling-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/rspack-profiling-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// A basic implementation to allow loaders access to loaderContext.currentTraceSpan
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    RspackProfilingPlugin: null,
    compilationSpans: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RspackProfilingPlugin: function() {
        return RspackProfilingPlugin;
    },
    compilationSpans: function() {
        return compilationSpans;
    }
});
const _getrspack = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-rspack.js [app-rsc] (ecmascript)");
const pluginName = 'RspackProfilingPlugin';
const moduleSpansByCompilation = new WeakMap();
const compilationSpans = new WeakMap();
class RspackProfilingPlugin {
    constructor({ runWebpackSpan }){
        this.runWebpackSpan = runWebpackSpan;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap({
            name: pluginName,
            stage: -Infinity
        }, (compilation)=>{
            const rspack = (0, _getrspack.getRspackCore)();
            moduleSpansByCompilation.set(compilation, new WeakMap());
            compilationSpans.set(compilation, this.runWebpackSpan.traceChild('compilation-' + compilation.name));
            const compilationSpan = this.runWebpackSpan.traceChild(`compilation-${compilation.name}`);
            const moduleHooks = rspack.NormalModule.getCompilationHooks(compilation);
            moduleHooks.loader.tap(pluginName, (loaderContext, module1)=>{
                var _moduleSpansByCompilation_get;
                const moduleSpan = (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : _moduleSpansByCompilation_get.get(module1);
                loaderContext.currentTraceSpan = moduleSpan;
            });
            compilation.hooks.buildModule.tap(pluginName, (module1)=>{
                var _moduleSpansByCompilation_get;
                const span = compilationSpan.traceChild('build-module');
                span.setAttribute('name', module1.userRequest);
                span.setAttribute('layer', module1.layer);
                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : _moduleSpansByCompilation_get.set(module1, span);
            });
            compilation.hooks.succeedModule.tap(pluginName, (module1)=>{
                var _moduleSpansByCompilation_get_get, _moduleSpansByCompilation_get;
                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : (_moduleSpansByCompilation_get_get = _moduleSpansByCompilation_get.get(module1)) == null ? void 0 : _moduleSpansByCompilation_get_get.stop();
            });
        });
    }
} //# sourceMappingURL=rspack-profiling-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    forEachEntryModule: null,
    formatBarrelOptimizedResource: null,
    getCompilationSpan: null,
    getModuleReferencesInOrder: null,
    traverseModules: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    forEachEntryModule: function() {
        return forEachEntryModule;
    },
    formatBarrelOptimizedResource: function() {
        return formatBarrelOptimizedResource;
    },
    getCompilationSpan: function() {
        return getCompilationSpan;
    },
    getModuleReferencesInOrder: function() {
        return getModuleReferencesInOrder;
    },
    traverseModules: function() {
        return traverseModules;
    }
});
const _entries = __turbopack_context__.r("[project]/node_modules/next/dist/build/entries.js [app-rsc] (ecmascript)");
const _profilingplugin = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/profiling-plugin.js [app-rsc] (ecmascript)");
const _rspackprofilingplugin = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/rspack-profiling-plugin.js [app-rsc] (ecmascript)");
function traverseModules(compilation, callback, filterChunkGroup) {
    compilation.chunkGroups.forEach((chunkGroup)=>{
        if (filterChunkGroup && !filterChunkGroup(chunkGroup)) {
            return;
        }
        chunkGroup.chunks.forEach((chunk)=>{
            const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);
            for (const mod of chunkModules){
                var _compilation_chunkGraph_getModuleId;
                const modId = (_compilation_chunkGraph_getModuleId = compilation.chunkGraph.getModuleId(mod)) == null ? void 0 : _compilation_chunkGraph_getModuleId.toString();
                if (modId) callback(mod, chunk, chunkGroup, modId);
                const anyModule = mod;
                if (anyModule.modules) {
                    for (const subMod of anyModule.modules)if (modId) callback(subMod, chunk, chunkGroup, modId);
                }
            }
        });
    });
}
function forEachEntryModule(compilation, callback) {
    for (const [name, entry] of compilation.entries.entries()){
        var _entry_dependencies;
        // Skip for entries under pages/
        if (name.startsWith('pages/')) {
            continue;
        }
        // Check if the page entry is a server component or not.
        const entryDependency = (_entry_dependencies = entry.dependencies) == null ? void 0 : _entry_dependencies[0];
        // Ensure only next-app-loader entries are handled.
        if (!entryDependency || !entryDependency.request) continue;
        const request = entryDependency.request;
        if (!request.startsWith('next-edge-ssr-loader?') && !request.startsWith('next-edge-app-route-loader?') && !request.startsWith(`${(0, _entries.getAppLoader)()}?`)) continue;
        let entryModule = compilation.moduleGraph.getResolvedModule(entryDependency);
        if (request.startsWith('next-edge-ssr-loader?') || request.startsWith('next-edge-app-route-loader?')) {
            entryModule.dependencies.forEach((dependency)=>{
                const modRequest = dependency.request;
                if (modRequest == null ? void 0 : modRequest.includes((0, _entries.getAppLoader)())) {
                    entryModule = compilation.moduleGraph.getResolvedModule(dependency);
                }
            });
        }
        callback({
            name,
            entryModule
        });
    }
}
function formatBarrelOptimizedResource(resource, matchResource) {
    return `${resource}@${matchResource}`;
}
function getModuleReferencesInOrder(module1, moduleGraph) {
    if ('getOutgoingConnectionsInOrder' in moduleGraph && typeof moduleGraph.getOutgoingConnectionsInOrder === 'function') {
        return moduleGraph.getOutgoingConnectionsInOrder(module1);
    }
    const connections = [];
    for (const connection of moduleGraph.getOutgoingConnections(module1)){
        if (connection.dependency && connection.module) {
            connections.push({
                connection,
                index: moduleGraph.getParentBlockIndex(connection.dependency)
            });
        }
    }
    connections.sort((a, b)=>a.index - b.index);
    return connections.map((c)=>c.connection);
}
function getCompilationSpan(compilation) {
    const compilationSpans = process.env.NEXT_RSPACK ? _rspackprofilingplugin.compilationSpans : _profilingplugin.spans;
    return compilationSpans.get(compilation);
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/middleware-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    SUPPORTED_NATIVE_MODULES: null,
    default: null,
    getEdgePolyfilledModules: null,
    handleWebpackExternalForEdgeRuntime: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SUPPORTED_NATIVE_MODULES: function() {
        return SUPPORTED_NATIVE_MODULES;
    },
    default: function() {
        return MiddlewarePlugin;
    },
    getEdgePolyfilledModules: function() {
        return getEdgePolyfilledModules;
    },
    handleWebpackExternalForEdgeRuntime: function() {
        return handleWebpackExternalForEdgeRuntime;
    }
});
const _routeregex = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/route-regex.js [app-rsc] (ecmascript)");
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [app-rsc] (ecmascript)");
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _picomatch = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-rsc] (ecmascript)"));
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _shared = __turbopack_context__.r("[project]/node_modules/next/dist/trace/shared.js [app-rsc] (ecmascript)");
const _events = __turbopack_context__.r("[project]/node_modules/next/dist/telemetry/events/index.js [app-rsc] (ecmascript)");
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _generateinterceptionroutesrewrites = __turbopack_context__.r("[project]/node_modules/next/dist/lib/generate-interception-routes-rewrites.js [app-rsc] (ecmascript)");
const _parsedynamiccodeevaluationerror = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parse-dynamic-code-evaluation-error.js [app-rsc] (ecmascript)");
const _utils1 = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const KNOWN_SAFE_DYNAMIC_PACKAGES = __turbopack_context__.r("[project]/node_modules/next/dist/lib/known-edge-safe-packages.json (json)");
const NAME = 'MiddlewarePlugin';
const MANIFEST_VERSION = 3;
/**
 * Checks the value of usingIndirectEval and when it is a set of modules it
 * check if any of the modules is actually being used. If the value is
 * simply truthy it will return true.
 */ function isUsingIndirectEvalAndUsedByExports(args) {
    const { moduleGraph, runtime, module: module1, usingIndirectEval, wp } = args;
    if (typeof usingIndirectEval === 'boolean') {
        return usingIndirectEval;
    }
    const exportsInfo = moduleGraph.getExportsInfo(module1);
    for (const exportName of usingIndirectEval){
        if (exportsInfo.getUsed(exportName, runtime) !== wp.UsageState.Unused) {
            return true;
        }
    }
    return false;
}
function getEntryFiles(entryFiles, meta, hasInstrumentationHook, opts) {
    const files = [];
    if (meta.edgeSSR) {
        if (meta.edgeSSR.isServerComponent) {
            files.push(`server/${_constants.SERVER_REFERENCE_MANIFEST}.js`);
            if (opts.sriEnabled) {
                files.push(`server/${_constants.SUBRESOURCE_INTEGRITY_MANIFEST}.js`);
            }
            files.push(...entryFiles.filter((file)=>file.startsWith('app/') && !file.endsWith('.hot-update.js')).map((file)=>'server/' + file.replace(/\.js$/, '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js')));
        }
        if (!opts.dev && !meta.edgeSSR.isAppDir) {
            files.push(`server/${_constants.DYNAMIC_CSS_MANIFEST}.js`);
        }
        files.push(`server/${_constants.MIDDLEWARE_BUILD_MANIFEST}.js`, `server/${_constants.MIDDLEWARE_REACT_LOADABLE_MANIFEST}.js`, `server/${_constants.NEXT_FONT_MANIFEST}.js`, `server/${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}.js`);
    }
    if (hasInstrumentationHook) {
        files.push(`server/edge-${_constants1.INSTRUMENTATION_HOOK_FILENAME}.js`);
    }
    files.push(...entryFiles.filter((file)=>!file.endsWith('.hot-update.js')).map((file)=>'server/' + file));
    return files;
}
function getCreateAssets(params) {
    const { compilation, metadataByEntry, opts } = params;
    return ()=>{
        const middlewareManifest = {
            version: MANIFEST_VERSION,
            middleware: {},
            functions: {},
            sortedMiddleware: []
        };
        const hasInstrumentationHook = compilation.entrypoints.has(_constants1.INSTRUMENTATION_HOOK_FILENAME);
        // we only emit this entry for the edge runtime since it doesn't have access to a routes manifest
        // and we don't need to provide the entire route manifest, just the interception routes.
        const interceptionRewrites = JSON.stringify(opts.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite));
        compilation.emitAsset(`${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST=${JSON.stringify(interceptionRewrites)}`));
        for (const entrypoint of compilation.entrypoints.values()){
            var _metadata_edgeMiddleware, _metadata_edgeSSR, _metadata_edgeApiFunction, _metadata_edgeSSR1, _metadata_edgeMiddleware1;
            if (!entrypoint.name) {
                continue;
            }
            // There should always be metadata for the entrypoint.
            const metadata = metadataByEntry.get(entrypoint.name);
            const page = (metadata == null ? void 0 : (_metadata_edgeMiddleware = metadata.edgeMiddleware) == null ? void 0 : _metadata_edgeMiddleware.page) || (metadata == null ? void 0 : (_metadata_edgeSSR = metadata.edgeSSR) == null ? void 0 : _metadata_edgeSSR.page) || (metadata == null ? void 0 : (_metadata_edgeApiFunction = metadata.edgeApiFunction) == null ? void 0 : _metadata_edgeApiFunction.page);
            if (!page) {
                continue;
            }
            const matcherSource = ((_metadata_edgeSSR1 = metadata.edgeSSR) == null ? void 0 : _metadata_edgeSSR1.isAppDir) ? (0, _apppaths.normalizeAppPath)(page) : page;
            const catchAll = !metadata.edgeSSR && !metadata.edgeApiFunction;
            const { namedRegex } = (0, _routeregex.getNamedMiddlewareRegex)(matcherSource, {
                catchAll
            });
            const matchers = (metadata == null ? void 0 : (_metadata_edgeMiddleware1 = metadata.edgeMiddleware) == null ? void 0 : _metadata_edgeMiddleware1.matchers) ?? [
                {
                    regexp: namedRegex,
                    originalSource: page === '/' && catchAll ? '/:path*' : matcherSource
                }
            ];
            const isEdgeFunction = !!(metadata.edgeApiFunction || metadata.edgeSSR);
            const edgeFunctionDefinition = {
                files: getEntryFiles(entrypoint.getFiles(), metadata, hasInstrumentationHook, opts),
                name: entrypoint.name,
                page: page,
                matchers,
                wasm: Array.from(metadata.wasmBindings, ([name, filePath])=>({
                        name,
                        filePath
                    })),
                assets: Array.from(metadata.assetBindings, ([name, filePath])=>({
                        name,
                        filePath
                    })),
                env: opts.edgeEnvironments,
                ...metadata.regions && {
                    regions: metadata.regions
                }
            };
            if (isEdgeFunction) {
                middlewareManifest.functions[page] = edgeFunctionDefinition;
            } else {
                middlewareManifest.middleware[page] = edgeFunctionDefinition;
            }
        }
        middlewareManifest.sortedMiddleware = (0, _utils.getSortedRoutes)(Object.keys(middlewareManifest.middleware));
        compilation.emitAsset(_constants.MIDDLEWARE_MANIFEST, new _webpack.sources.RawSource(JSON.stringify(middlewareManifest, null, 2)));
    };
}
function buildWebpackError({ message, loc, compilation, entryModule, parser }) {
    const error = new compilation.compiler.webpack.WebpackError(message);
    error.name = NAME;
    const module1 = entryModule ?? (parser == null ? void 0 : parser.state.current);
    if (module1) {
        error.module = module1;
    }
    error.loc = loc;
    return error;
}
function isInMiddlewareLayer(parser) {
    var _parser_state_module;
    const layer = (_parser_state_module = parser.state.module) == null ? void 0 : _parser_state_module.layer;
    return layer === _constants1.WEBPACK_LAYERS.middleware || layer === _constants1.WEBPACK_LAYERS.apiEdge;
}
function isNodeJsModule(moduleName) {
    return __turbopack_context__.r("[externals]/module [external] (module, cjs)").builtinModules.includes(moduleName);
}
function isDynamicCodeEvaluationAllowed(fileName, middlewareConfig, rootDir) {
    // Some packages are known to use `eval` but are safe to use in the Edge
    // Runtime because the dynamic code will never be executed.
    if (KNOWN_SAFE_DYNAMIC_PACKAGES.some((pkg)=>fileName.includes(`/node_modules/${pkg}/`.replace(/\//g, _path.default.sep)))) {
        return true;
    }
    const name = fileName.replace(rootDir ?? '', '');
    return (0, _picomatch.default)((middlewareConfig == null ? void 0 : middlewareConfig.unstable_allowDynamic) ?? [], {
        dot: true
    })(name);
}
function buildUnsupportedApiError({ apiName, loc, ...rest }) {
    return buildWebpackError({
        message: `A Node.js API is used (${apiName} at line: ${loc.start.line}) which is not supported in the Edge Runtime.
Learn more: https://nextjs.org/docs/api-reference/edge-runtime`,
        loc,
        ...rest
    });
}
function registerUnsupportedApiHooks(parser, compilation) {
    for (const expression of _constants.EDGE_UNSUPPORTED_NODE_APIS){
        const warnForUnsupportedApi = (node)=>{
            if (!isInMiddlewareLayer(parser)) {
                return;
            }
            compilation.warnings.push(buildUnsupportedApiError({
                compilation,
                parser,
                apiName: expression,
                ...node
            }));
            return true;
        };
        parser.hooks.call.for(expression).tap(NAME, warnForUnsupportedApi);
        parser.hooks.expression.for(expression).tap(NAME, warnForUnsupportedApi);
        parser.hooks.callMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);
        parser.hooks.expressionMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);
    }
    const warnForUnsupportedProcessApi = (node, [callee])=>{
        if (!isInMiddlewareLayer(parser) || callee === 'env') {
            return;
        }
        compilation.warnings.push(buildUnsupportedApiError({
            compilation,
            parser,
            apiName: `process.${callee}`,
            ...node
        }));
        return true;
    };
    parser.hooks.callMemberChain.for('process').tap(NAME, warnForUnsupportedProcessApi);
    parser.hooks.expressionMemberChain.for('process').tap(NAME, warnForUnsupportedProcessApi);
}
function getCodeAnalyzer(params) {
    return (parser)=>{
        const { dev, compiler: { webpack: wp }, compilation } = params;
        const { hooks } = parser;
        /**
     * For an expression this will check the graph to ensure it is being used
     * by exports. Then it will store in the module buildInfo a boolean to
     * express that it contains dynamic code and, if it is available, the
     * module path that is using it.
     */ const handleExpression = ()=>{
            if (!isInMiddlewareLayer(parser)) {
                return;
            }
            wp.optimize.InnerGraph.onUsage(parser.state, (used = true)=>{
                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(parser.state.module);
                if (buildInfo.usingIndirectEval === true || used === false) {
                    return;
                }
                if (!buildInfo.usingIndirectEval || used === true) {
                    buildInfo.usingIndirectEval = used;
                    return;
                }
                buildInfo.usingIndirectEval = new Set([
                    ...Array.from(buildInfo.usingIndirectEval),
                    ...Array.from(used)
                ]);
            });
        };
        /**
     * This expression handler allows to wrap a dynamic code expression with a
     * function call where we can warn about dynamic code not being allowed
     * but actually execute the expression.
     */ const handleWrapExpression = (expr)=>{
            if (!isInMiddlewareLayer(parser)) {
                return;
            }
            const { ConstDependency } = wp.dependencies;
            const dep1 = new ConstDependency('__next_eval__(function() { return ', expr.range[0]);
            dep1.loc = expr.loc;
            parser.state.module.addPresentationalDependency(dep1);
            const dep2 = new ConstDependency('})', expr.range[1]);
            dep2.loc = expr.loc;
            parser.state.module.addPresentationalDependency(dep2);
            handleExpression();
            return true;
        };
        /**
     * This expression handler allows to wrap a WebAssembly.compile invocation with a
     * function call where we can warn about WASM code generation not being allowed
     * but actually execute the expression.
     */ const handleWrapWasmCompileExpression = (expr)=>{
            if (!isInMiddlewareLayer(parser)) {
                return;
            }
            const { ConstDependency } = wp.dependencies;
            const dep1 = new ConstDependency('__next_webassembly_compile__(function() { return ', expr.range[0]);
            dep1.loc = expr.loc;
            parser.state.module.addPresentationalDependency(dep1);
            const dep2 = new ConstDependency('})', expr.range[1]);
            dep2.loc = expr.loc;
            parser.state.module.addPresentationalDependency(dep2);
            handleExpression();
        };
        /**
     * This expression handler allows to wrap a WebAssembly.instatiate invocation with a
     * function call where we can warn about WASM code generation not being allowed
     * but actually execute the expression.
     *
     * Note that we don't update `usingIndirectEval`, i.e. we don't abort a production build
     * since we can't determine statically if the first parameter is a module (legit use) or
     * a buffer (dynamic code generation).
     */ const handleWrapWasmInstantiateExpression = (expr)=>{
            if (!isInMiddlewareLayer(parser)) {
                return;
            }
            if (dev) {
                const { ConstDependency } = wp.dependencies;
                const dep1 = new ConstDependency('__next_webassembly_instantiate__(function() { return ', expr.range[0]);
                dep1.loc = expr.loc;
                parser.state.module.addPresentationalDependency(dep1);
                const dep2 = new ConstDependency('})', expr.range[1]);
                dep2.loc = expr.loc;
                parser.state.module.addPresentationalDependency(dep2);
            }
        };
        /**
     * Handler to store original source location of static and dynamic imports into module's buildInfo.
     */ const handleImport = (node)=>{
            var _node_source;
            if (isInMiddlewareLayer(parser) && ((_node_source = node.source) == null ? void 0 : _node_source.value) && (node == null ? void 0 : node.loc)) {
                var _node_source_value;
                const { module: module1, source } = parser.state;
                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);
                if (!buildInfo.importLocByPath) {
                    buildInfo.importLocByPath = new Map();
                }
                const importedModule = (_node_source_value = node.source.value) == null ? void 0 : _node_source_value.toString();
                buildInfo.importLocByPath.set(importedModule, {
                    sourcePosition: {
                        ...node.loc.start,
                        source: module1.identifier()
                    },
                    sourceContent: source.toString()
                });
                if (!dev && isNodeJsModule(importedModule) && !SUPPORTED_NATIVE_MODULES.includes(importedModule)) {
                    compilation.warnings.push(buildWebpackError({
                        message: `A Node.js module is loaded ('${importedModule}' at line ${node.loc.start.line}) which is not supported in the Edge Runtime.
Learn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`,
                        compilation,
                        parser,
                        ...node
                    }));
                }
            }
        };
        /**
     * A noop handler to skip analyzing some cases.
     * Order matters: for it to work, it must be registered first
     */ const skip = ()=>isInMiddlewareLayer(parser) ? true : undefined;
        for (const prefix of [
            '',
            'global.'
        ]){
            hooks.expression.for(`${prefix}Function.prototype`).tap(NAME, skip);
            hooks.expression.for(`${prefix}Function.bind`).tap(NAME, skip);
            hooks.call.for(`${prefix}eval`).tap(NAME, handleWrapExpression);
            hooks.call.for(`${prefix}Function`).tap(NAME, handleWrapExpression);
            hooks.new.for(`${prefix}Function`).tap(NAME, handleWrapExpression);
            hooks.call.for(`${prefix}WebAssembly.compile`).tap(NAME, handleWrapWasmCompileExpression);
            hooks.call.for(`${prefix}WebAssembly.instantiate`).tap(NAME, handleWrapWasmInstantiateExpression);
        }
        hooks.importCall.tap(NAME, handleImport);
        hooks.import.tap(NAME, handleImport);
        if (!dev) {
            // do not issue compilation warning on dev: invoking code will provide details
            registerUnsupportedApiHooks(parser, compilation);
        }
    };
}
function getExtractMetadata(params) {
    const { dev, compilation, metadataByEntry, compiler } = params;
    const { webpack: wp } = compiler;
    return async ()=>{
        metadataByEntry.clear();
        const telemetry = _shared.traceGlobals.get('telemetry');
        for (const [entryName, entry] of compilation.entries){
            var _entry_dependencies, _route_middlewareConfig;
            if (entry.options.runtime !== _constants.EDGE_RUNTIME_WEBPACK) {
                continue;
            }
            const entryDependency = (_entry_dependencies = entry.dependencies) == null ? void 0 : _entry_dependencies[0];
            const resolvedModule = compilation.moduleGraph.getResolvedModule(entryDependency);
            if (!resolvedModule) {
                continue;
            }
            const { rootDir, route } = (0, _getmodulebuildinfo.getModuleBuildInfo)(resolvedModule);
            const { moduleGraph } = compilation;
            const modules = new Set();
            const addEntriesFromDependency = (dependency)=>{
                const module1 = moduleGraph.getModule(dependency);
                if (module1) {
                    modules.add(module1);
                }
            };
            entry.dependencies.forEach(addEntriesFromDependency);
            entry.includeDependencies.forEach(addEntriesFromDependency);
            const entryMetadata = {
                wasmBindings: new Map(),
                assetBindings: new Map()
            };
            if (route == null ? void 0 : (_route_middlewareConfig = route.middlewareConfig) == null ? void 0 : _route_middlewareConfig.regions) {
                entryMetadata.regions = route.middlewareConfig.regions;
            }
            if (route == null ? void 0 : route.preferredRegion) {
                const preferredRegion = route.preferredRegion;
                entryMetadata.regions = typeof preferredRegion === 'string' ? [
                    preferredRegion
                ] : preferredRegion;
            }
            let ogImageGenerationCount = 0;
            for (const module1 of modules){
                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);
                /**
         * Check if it uses the image generation feature.
         */ if (!dev) {
                    const resource = module1.resource;
                    const hasOGImageGeneration = resource && /[\\/]node_modules[\\/]@vercel[\\/]og[\\/]dist[\\/]index\.(edge|node)\.js$|[\\/]next[\\/]dist[\\/](esm[\\/])?server[\\/]og[\\/]image-response\.js$/.test(resource);
                    if (hasOGImageGeneration) {
                        ogImageGenerationCount++;
                    }
                }
                /**
         * When building for production checks if the module is using `eval`
         * and in such case produces a compilation error. The module has to
         * be in use.
         */ if (!dev && buildInfo.usingIndirectEval && isUsingIndirectEvalAndUsedByExports({
                    module: module1,
                    moduleGraph,
                    runtime: wp.util.runtime.getEntryRuntime(compilation, entryName),
                    usingIndirectEval: buildInfo.usingIndirectEval,
                    wp
                })) {
                    var _route_middlewareConfig1;
                    const id = module1.identifier();
                    if (/node_modules[\\/]regenerator-runtime[\\/]runtime\.js/.test(id)) {
                        continue;
                    }
                    if (route == null ? void 0 : (_route_middlewareConfig1 = route.middlewareConfig) == null ? void 0 : _route_middlewareConfig1.unstable_allowDynamic) {
                        telemetry == null ? void 0 : telemetry.record({
                            eventName: 'NEXT_EDGE_ALLOW_DYNAMIC_USED',
                            payload: {
                                file: route == null ? void 0 : route.absolutePagePath.replace(rootDir ?? '', ''),
                                config: route == null ? void 0 : route.middlewareConfig,
                                fileWithDynamicCode: module1.userRequest.replace(rootDir ?? '', '')
                            }
                        });
                    }
                    if (!isDynamicCodeEvaluationAllowed(module1.userRequest, route == null ? void 0 : route.middlewareConfig, rootDir)) {
                        const message = `Dynamic Code Evaluation (e. g. 'eval', 'new Function', 'WebAssembly.compile') not allowed in Edge Runtime ${typeof buildInfo.usingIndirectEval !== 'boolean' ? `\nUsed by ${Array.from(buildInfo.usingIndirectEval).join(', ')}` : ''}\nLearn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`;
                        compilation.errors.push((0, _parsedynamiccodeevaluationerror.getDynamicCodeEvaluationError)(message, module1, compilation, compiler));
                    }
                }
                /**
         * The entry module has to be either a page or a middleware and hold
         * the corresponding metadata.
         */ if (buildInfo == null ? void 0 : buildInfo.nextEdgeSSR) {
                    entryMetadata.edgeSSR = buildInfo.nextEdgeSSR;
                } else if (buildInfo == null ? void 0 : buildInfo.nextEdgeMiddleware) {
                    entryMetadata.edgeMiddleware = buildInfo.nextEdgeMiddleware;
                } else if (buildInfo == null ? void 0 : buildInfo.nextEdgeApiFunction) {
                    entryMetadata.edgeApiFunction = buildInfo.nextEdgeApiFunction;
                }
                /**
         * If the module is a WASM module we read the binding information and
         * append it to the entry wasm bindings.
         */ if (buildInfo == null ? void 0 : buildInfo.nextWasmMiddlewareBinding) {
                    entryMetadata.wasmBindings.set(buildInfo.nextWasmMiddlewareBinding.name, buildInfo.nextWasmMiddlewareBinding.filePath);
                }
                if (buildInfo == null ? void 0 : buildInfo.nextAssetMiddlewareBinding) {
                    entryMetadata.assetBindings.set(buildInfo.nextAssetMiddlewareBinding.name, buildInfo.nextAssetMiddlewareBinding.filePath);
                }
                /**
         * Append to the list of modules to process outgoingConnections from
         * the module that is being processed.
         */ for (const conn of (0, _utils1.getModuleReferencesInOrder)(module1, moduleGraph)){
                    if (conn.module) {
                        modules.add(conn.module);
                    }
                }
            }
            telemetry == null ? void 0 : telemetry.record({
                eventName: _events.EVENT_BUILD_FEATURE_USAGE,
                payload: {
                    featureName: 'vercelImageGeneration',
                    invocationCount: ogImageGenerationCount
                }
            });
            metadataByEntry.set(entryName, entryMetadata);
        }
    };
}
class MiddlewarePlugin {
    constructor({ dev, sriEnabled, rewrites, edgeEnvironments }){
        this.dev = dev;
        this.sriEnabled = sriEnabled;
        this.rewrites = rewrites;
        this.edgeEnvironments = edgeEnvironments;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(NAME, (compilation, params)=>{
            const { hooks } = params.normalModuleFactory;
            /**
       * This is the static code analysis phase.
       */ const codeAnalyzer = getCodeAnalyzer({
                dev: this.dev,
                compiler,
                compilation
            });
            // parser hooks aren't available in rspack
            if (!process.env.NEXT_RSPACK) {
                hooks.parser.for('javascript/auto').tap(NAME, codeAnalyzer);
                hooks.parser.for('javascript/dynamic').tap(NAME, codeAnalyzer);
                hooks.parser.for('javascript/esm').tap(NAME, codeAnalyzer);
            }
            /**
       * Extract all metadata for the entry points in a Map object.
       */ const metadataByEntry = new Map();
            compilation.hooks.finishModules.tapPromise(NAME, getExtractMetadata({
                compilation,
                compiler,
                dev: this.dev,
                metadataByEntry
            }));
            /**
       * Emit the middleware manifest.
       */ compilation.hooks.processAssets.tap({
                name: 'NextJsMiddlewareManifest',
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, getCreateAssets({
                compilation,
                metadataByEntry,
                opts: {
                    sriEnabled: this.sriEnabled,
                    rewrites: this.rewrites,
                    edgeEnvironments: this.edgeEnvironments,
                    dev: this.dev
                }
            }));
        });
    }
}
const SUPPORTED_NATIVE_MODULES = [
    'buffer',
    'events',
    'assert',
    'util',
    'async_hooks'
];
const supportedEdgePolyfills = new Set(SUPPORTED_NATIVE_MODULES);
function getEdgePolyfilledModules() {
    const records = {};
    for (const mod of SUPPORTED_NATIVE_MODULES){
        records[mod] = `commonjs node:${mod}`;
        records[`node:${mod}`] = `commonjs node:${mod}`;
    }
    return records;
}
async function handleWebpackExternalForEdgeRuntime({ request, context, contextInfo, getResolve }) {
    if ((contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.middleware || contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.apiEdge) && isNodeJsModule(request) && !supportedEdgePolyfills.has(request)) {
        // allows user to provide and use their polyfills, as we do with buffer.
        try {
            await getResolve()(context, request);
        } catch  {
            return `root globalThis.__import_unsupported('${request}')`;
        }
    }
} //# sourceMappingURL=middleware-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/next-drop-client-page-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DropClientPage: null,
    ampFirstEntryNamesMap: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DropClientPage: function() {
        return DropClientPage;
    },
    ampFirstEntryNamesMap: function() {
        return ampFirstEntryNamesMap;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const ampFirstEntryNamesMap = new WeakMap();
const PLUGIN_NAME = 'DropAmpFirstPagesPlugin';
class DropClientPage {
    apply(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory })=>{
            // Recursively look up the issuer till it ends up at the root
            function findEntryModule(mod) {
                const queue = new Set([
                    mod
                ]);
                for (const module1 of queue){
                    const incomingConnections = compilation.moduleGraph.getIncomingConnections(module1);
                    for (const incomingConnection of incomingConnections){
                        if (!incomingConnection.originModule) return module1;
                        queue.add(incomingConnection.originModule);
                    }
                }
                return null;
            }
            function handler(parser) {
                function markAsAmpFirst() {
                    const entryModule = findEntryModule(parser.state.module);
                    if (!entryModule) {
                        return;
                    }
                    // @ts-ignore buildInfo exists on Module
                    entryModule.buildInfo.NEXT_ampFirst = true;
                }
                parser.hooks.preDeclarator.tap(PLUGIN_NAME, (declarator)=>{
                    var _declarator_id;
                    if ((declarator == null ? void 0 : (_declarator_id = declarator.id) == null ? void 0 : _declarator_id.name) === _constants.STRING_LITERAL_DROP_BUNDLE) {
                        markAsAmpFirst();
                    }
                });
            }
            normalModuleFactory.hooks.parser.for('javascript/auto').tap(PLUGIN_NAME, handler);
            normalModuleFactory.hooks.parser.for('javascript/esm').tap(PLUGIN_NAME, handler);
            normalModuleFactory.hooks.parser.for('javascript/dynamic').tap(PLUGIN_NAME, handler);
            if (!ampFirstEntryNamesMap.has(compilation)) {
                ampFirstEntryNamesMap.set(compilation, []);
            }
            const ampFirstEntryNamesItem = ampFirstEntryNamesMap.get(compilation);
            compilation.hooks.seal.tap(PLUGIN_NAME, ()=>{
                for (const [name, entryData] of compilation.entries){
                    for (const dependency of entryData.dependencies){
                        var _module_buildInfo;
                        const module1 = compilation.moduleGraph.getModule(dependency);
                        if (module1 == null ? void 0 : (_module_buildInfo = module1.buildInfo) == null ? void 0 : _module_buildInfo.NEXT_ampFirst) {
                            ampFirstEntryNamesItem.push(name);
                            compilation.entries.delete(name);
                        }
                    }
                }
            });
        });
    }
    constructor(){
        this.ampPages = new Set();
    }
} //# sourceMappingURL=next-drop-client-page-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createEdgeRuntimeManifest: null,
    default: null,
    generateClientManifest: null,
    getEntrypointFiles: null,
    normalizeRewritesForBuildManifest: null,
    processRoute: null,
    srcEmptySsgManifest: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createEdgeRuntimeManifest: function() {
        return createEdgeRuntimeManifest;
    },
    // This plugin creates a build-manifest.json for all assets that are being output
    // It has a mapping of "entry" filename to real filename. Because the real filename can be hashed in production
    default: function() {
        return BuildManifestPlugin;
    },
    generateClientManifest: function() {
        return generateClientManifest;
    },
    getEntrypointFiles: function() {
        return getEntrypointFiles;
    },
    normalizeRewritesForBuildManifest: function() {
        return normalizeRewritesForBuildManifest;
    },
    processRoute: function() {
        return processRoute;
    },
    srcEmptySsgManifest: function() {
        return srcEmptySsgManifest;
    }
});
const _devalue = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/devalue/devalue.umd.js [app-rsc] (ecmascript)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/get-route-from-entrypoint.js [app-rsc] (ecmascript)"));
const _nextdropclientpageplugin = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/next-drop-client-page-plugin.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [app-rsc] (ecmascript)");
const _trace = __turbopack_context__.r("[project]/node_modules/next/dist/trace/index.js [app-rsc] (ecmascript)");
const _utils1 = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const srcEmptySsgManifest = `self.__SSG_MANIFEST=new Set;self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()`;
// nodejs: '/static/<build id>/low-priority.js'
function buildNodejsLowPriorityPath(filename, buildId) {
    return `${_constants.CLIENT_STATIC_FILES_PATH}/${buildId}/${filename}`;
}
function createEdgeRuntimeManifest(originAssetMap) {
    const manifestFilenames = [
        '_buildManifest.js',
        '_ssgManifest.js'
    ];
    const assetMap = {
        ...originAssetMap,
        lowPriorityFiles: []
    };
    // we use globalThis here because middleware can be node
    // which doesn't have "self"
    const manifestDefCode = `globalThis.__BUILD_MANIFEST = ${JSON.stringify(assetMap, null, 2)};\n`;
    // edge lowPriorityFiles item: '"/static/" + process.env.__NEXT_BUILD_ID + "/low-priority.js"'.
    // Since lowPriorityFiles is not fixed and relying on `process.env.__NEXT_BUILD_ID`, we'll produce code creating it dynamically.
    const lowPriorityFilesCode = `globalThis.__BUILD_MANIFEST.lowPriorityFiles = [\n` + manifestFilenames.map((filename)=>{
        return `"/static/" + process.env.__NEXT_BUILD_ID + "/${filename}",\n`;
    }).join(',') + `\n];`;
    return manifestDefCode + lowPriorityFilesCode;
}
function normalizeRewrite(item) {
    return {
        has: item.has,
        source: item.source,
        destination: item.destination
    };
}
function normalizeRewritesForBuildManifest(rewrites) {
    var _rewrites_afterFiles_map, _rewrites_afterFiles, _rewrites_beforeFiles_map, _rewrites_beforeFiles, _rewrites_fallback_map, _rewrites_fallback;
    return {
        afterFiles: (_rewrites_afterFiles = rewrites.afterFiles) == null ? void 0 : (_rewrites_afterFiles_map = _rewrites_afterFiles.map(processRoute)) == null ? void 0 : _rewrites_afterFiles_map.map((item)=>normalizeRewrite(item)),
        beforeFiles: (_rewrites_beforeFiles = rewrites.beforeFiles) == null ? void 0 : (_rewrites_beforeFiles_map = _rewrites_beforeFiles.map(processRoute)) == null ? void 0 : _rewrites_beforeFiles_map.map((item)=>normalizeRewrite(item)),
        fallback: (_rewrites_fallback = rewrites.fallback) == null ? void 0 : (_rewrites_fallback_map = _rewrites_fallback.map(processRoute)) == null ? void 0 : _rewrites_fallback_map.map((item)=>normalizeRewrite(item))
    };
}
function generateClientManifest(assetMap, rewrites, clientRouterFilters, compiler, compilation) {
    const compilationSpan = compilation ? (0, _utils1.getCompilationSpan)(compilation) : compiler ? (0, _utils1.getCompilationSpan)(compiler) : new _trace.Span({
        name: 'client-manifest'
    });
    const genClientManifestSpan = compilationSpan == null ? void 0 : compilationSpan.traceChild('NextJsBuildManifest-generateClientManifest');
    return genClientManifestSpan == null ? void 0 : genClientManifestSpan.traceFn(()=>{
        const clientManifest = {
            __rewrites: normalizeRewritesForBuildManifest(rewrites),
            __routerFilterStatic: clientRouterFilters == null ? void 0 : clientRouterFilters.staticFilter,
            __routerFilterDynamic: clientRouterFilters == null ? void 0 : clientRouterFilters.dynamicFilter
        };
        const appDependencies = new Set(assetMap.pages['/_app']);
        const sortedPageKeys = (0, _utils.getSortedRoutes)(Object.keys(assetMap.pages));
        sortedPageKeys.forEach((page)=>{
            const dependencies = assetMap.pages[page];
            if (page === '/_app') return;
            // Filter out dependencies in the _app entry, because those will have already
            // been loaded by the client prior to a navigation event
            const filteredDeps = dependencies.filter((dep)=>!appDependencies.has(dep));
            // The manifest can omit the page if it has no requirements
            if (filteredDeps.length) {
                clientManifest[page] = filteredDeps;
            }
        });
        // provide the sorted pages as an array so we don't rely on the object's keys
        // being in order and we don't slow down look-up time for page assets
        clientManifest.sortedPages = sortedPageKeys;
        return (0, _devalue.default)(clientManifest);
    });
}
function getEntrypointFiles(entrypoint) {
    return (entrypoint == null ? void 0 : entrypoint.getFiles().filter((file)=>{
        // We don't want to include `.hot-update.js` files into the initial page
        return /(?<!\.hot-update)\.(js|css)($|\?)/.test(file);
    }).map((file)=>file.replace(/\\/g, '/'))) ?? [];
}
const processRoute = (r)=>{
    var _rewrite_destination;
    const rewrite = {
        ...r
    };
    // omit external rewrite destinations since these aren't
    // handled client-side
    if (!(rewrite == null ? void 0 : (_rewrite_destination = rewrite.destination) == null ? void 0 : _rewrite_destination.startsWith('/'))) {
        delete rewrite.destination;
    }
    return rewrite;
};
class BuildManifestPlugin {
    constructor(options){
        this.buildId = options.buildId;
        this.isDevFallback = !!options.isDevFallback;
        this.rewrites = {
            beforeFiles: [],
            afterFiles: [],
            fallback: []
        };
        this.appDirEnabled = options.appDirEnabled;
        this.clientRouterFilters = options.clientRouterFilters;
        this.rewrites.beforeFiles = options.rewrites.beforeFiles.map(processRoute);
        this.rewrites.afterFiles = options.rewrites.afterFiles.map(processRoute);
        this.rewrites.fallback = options.rewrites.fallback.map(processRoute);
    }
    createAssets(compiler, compilation) {
        const compilationSpan = (0, _utils1.getCompilationSpan)(compilation) ?? (0, _utils1.getCompilationSpan)(compiler);
        if (!compilationSpan) {
            throw Object.defineProperty(new Error('No span found for compilation'), "__NEXT_ERROR_CODE", {
                value: "E646",
                enumerable: false,
                configurable: true
            });
        }
        const createAssetsSpan = compilationSpan.traceChild('NextJsBuildManifest-createassets');
        return createAssetsSpan.traceFn(()=>{
            const entrypoints = compilation.entrypoints;
            const assetMap = {
                polyfillFiles: [],
                devFiles: [],
                ampDevFiles: [],
                lowPriorityFiles: [],
                rootMainFiles: [],
                rootMainFilesTree: {},
                pages: {
                    '/_app': []
                },
                ampFirstPages: []
            };
            const ampFirstEntryNames = _nextdropclientpageplugin.ampFirstEntryNamesMap.get(compilation);
            if (ampFirstEntryNames) {
                for (const entryName of ampFirstEntryNames){
                    const pagePath = (0, _getroutefromentrypoint.default)(entryName);
                    if (!pagePath) {
                        continue;
                    }
                    assetMap.ampFirstPages.push(pagePath);
                }
            }
            const mainFiles = new Set(getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN)));
            if (this.appDirEnabled) {
                assetMap.rootMainFiles = [
                    ...new Set(getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)))
                ];
            }
            const compilationAssets = compilation.getAssets();
            assetMap.polyfillFiles = compilationAssets.filter((p)=>{
                // Ensure only .js files are passed through
                if (!p.name.endsWith('.js')) {
                    return false;
                }
                return p.info && _constants.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL in p.info;
            }).map((v)=>v.name);
            assetMap.devFiles = getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH)).filter((file)=>!mainFiles.has(file));
            assetMap.ampDevFiles = getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_AMP));
            for (const entrypoint of compilation.entrypoints.values()){
                if (_constants.SYSTEM_ENTRYPOINTS.has(entrypoint.name)) continue;
                const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name);
                if (!pagePath) {
                    continue;
                }
                const filesForPage = getEntrypointFiles(entrypoint);
                assetMap.pages[pagePath] = [
                    ...new Set([
                        ...mainFiles,
                        ...filesForPage
                    ])
                ];
            }
            if (!this.isDevFallback) {
                // Add the runtime build manifest file (generated later in this file)
                // as a dependency for the app. If the flag is false, the file won't be
                // downloaded by the client.
                const buildManifestPath = buildNodejsLowPriorityPath('_buildManifest.js', this.buildId);
                const ssgManifestPath = buildNodejsLowPriorityPath('_ssgManifest.js', this.buildId);
                assetMap.lowPriorityFiles.push(buildManifestPath, ssgManifestPath);
                compilation.emitAsset(ssgManifestPath, new _webpack.sources.RawSource(srcEmptySsgManifest));
            }
            assetMap.pages = Object.keys(assetMap.pages).sort().reduce((a, c)=>(a[c] = assetMap.pages[c], a), {});
            let buildManifestName = _constants.BUILD_MANIFEST;
            if (this.isDevFallback) {
                buildManifestName = `fallback-${_constants.BUILD_MANIFEST}`;
            }
            compilation.emitAsset(buildManifestName, new _webpack.sources.RawSource(JSON.stringify(assetMap, null, 2)));
            compilation.emitAsset(`server/${_constants.MIDDLEWARE_BUILD_MANIFEST}.js`, new _webpack.sources.RawSource(`${createEdgeRuntimeManifest(assetMap)}`));
            if (!this.isDevFallback) {
                compilation.emitAsset(`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.js`, new _webpack.sources.RawSource(`self.__BUILD_MANIFEST = ${generateClientManifest(assetMap, this.rewrites, this.clientRouterFilters, compiler, compilation)};self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB()`));
            }
        });
    }
    apply(compiler) {
        compiler.hooks.make.tap('NextJsBuildManifest', (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: 'NextJsBuildManifest',
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>{
                this.createAssets(compiler, compilation);
            });
        });
        return;
    }
} //# sourceMappingURL=build-manifest-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/jsconfig-paths-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This webpack resolver is largely based on TypeScript's "paths" handling
 * The TypeScript license can be found here:
 * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    JsConfigPathsPlugin: null,
    findBestPatternMatch: null,
    hasZeroOrOneAsteriskCharacter: null,
    isString: null,
    matchPatternOrExact: null,
    matchedText: null,
    pathIsRelative: null,
    patternText: null,
    tryParsePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    JsConfigPathsPlugin: function() {
        return JsConfigPathsPlugin;
    },
    findBestPatternMatch: function() {
        return findBestPatternMatch;
    },
    hasZeroOrOneAsteriskCharacter: function() {
        return hasZeroOrOneAsteriskCharacter;
    },
    isString: function() {
        return isString;
    },
    matchPatternOrExact: function() {
        return matchPatternOrExact;
    },
    matchedText: function() {
        return matchedText;
    },
    pathIsRelative: function() {
        return pathIsRelative;
    },
    patternText: function() {
        return patternText;
    },
    tryParsePattern: function() {
        return tryParsePattern;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _debug = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/debug/index.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const log = (0, _debug.debug)('next:jsconfig-paths-plugin');
const asterisk = 0x2a;
function hasZeroOrOneAsteriskCharacter(str) {
    let seenAsterisk = false;
    for(let i = 0; i < str.length; i++){
        if (str.charCodeAt(i) === asterisk) {
            if (!seenAsterisk) {
                seenAsterisk = true;
            } else {
                // have already seen asterisk
                return false;
            }
        }
    }
    return true;
}
function pathIsRelative(testPath) {
    return /^\.\.?($|[\\/])/.test(testPath);
}
function tryParsePattern(pattern) {
    // This should be verified outside of here and a proper error thrown.
    const indexOfStar = pattern.indexOf('*');
    return indexOfStar === -1 ? undefined : {
        prefix: pattern.slice(0, indexOfStar),
        suffix: pattern.slice(indexOfStar + 1)
    };
}
function isPatternMatch({ prefix, suffix }, candidate) {
    return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);
}
function findBestPatternMatch(values, getPattern, candidate) {
    let matchedValue;
    // use length of prefix as betterness criteria
    let longestMatchPrefixLength = -1;
    for (const v of values){
        const pattern = getPattern(v);
        if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {
            longestMatchPrefixLength = pattern.prefix.length;
            matchedValue = v;
        }
    }
    return matchedValue;
}
function matchPatternOrExact(patternStrings, candidate) {
    const patterns = [];
    for (const patternString of patternStrings){
        if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;
        const pattern = tryParsePattern(patternString);
        if (pattern) {
            patterns.push(pattern);
        } else if (patternString === candidate) {
            // pattern was matched as is - no need to search further
            return patternString;
        }
    }
    return findBestPatternMatch(patterns, (_)=>_, candidate);
}
function isString(text) {
    return typeof text === 'string';
}
function matchedText(pattern, candidate) {
    return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);
}
function patternText({ prefix, suffix }) {
    return `${prefix}*${suffix}`;
}
/**
 * Calls the iterator function for each entry of the array
 * until the first result or error is reached
 */ function forEachBail(array, iterator, callback) {
    if (array.length === 0) return callback();
    let i = 0;
    const next = ()=>{
        let loop = undefined;
        iterator(array[i++], (err, result)=>{
            if (err || result !== undefined || i >= array.length) {
                return callback(err, result);
            }
            if (loop === false) while(next());
            loop = true;
        });
        if (!loop) loop = false;
        return loop;
    };
    while(next());
}
const NODE_MODULES_REGEX = /node_modules/;
class JsConfigPathsPlugin {
    constructor(paths, resolvedBaseUrl){
        this.paths = paths;
        this.resolvedBaseUrl = resolvedBaseUrl;
        this.jsConfigPlugin = true;
        log('tsconfig.json or jsconfig.json paths: %O', paths);
        log('resolved baseUrl: %s', resolvedBaseUrl);
    }
    apply(resolver) {
        const target = resolver.ensureHook('resolve');
        resolver.getHook('described-resolve').tapAsync('JsConfigPathsPlugin', (request, resolveContext, callback)=>{
            const resolvedBaseUrl = this.resolvedBaseUrl;
            if (resolvedBaseUrl === undefined) {
                return callback();
            }
            const paths = this.paths;
            const pathsKeys = Object.keys(paths);
            // If no aliases are added bail out
            if (pathsKeys.length === 0) {
                log('paths are empty, bailing out');
                return callback();
            }
            const moduleName = request.request;
            // Exclude node_modules from paths support (speeds up resolving)
            if (request.path.match(NODE_MODULES_REGEX)) {
                log('skipping request as it is inside node_modules %s', moduleName);
                return callback();
            }
            if (_path.default.posix.isAbsolute(moduleName) || process.platform === 'win32' && _path.default.win32.isAbsolute(moduleName)) {
                log('skipping request as it is an absolute path %s', moduleName);
                return callback();
            }
            if (pathIsRelative(moduleName)) {
                log('skipping request as it is a relative path %s', moduleName);
                return callback();
            }
            // log('starting to resolve request %s', moduleName)
            // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack
            const matchedPattern = matchPatternOrExact(pathsKeys, moduleName);
            if (!matchedPattern) {
                log('moduleName did not match any paths pattern %s', moduleName);
                return callback();
            }
            const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);
            const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);
            let triedPaths = [];
            forEachBail(paths[matchedPatternText], (subst, pathCallback)=>{
                const curPath = matchedStar ? subst.replace('*', matchedStar) : subst;
                // Ensure .d.ts is not matched
                if (curPath.endsWith('.d.ts')) {
                    // try next path candidate
                    return pathCallback();
                }
                const candidate = _path.default.join(resolvedBaseUrl.baseUrl, curPath);
                const obj = Object.assign({}, request, {
                    request: candidate
                });
                resolver.doResolve(target, obj, `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`, resolveContext, (resolverErr, resolverResult)=>{
                    if (resolverErr || resolverResult === undefined) {
                        triedPaths.push(candidate);
                        // try next path candidate
                        return pathCallback();
                    }
                    return pathCallback(resolverErr, resolverResult);
                });
            }, callback);
        });
    }
} //# sourceMappingURL=jsconfig-paths-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/pages-manifest-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    edgeServerAppPaths: null,
    edgeServerPages: null,
    nodeServerAppPaths: null,
    nodeServerPages: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    // This plugin creates a pages-manifest.json from page entrypoints.
    // This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR
    // It's also used by next export to provide defaultPathMap
    default: function() {
        return PagesManifestPlugin;
    },
    edgeServerAppPaths: function() {
        return edgeServerAppPaths;
    },
    edgeServerPages: function() {
        return edgeServerPages;
    },
    nodeServerAppPaths: function() {
        return nodeServerAppPaths;
    },
    nodeServerPages: function() {
        return nodeServerPages;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _promises = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/get-route-from-entrypoint.js [app-rsc] (ecmascript)"));
const _normalizepathsep = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let edgeServerPages = {};
let nodeServerPages = {};
let edgeServerAppPaths = {};
let nodeServerAppPaths = {};
class PagesManifestPlugin {
    constructor({ dev, distDir, isEdgeRuntime, appDirEnabled }){
        this.dev = dev;
        this.distDir = distDir;
        this.isEdgeRuntime = isEdgeRuntime;
        this.appDirEnabled = appDirEnabled;
    }
    async createAssets(compilation) {
        const entrypoints = compilation.entrypoints;
        const pages = {};
        const appPaths = {};
        for (const entrypoint of entrypoints.values()){
            const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name, this.appDirEnabled);
            if (!pagePath) {
                continue;
            }
            const files = entrypoint.getFiles().filter((file)=>!file.includes('webpack-runtime') && !file.includes('webpack-api-runtime') && file.endsWith('.js'));
            // Skip entries which are empty
            if (!files.length) {
                continue;
            }
            // Write filename, replace any backslashes in path (on windows) with forwardslashes for cross-platform consistency.
            let file = files[files.length - 1];
            if (!this.dev) {
                if (!this.isEdgeRuntime) {
                    file = file.slice(3);
                }
            }
            file = (0, _normalizepathsep.normalizePathSep)(file);
            if (entrypoint.name.startsWith('app/')) {
                appPaths[pagePath] = file;
            } else {
                pages[pagePath] = file;
            }
        }
        // This plugin is used by both the Node server and Edge server compilers,
        // we need to merge both pages to generate the full manifest.
        if (this.isEdgeRuntime) {
            edgeServerPages = pages;
            edgeServerAppPaths = appPaths;
        } else {
            nodeServerPages = pages;
            nodeServerAppPaths = appPaths;
        }
        // handle parallel compilers writing to the same
        // manifest path by merging existing manifest with new
        const writeMergedManifest = async (manifestPath, entries)=>{
            await _promises.default.mkdir(_path.default.dirname(manifestPath), {
                recursive: true
            });
            await _promises.default.writeFile(manifestPath, JSON.stringify({
                ...await _promises.default.readFile(manifestPath, 'utf8').then((res)=>JSON.parse(res)).catch(()=>({})),
                ...entries
            }, null, 2));
        };
        if (this.distDir) {
            const pagesManifestPath = _path.default.join(this.distDir, 'server', _constants.PAGES_MANIFEST);
            await writeMergedManifest(pagesManifestPath, {
                ...edgeServerPages,
                ...nodeServerPages
            });
        } else {
            const pagesManifestPath = (!this.dev && !this.isEdgeRuntime ? '../' : '') + _constants.PAGES_MANIFEST;
            compilation.emitAsset(pagesManifestPath, new _webpack.sources.RawSource(JSON.stringify({
                ...edgeServerPages,
                ...nodeServerPages
            }, null, 2)));
        }
        if (this.appDirEnabled) {
            if (this.distDir) {
                const appPathsManifestPath = _path.default.join(this.distDir, 'server', _constants.APP_PATHS_MANIFEST);
                await writeMergedManifest(appPathsManifestPath, {
                    ...edgeServerAppPaths,
                    ...nodeServerAppPaths
                });
            } else {
                compilation.emitAsset((!this.dev && !this.isEdgeRuntime ? '../' : '') + _constants.APP_PATHS_MANIFEST, new _webpack.sources.RawSource(JSON.stringify({
                    ...edgeServerAppPaths,
                    ...nodeServerAppPaths
                }, null, 2)));
            }
        }
    }
    apply(compiler) {
        compiler.hooks.make.tap('NextJsPagesManifest', (compilation)=>{
            compilation.hooks.processAssets.tapPromise({
                name: 'NextJsPagesManifest',
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>this.createAssets(compilation));
        });
    }
} //# sourceMappingURL=pages-manifest-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/react-loadable-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
COPYRIGHT (c) 2017-present James Kyle <me@thejameskyle.com>
 MIT License
 Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
 The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWAR
*/ // Implementation of this PR: https://github.com/jamiebuilds/react-loadable/pull/132
// Modified to strip out unneeded results for Next's specific use case
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReactLoadablePlugin", {
    enumerable: true,
    get: function() {
        return ReactLoadablePlugin;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function getModuleId(compilation, module) {
    return compilation.chunkGraph.getModuleId(module);
}
function getModuleFromDependency(compilation, dep) {
    return compilation.moduleGraph.getModule(dep);
}
function getOriginModuleFromDependency(compilation, dep) {
    return compilation.moduleGraph.getParentModule(dep);
}
function getChunkGroupFromBlock(compilation, block) {
    return compilation.chunkGraph.getBlockChunkGroup(block);
}
function buildManifest(_compiler, compilation, projectSrcDir, dev, shouldCreateDynamicCssManifest) {
    if (!projectSrcDir) {
        return {
            reactLoadableManifest: {},
            dynamicCssManifest: []
        };
    }
    const dynamicCssManifestSet = new Set();
    let manifest = {};
    // This is allowed:
    // import("./module"); <- ImportDependency
    // We don't support that:
    // import(/* webpackMode: "eager" */ "./module") <- ImportEagerDependency
    // import(`./module/${param}`) <- ImportContextDependency
    // Find all dependencies blocks which contains a `import()` dependency
    const handleBlock = (block)=>{
        block.blocks.forEach(handleBlock);
        const chunkGroup = getChunkGroupFromBlock(compilation, block);
        for (const dependency of block.dependencies){
            if (dependency.type.startsWith('import()')) {
                // get the referenced module
                const module = getModuleFromDependency(compilation, dependency);
                if (!module) return;
                // get the module containing the import()
                const originModule = getOriginModuleFromDependency(compilation, dependency);
                const originRequest = originModule == null ? void 0 : originModule.resource;
                if (!originRequest) return;
                // We construct a "unique" key from origin module and request
                // It's not perfect unique, but that will be fine for us.
                // We also need to construct the same in the babel plugin.
                const key = `${_path.default.relative(projectSrcDir, originRequest)} -> ${dependency.request}`;
                // Capture all files that need to be loaded.
                const files = new Set();
                if (manifest[key]) {
                    // In the "rare" case where multiple chunk groups
                    // are created for the same `import()` or multiple
                    // import()s reference the same module, we merge
                    // the files to make sure to not miss files
                    // This may cause overfetching in edge cases.
                    for (const file of manifest[key].files){
                        files.add(file);
                    }
                }
                // There might not be a chunk group when all modules
                // are already loaded. In this case we only need need
                // the module id and no files
                if (chunkGroup) {
                    for (const chunk of chunkGroup.chunks){
                        chunk.files.forEach((file)=>{
                            if ((file.endsWith('.js') || file.endsWith('.css')) && file.match(/^static\/(chunks|css)\//)) {
                                files.add(file);
                                if (shouldCreateDynamicCssManifest && file.endsWith('.css')) {
                                    dynamicCssManifestSet.add(file);
                                }
                            }
                        });
                    }
                }
                // usually we have to add the parent chunk groups too
                // but we assume that all parents are also imported by
                // next/dynamic so they are loaded by the same technique
                // add the id and files to the manifest
                const id = dev ? key : getModuleId(compilation, module);
                manifest[key] = {
                    id,
                    files: Array.from(files)
                };
            }
        }
    };
    for (const module of compilation.modules){
        module.blocks.forEach(handleBlock);
    }
    manifest = Object.keys(manifest).sort() // eslint-disable-next-line no-sequences
    .reduce((a, c)=>(a[c] = manifest[c], a), {});
    return {
        reactLoadableManifest: manifest,
        dynamicCssManifest: Array.from(dynamicCssManifestSet)
    };
}
class ReactLoadablePlugin {
    constructor(opts){
        this.filename = opts.filename;
        this.pagesOrAppDir = opts.pagesDir || opts.appDir;
        this.isPagesDir = Boolean(opts.pagesDir);
        this.runtimeAsset = opts.runtimeAsset;
        this.dev = opts.dev;
    }
    createAssets(compiler, compilation) {
        const projectSrcDir = this.pagesOrAppDir ? _path.default.dirname(this.pagesOrAppDir) : undefined;
        const shouldCreateDynamicCssManifest = !this.dev && this.isPagesDir;
        const { reactLoadableManifest, dynamicCssManifest } = buildManifest(compiler, compilation, projectSrcDir, this.dev, shouldCreateDynamicCssManifest);
        compilation.emitAsset(this.filename, new _webpack.sources.RawSource(JSON.stringify(reactLoadableManifest, null, 2)));
        if (this.runtimeAsset) {
            compilation.emitAsset(this.runtimeAsset, new _webpack.sources.RawSource(`self.__REACT_LOADABLE_MANIFEST=${JSON.stringify(JSON.stringify(reactLoadableManifest))}`));
        }
        // This manifest prevents removing server rendered <link> tags after client
        // navigation. This is only needed under Pages dir && Production && Webpack.
        // x-ref: https://github.com/vercel/next.js/pull/72959
        if (shouldCreateDynamicCssManifest) {
            compilation.emitAsset(`${_constants.DYNAMIC_CSS_MANIFEST}.json`, new _webpack.sources.RawSource(JSON.stringify(dynamicCssManifest, null, 2)));
            // This is for edge runtime.
            compilation.emitAsset(`server/${_constants.DYNAMIC_CSS_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__DYNAMIC_CSS_MANIFEST=${JSON.stringify(JSON.stringify(dynamicCssManifest))}`));
        }
    }
    apply(compiler) {
        compiler.hooks.make.tap('ReactLoadableManifest', (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: 'ReactLoadableManifest',
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>{
                this.createAssets(compiler, compilation);
            });
        });
    }
} //# sourceMappingURL=react-loadable-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseBabel.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getBabelError", {
    enumerable: true,
    get: function() {
        return getBabelError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
function getBabelError(fileName, err) {
    if (err.code !== 'BABEL_PARSE_ERROR') {
        return false;
    }
    // https://github.com/babel/babel/blob/34693d6024da3f026534dd8d569f97ac0109602e/packages/babel-core/src/parser/index.js
    if (err.loc) {
        const lineNumber = Math.max(1, err.loc.line);
        const column = Math.max(1, err.loc.column);
        let message = err.message // Remove file information, which instead is provided by webpack.
        .replace(/^.+?: /, '') // Remove column information from message
        .replace(new RegExp(`[^\\S\\r\\n]*\\(${lineNumber}:${column}\\)[^\\S\\r\\n]*`), '');
        return new _simpleWebpackError.SimpleWebpackError(`${(0, _picocolors.cyan)(fileName)}:${(0, _picocolors.yellow)(lineNumber.toString())}:${(0, _picocolors.yellow)(column.toString())}`, (0, _picocolors.red)((0, _picocolors.bold)('Syntax error')).concat(`: ${message}`));
    }
    return false;
} //# sourceMappingURL=parseBabel.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseCss.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getCssError", {
    enumerable: true,
    get: function() {
        return getCssError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
const regexCssError = /^(?:CssSyntaxError|SyntaxError)\n\n\((\d+):(\d*)\) (.*)$/s;
function getCssError(fileName, err) {
    if (!((err.name === 'CssSyntaxError' || err.name === 'SyntaxError') && err.stack === false && !(err instanceof SyntaxError))) {
        return false;
    }
    // https://github.com/postcss/postcss-loader/blob/d6931da177ac79707bd758436e476036a55e4f59/src/Error.js
    const res = regexCssError.exec(err.message);
    if (res) {
        const [, _lineNumber, _column, reason] = res;
        const lineNumber = Math.max(1, parseInt(_lineNumber, 10));
        const column = Math.max(1, parseInt(_column, 10));
        return new _simpleWebpackError.SimpleWebpackError(`${(0, _picocolors.cyan)(fileName)}:${(0, _picocolors.yellow)(lineNumber.toString())}:${(0, _picocolors.yellow)(column.toString())}`, (0, _picocolors.red)((0, _picocolors.bold)('Syntax error')).concat(`: ${reason}`));
    }
    return false;
} //# sourceMappingURL=parseCss.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseScss.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getScssError", {
    enumerable: true,
    get: function() {
        return getScssError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
const regexScssError = /SassError: (.+)\n\s+on line (\d+) [\s\S]*?>> (.+)\n\s*(-+)\^$/m;
function getScssError(fileName, fileContent, err) {
    if (err.name !== 'SassError') {
        return false;
    }
    const res = regexScssError.exec(err.message);
    if (res) {
        const [, reason, _lineNumer, backupFrame, columnString] = res;
        const lineNumber = Math.max(1, parseInt(_lineNumer, 10));
        const column = (columnString == null ? void 0 : columnString.length) ?? 1;
        let frame;
        if (fileContent) {
            try {
                const { codeFrameColumns } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/babel/code-frame.js [app-rsc] (ecmascript)");
                frame = codeFrameColumns(fileContent, {
                    start: {
                        line: lineNumber,
                        column
                    }
                }, {
                    forceColor: true
                });
            } catch  {}
        }
        return new _simpleWebpackError.SimpleWebpackError(`${(0, _picocolors.cyan)(fileName)}:${(0, _picocolors.yellow)(lineNumber.toString())}:${(0, _picocolors.yellow)(column.toString())}`, (0, _picocolors.red)((0, _picocolors.bold)('Syntax error')).concat(`: ${reason}\n\n${frame ?? backupFrame}`));
    }
    return false;
} //# sourceMappingURL=parseScss.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNotFoundError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getImageError: null,
    getNotFoundError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getImageError: function() {
        return getImageError;
    },
    getNotFoundError: function() {
        return getNotFoundError;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
const _middlewarewebpack = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/react-dev-overlay/server/middleware-webpack.js [app-rsc] (ecmascript)");
// Based on https://github.com/webpack/webpack/blob/fcdd04a833943394bbb0a9eeb54a962a24cc7e41/lib/stats/DefaultStatsFactoryPlugin.js#L422-L431
/*
Copyright JS Foundation and other contributors

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/ function getModuleTrace(input, compilation) {
    const visitedModules = new Set();
    const moduleTrace = [];
    let current = input.module;
    while(current){
        if (visitedModules.has(current)) break; // circular (technically impossible, but who knows)
        visitedModules.add(current);
        const origin = compilation.moduleGraph.getIssuer(current);
        if (!origin) break;
        moduleTrace.push({
            origin,
            module: current
        });
        current = origin;
    }
    return moduleTrace;
}
async function getSourceFrame(input, fileName, compilation) {
    try {
        const loc = input.loc || input.dependencies.map((d)=>d.loc).filter(Boolean)[0];
        const module1 = input.module;
        const originalSource = module1.originalSource();
        const sourceMap = (originalSource == null ? void 0 : originalSource.map()) ?? undefined;
        if (sourceMap) {
            var _result_originalStackFrame_lineNumber, _result_originalStackFrame, _result_originalStackFrame_column, _result_originalStackFrame1;
            const moduleId = compilation.chunkGraph.getModuleId(module1);
            const result = await (0, _middlewarewebpack.createOriginalStackFrame)({
                source: {
                    type: 'bundle',
                    sourceMap,
                    ignoredSources: (0, _middlewarewebpack.getIgnoredSources)(sourceMap),
                    compilation,
                    moduleId,
                    moduleURL: fileName
                },
                rootDirectory: compilation.options.context,
                frame: {
                    arguments: [],
                    file: fileName,
                    methodName: '',
                    lineNumber: loc.start.line,
                    // loc is 0-based but columns in stack frames are 1-based.
                    column: (loc.start.column ?? 0) + 1
                }
            });
            return {
                frame: (result == null ? void 0 : result.originalCodeFrame) ?? '',
                lineNumber: (result == null ? void 0 : (_result_originalStackFrame = result.originalStackFrame) == null ? void 0 : (_result_originalStackFrame_lineNumber = _result_originalStackFrame.lineNumber) == null ? void 0 : _result_originalStackFrame_lineNumber.toString()) ?? '',
                column: (result == null ? void 0 : (_result_originalStackFrame1 = result.originalStackFrame) == null ? void 0 : (_result_originalStackFrame_column = _result_originalStackFrame1.column) == null ? void 0 : _result_originalStackFrame_column.toString()) ?? ''
            };
        }
    } catch  {}
    return {
        frame: '',
        lineNumber: '',
        column: ''
    };
}
function getFormattedFileName(fileName, module1, lineNumber, column) {
    var _module_loaders;
    if ((_module_loaders = module1.loaders) == null ? void 0 : _module_loaders.find((loader)=>/next-font-loader[/\\]index.js/.test(loader.loader))) {
        // Parse the query and get the path of the file where the font function was called.
        // provided by next-swc next-transform-font
        return JSON.parse(module1.resourceResolveData.query.slice(1)).path;
    } else {
        let formattedFileName = (0, _picocolors.cyan)(fileName);
        if (lineNumber && column) {
            formattedFileName += `:${(0, _picocolors.yellow)(lineNumber)}:${(0, _picocolors.yellow)(column)}`;
        }
        return formattedFileName;
    }
}
async function getNotFoundError(compilation, input, fileName, module1) {
    if (input.name !== 'ModuleNotFoundError' && !(input.name === 'ModuleBuildError' && /Error: Can't resolve '.+' in /.test(input.message))) {
        return false;
    }
    try {
        const { frame, lineNumber, column } = await getSourceFrame(input, fileName, compilation);
        const errorMessage = input.error.message.replace(/ in '.*?'/, '').replace(/Can't resolve '(.*)'/, `Can't resolve '${(0, _picocolors.green)('$1')}'`);
        const importTrace = ()=>{
            const moduleTrace = getModuleTrace(input, compilation).map(({ origin })=>origin.readableIdentifier(compilation.requestShortener)).filter((name)=>name && !/next-(app|middleware|client-pages|route|flight-(client|server|client-entry))-loader/.test(name) && !/css-loader.+\.js/.test(name));
            if (moduleTrace.length === 0) return '';
            return `\nImport trace for requested module:\n${moduleTrace.join('\n')}`;
        };
        let message = (0, _picocolors.red)((0, _picocolors.bold)('Module not found')) + `: ${errorMessage}` + '\n' + frame + (frame !== '' ? '\n' : '') + '\nhttps://nextjs.org/docs/messages/module-not-found\n' + importTrace();
        const formattedFileName = getFormattedFileName(fileName, module1, lineNumber, column);
        return new _simpleWebpackError.SimpleWebpackError(formattedFileName, message);
    } catch (err) {
        // Don't fail on failure to resolve sourcemaps
        return input;
    }
}
async function getImageError(compilation, input, err) {
    if (err.name !== 'InvalidImageFormatError') {
        return false;
    }
    const moduleTrace = getModuleTrace(input, compilation);
    const { origin, module: module1 } = moduleTrace[0] || {};
    if (!origin || !module1) {
        return false;
    }
    const page = origin.rawRequest.replace(/^private-next-pages/, './pages');
    const importedFile = module1.rawRequest;
    const source = origin.originalSource().buffer().toString('utf8');
    let lineNumber = -1;
    source.split('\n').some((line)=>{
        lineNumber++;
        return line.includes(importedFile);
    });
    return new _simpleWebpackError.SimpleWebpackError(`${(0, _picocolors.cyan)(page)}:${(0, _picocolors.yellow)(lineNumber.toString())}`, (0, _picocolors.red)((0, _picocolors.bold)('Error')).concat(`: Image import "${importedFile}" is not a valid image file. The image may be corrupted or an unsupported format.`));
} //# sourceMappingURL=parseNotFoundError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextFontError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextFontError", {
    enumerable: true,
    get: function() {
        return getNextFontError;
    }
});
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
function getNextFontError(err, module) {
    try {
        const resourceResolveData = module.resourceResolveData;
        if (!module.loaders.find((loader)=>/next-font-loader[/\\]index.js/.test(loader.loader))) {
            return false;
        }
        // Parse the query and get the path of the file where the font function was called.
        // provided by next-swc next-transform-font
        const file = JSON.parse(resourceResolveData.query.slice(1)).path;
        if (err.name === 'NextFontError') {
            // Known error thrown by @next/font, display the error message
            return new _simpleWebpackError.SimpleWebpackError(file, `\`next/font\` error:\n${err.message}`);
        } else {
            // Unknown error thrown by @next/font
            return new _simpleWebpackError.SimpleWebpackError(file, `An error occurred in \`next/font\`.\n\n${err.stack}`);
        }
    } catch  {
        return false;
    }
} //# sourceMappingURL=parseNextFontError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextAppLoaderError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextAppLoaderError", {
    enumerable: true,
    get: function() {
        return getNextAppLoaderError;
    }
});
const _path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
const _entries = __turbopack_context__.r("[project]/node_modules/next/dist/build/entries.js [app-rsc] (ecmascript)");
function getNextAppLoaderError(err, module, compiler) {
    try {
        if (!module.loaders[0].loader.includes((0, _entries.getAppLoader)())) {
            return false;
        }
        const file = (0, _path.relative)(compiler.context, module.buildInfo.route.absolutePagePath);
        return new _simpleWebpackError.SimpleWebpackError(file, err.message);
    } catch  {
        return false;
    }
} //# sourceMappingURL=parseNextAppLoaderError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextInvalidImportError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNextInvalidImportError", {
    enumerable: true,
    get: function() {
        return getNextInvalidImportError;
    }
});
const _getModuleTrace = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/getModuleTrace.js [app-rsc] (ecmascript)");
const _simpleWebpackError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/simpleWebpackError.js [app-rsc] (ecmascript)");
function getNextInvalidImportError(err, module, compilation, compiler) {
    try {
        if (!module.loaders.find((loader)=>loader.loader.includes('next-invalid-import-error-loader.js'))) {
            return false;
        }
        const { moduleTrace } = (0, _getModuleTrace.getModuleTrace)(module, compilation, compiler);
        const { formattedModuleTrace, lastInternalFileName, invalidImportMessage } = (0, _getModuleTrace.formatModuleTrace)(compiler, moduleTrace);
        return new _simpleWebpackError.SimpleWebpackError(lastInternalFileName, err.message + invalidImportMessage + '\n\nImport trace for requested module:\n' + formattedModuleTrace);
    } catch  {
        return false;
    }
} //# sourceMappingURL=parseNextInvalidImportError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/webpackModuleError.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getModuleBuildError", {
    enumerable: true,
    get: function() {
        return getModuleBuildError;
    }
});
const _fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const _path = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _parseBabel = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseBabel.js [app-rsc] (ecmascript)");
const _parseCss = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseCss.js [app-rsc] (ecmascript)");
const _parseScss = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseScss.js [app-rsc] (ecmascript)");
const _parseNotFoundError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNotFoundError.js [app-rsc] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-rsc] (ecmascript)"));
const _parseNextFontError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextFontError.js [app-rsc] (ecmascript)");
const _parseNextAppLoaderError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextAppLoaderError.js [app-rsc] (ecmascript)");
const _parseNextInvalidImportError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/parseNextInvalidImportError.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function getFileData(compilation, m) {
    var _compilation_compiler;
    let resolved;
    let ctx = ((_compilation_compiler = compilation.compiler) == null ? void 0 : _compilation_compiler.context) ?? null;
    if (ctx !== null && typeof m.resource === 'string') {
        const res = _path.relative(ctx, m.resource).replace(/\\/g, _path.posix.sep);
        resolved = res.startsWith('.') ? res : `.${_path.posix.sep}${res}`;
    } else {
        const requestShortener = compilation.requestShortener;
        if (typeof (m == null ? void 0 : m.readableIdentifier) === 'function') {
            resolved = m.readableIdentifier(requestShortener);
        } else {
            resolved = m.request ?? m.userRequest;
        }
    }
    if (resolved) {
        let content = null;
        try {
            content = (0, _fs.readFileSync)(ctx ? _path.resolve(ctx, resolved) : resolved, 'utf8');
        } catch  {}
        return [
            resolved,
            content
        ];
    }
    return [
        '<unknown>',
        null
    ];
}
async function getModuleBuildError(compiler, compilation, input) {
    if (!(typeof input === 'object' && ((input == null ? void 0 : input.name) === 'ModuleBuildError' || (input == null ? void 0 : input.name) === 'ModuleNotFoundError') && Boolean(input.module) && (0, _iserror.default)(input.error))) {
        return false;
    }
    const err = input.error;
    const [sourceFilename, sourceContent] = getFileData(compilation, input.module);
    const notFoundError = await (0, _parseNotFoundError.getNotFoundError)(compilation, input, sourceFilename, input.module);
    if (notFoundError !== false) {
        return notFoundError;
    }
    const imageError = await (0, _parseNotFoundError.getImageError)(compilation, input, err);
    if (imageError !== false) {
        return imageError;
    }
    const babel = (0, _parseBabel.getBabelError)(sourceFilename, err);
    if (babel !== false) {
        return babel;
    }
    const css = (0, _parseCss.getCssError)(sourceFilename, err);
    if (css !== false) {
        return css;
    }
    const scss = (0, _parseScss.getScssError)(sourceFilename, sourceContent, err);
    if (scss !== false) {
        return scss;
    }
    const nextFont = (0, _parseNextFontError.getNextFontError)(err, input.module);
    if (nextFont !== false) {
        return nextFont;
    }
    const nextAppLoader = (0, _parseNextAppLoaderError.getNextAppLoaderError)(err, input.module, compiler);
    if (nextAppLoader !== false) {
        return nextAppLoader;
    }
    const invalidImportError = (0, _parseNextInvalidImportError.getNextInvalidImportError)(err, input.module, compilation, compiler);
    if (invalidImportError !== false) {
        return invalidImportError;
    }
    return false;
} //# sourceMappingURL=webpackModuleError.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "WellKnownErrorsPlugin", {
    enumerable: true,
    get: function() {
        return WellKnownErrorsPlugin;
    }
});
const _webpackModuleError = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/wellknown-errors-plugin/webpackModuleError.js [app-rsc] (ecmascript)");
const NAME = 'WellKnownErrorsPlugin';
class WellKnownErrorsPlugin {
    apply(compiler) {
        compiler.hooks.compilation.tap(NAME, (compilation)=>{
            compilation.hooks.afterSeal.tapPromise(NAME, async ()=>{
                var _compilation_warnings, _compilation_errors;
                if ((_compilation_warnings = compilation.warnings) == null ? void 0 : _compilation_warnings.length) {
                    await Promise.all(compilation.warnings.map(async (warn, i)=>{
                        var _warn_module_context, _warn_module;
                        if (warn.name === 'ModuleDependencyWarning' && ((_warn_module = warn.module) == null ? void 0 : (_warn_module_context = _warn_module.context) == null ? void 0 : _warn_module_context.includes('node_modules'))) {
                            compilation.warnings.splice(i, 1);
                        }
                    }));
                }
                if ((_compilation_errors = compilation.errors) == null ? void 0 : _compilation_errors.length) {
                    await Promise.all(compilation.errors.map(async (err, i)=>{
                        try {
                            const moduleError = await (0, _webpackModuleError.getModuleBuildError)(compiler, compilation, err);
                            if (moduleError !== false) {
                                compilation.errors[i] = moduleError;
                            }
                        } catch (e) {
                            console.log(e);
                        }
                    }));
                }
            });
        });
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/copy-file-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CopyFilePlugin", {
    enumerable: true,
    get: function() {
        return CopyFilePlugin;
    }
});
const _fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const _loaderutils3 = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/loader-utils3/index.js [app-rsc] (ecmascript)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'CopyFilePlugin';
class CopyFilePlugin {
    constructor({ filePath, cacheKey, name, info }){
        this.filePath = filePath;
        this.cacheKey = cacheKey;
        this.name = name;
        this.info = info;
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{
            const cache = compilation.getCache('CopyFilePlugin');
            const hook = compilation.hooks.processAssets;
            hook.tapPromise({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, async ()=>{
                if (cache) {
                    const cachedResult = await cache.getPromise(this.filePath, this.cacheKey);
                    if (cachedResult) {
                        const { file, source } = cachedResult;
                        compilation.emitAsset(file, source, {
                            ...this.info
                        });
                        return;
                    }
                }
                const content = await _fs.promises.readFile(this.filePath, 'utf8');
                const file = _loaderutils3.default.interpolateName({
                    resourcePath: this.filePath
                }, this.name, {
                    content,
                    context: compiler.context
                });
                const source = new _webpack.sources.RawSource(content);
                if (cache) {
                    await cache.storePromise(this.filePath, this.cacheKey, {
                        file,
                        source
                    });
                }
                compilation.emitAsset(file, source, {
                    ...this.info
                });
            });
        });
    }
} //# sourceMappingURL=copy-file-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/flight-manifest-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ClientReferenceManifestPlugin", {
    enumerable: true,
    get: function() {
        return ClientReferenceManifestPlugin;
    }
});
const _path = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _buildcontext = __turbopack_context__.r("[project]/node_modules/next/dist/build/build-context.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _normalizepagepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-page-path.js [app-rsc] (ecmascript)");
const _deploymentid = __turbopack_context__.r("[project]/node_modules/next/dist/build/deployment-id.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
const _encodeuripath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/encode-uri-path.js [app-rsc] (ecmascript)");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const pluginState = (0, _buildcontext.getProxiedPluginState)({
    ssrModules: {},
    edgeSsrModules: {},
    rscModules: {},
    edgeRscModules: {}
});
function getAppPathRequiredChunks(chunkGroup, excludedFiles) {
    const deploymentIdChunkQuery = (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();
    const chunks = [];
    chunkGroup.chunks.forEach((chunk)=>{
        if (_constants.SYSTEM_ENTRYPOINTS.has(chunk.name || '')) {
            return null;
        }
        // Get the actual chunk file names from the chunk file list.
        // It's possible that the chunk is generated via `import()`, in
        // that case the chunk file name will be '[name].[contenthash]'
        // instead of '[name]-[chunkhash]'.
        if (chunk.id != null) {
            const chunkId = '' + chunk.id;
            chunk.files.forEach((file)=>{
                // It's possible that a chunk also emits CSS files, that will
                // be handled separatedly.
                if (!file.endsWith('.js')) return null;
                if (file.endsWith('.hot-update.js')) return null;
                if (excludedFiles.has(file)) return null;
                // We encode the file as a URI because our server (and many other services such as S3)
                // expect to receive reserved characters such as `[` and `]` as encoded. This was
                // previously done for dynamic chunks by patching the webpack runtime but we want
                // these filenames to be managed by React's Flight runtime instead and so we need
                // to implement any special handling of the file name here.
                return chunks.push(chunkId, (0, _encodeuripath.encodeURIPath)(file) + deploymentIdChunkQuery);
            });
        }
    });
    return chunks;
}
// Normalize the entry names to their "group names" so a page can easily track
// all the manifest items it needs from parent groups by looking up the group
// segments:
// - app/foo/loading -> app/foo
// - app/foo/page -> app/foo
// - app/(group)/@named/foo/page -> app/foo
// - app/(.)foo/(..)bar/loading -> app/bar
// - app/[...catchAll]/page -> app
// - app/foo/@slot/[...catchAll]/page -> app/foo
function entryNameToGroupName(entryName) {
    let groupName = entryName.slice(0, entryName.lastIndexOf('/')) // Remove slots
    .replace(/\/@[^/]+/g, '') // Remove the group with lookahead to make sure it's not interception route
    .replace(/\/\([^/]+\)(?=(\/|$))/g, '') // Remove catch-all routes since they should be part of the parent group that the catch-all would apply to.
    // This is necessary to support parallel routes since multiple page components can be rendered on the same page.
    // In order to do that, we need to ensure that the manifests are merged together by putting them in the same group.
    .replace(/\/\[?\[\.\.\.[^\]]*]]?/g, '');
    // Interception routes
    groupName = groupName.replace(/^.+\/\(\.\.\.\)/g, 'app/').replace(/\/\(\.\)/g, '/');
    // Interception routes (recursive)
    while(/\/[^/]+\/\(\.\.\)/.test(groupName)){
        groupName = groupName.replace(/\/[^/]+\/\(\.\.\)/g, '/');
    }
    return groupName;
}
function mergeManifest(manifest, manifestToMerge) {
    Object.assign(manifest.clientModules, manifestToMerge.clientModules);
    Object.assign(manifest.ssrModuleMapping, manifestToMerge.ssrModuleMapping);
    Object.assign(manifest.edgeSSRModuleMapping, manifestToMerge.edgeSSRModuleMapping);
    Object.assign(manifest.entryCSSFiles, manifestToMerge.entryCSSFiles);
    Object.assign(manifest.rscModuleMapping, manifestToMerge.rscModuleMapping);
    Object.assign(manifest.edgeRscModuleMapping, manifestToMerge.edgeRscModuleMapping);
}
const PLUGIN_NAME = 'ClientReferenceManifestPlugin';
class ClientReferenceManifestPlugin {
    constructor(options){
        this.dev = false;
        this.dev = options.dev;
        this.appDir = options.appDir;
        this.appDirBase = _path.default.dirname(this.appDir) + _path.default.sep;
        this.experimentalInlineCss = options.experimentalInlineCss;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                // Have to be in the optimize stage to run after updating the CSS
                // asset hash via extract mini css plugin.
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH
            }, ()=>this.createAsset(compilation, compiler.context));
        });
    }
    createAsset(compilation, context) {
        var _compilation_entrypoints_get;
        const manifestsPerGroup = new Map();
        const manifestEntryFiles = [];
        const configuredCrossOriginLoading = compilation.outputOptions.crossOriginLoading;
        const crossOriginMode = typeof configuredCrossOriginLoading === 'string' ? configuredCrossOriginLoading === 'use-credentials' ? configuredCrossOriginLoading : '' // === 'anonymous'
         : undefined;
        if (typeof compilation.outputOptions.publicPath !== 'string') {
            throw Object.defineProperty(new Error('Expected webpack publicPath to be a string when using App Router. To customize where static assets are loaded from, use the `assetPrefix` option in next.config.js. If you are customizing your webpack config please make sure you are not modifying or removing the publicPath configuration option'), "__NEXT_ERROR_CODE", {
                value: "E136",
                enumerable: false,
                configurable: true
            });
        }
        const prefix = compilation.outputOptions.publicPath || '';
        // We want to omit any files that will always be loaded on any App Router page
        // because they will already be loaded by the main entrypoint.
        const rootMainFiles = new Set();
        (_compilation_entrypoints_get = compilation.entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)) == null ? void 0 : _compilation_entrypoints_get.getFiles().forEach((file)=>{
            if (/(?<!\.hot-update)\.(js|css)($|\?)/.test(file)) {
                rootMainFiles.add(file.replace(/\\/g, '/'));
            }
        });
        for (let [entryName, entrypoint] of compilation.entrypoints){
            if (entryName === _constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || entryName === _constants.APP_CLIENT_INTERNALS) {
                entryName = '';
            } else if (!/^app[\\/]/.test(entryName)) {
                continue;
            }
            const manifest = {
                moduleLoading: {
                    prefix,
                    crossOrigin: crossOriginMode
                },
                ssrModuleMapping: {},
                edgeSSRModuleMapping: {},
                clientModules: {},
                entryCSSFiles: {},
                rscModuleMapping: {},
                edgeRscModuleMapping: {}
            };
            // Absolute path without the extension
            const chunkEntryName = (this.appDirBase + entryName).replace(/[\\/]/g, _path.default.sep);
            manifest.entryCSSFiles[chunkEntryName] = entrypoint.getFiles().filter((f)=>!f.startsWith('static/css/pages/') && f.endsWith('.css')).map((file)=>{
                const source = compilation.getAsset(file).source.source();
                if (this.experimentalInlineCss && // Inline CSS currently does not work properly with HMR, so we only
                // inline CSS in production.
                !this.dev) {
                    return {
                        inlined: true,
                        path: file,
                        content: typeof source === 'string' ? source : source.toString()
                    };
                }
                return {
                    inlined: false,
                    path: file
                };
            });
            const requiredChunks = getAppPathRequiredChunks(entrypoint, rootMainFiles);
            const recordModule = (modId, mod)=>{
                var _mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;
                let resource = mod.type === 'css/mini-extract' ? mod.identifier().slice(mod.identifier().lastIndexOf('!') + 1) : mod.resource;
                if (!resource) {
                    return;
                }
                const moduleReferences = manifest.clientModules;
                const moduleIdMapping = manifest.ssrModuleMapping;
                const edgeModuleIdMapping = manifest.edgeSSRModuleMapping;
                const rscIdMapping = manifest.rscModuleMapping;
                const edgeRscIdMapping = manifest.edgeRscModuleMapping;
                // Note that this isn't that reliable as webpack is still possible to assign
                // additional queries to make sure there's no conflict even using the `named`
                // module ID strategy.
                let ssrNamedModuleId = (0, _path.relative)(context, ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path) || resource);
                const rscNamedModuleId = (0, _path.relative)(context, ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.path) || resource);
                if (!ssrNamedModuleId.startsWith('.')) ssrNamedModuleId = `./${ssrNamedModuleId.replace(/\\/g, '/')}`;
                // The client compiler will always use the CJS Next.js build, so here we
                // also add the mapping for the ESM build (Edge runtime) to consume.
                const esmResource = /[\\/]next[\\/]dist[\\/]/.test(resource) ? resource.replace(/[\\/]next[\\/]dist[\\/]/, '/next/dist/esm/'.replace(/\//g, _path.default.sep)) : null;
                // An extra query param is added to the resource key when it's optimized
                // through the Barrel Loader. That's because the same file might be created
                // as multiple modules (depending on what you import from it).
                // See also: webpack/loaders/next-flight-loader/index.ts.
                if ((_mod_matchResource = mod.matchResource) == null ? void 0 : _mod_matchResource.startsWith(_constants.BARREL_OPTIMIZATION_PREFIX)) {
                    ssrNamedModuleId = (0, _utils.formatBarrelOptimizedResource)(ssrNamedModuleId, mod.matchResource);
                    resource = (0, _utils.formatBarrelOptimizedResource)(resource, mod.matchResource);
                }
                function addClientReference() {
                    var _pluginState_ssrModules_ssrNamedModuleId, _pluginState_edgeSsrModules_ssrNamedModuleId;
                    const isAsync = Boolean(compilation.moduleGraph.isAsync(mod) || ((_pluginState_ssrModules_ssrNamedModuleId = pluginState.ssrModules[ssrNamedModuleId]) == null ? void 0 : _pluginState_ssrModules_ssrNamedModuleId.async) || ((_pluginState_edgeSsrModules_ssrNamedModuleId = pluginState.edgeSsrModules[ssrNamedModuleId]) == null ? void 0 : _pluginState_edgeSsrModules_ssrNamedModuleId.async));
                    const exportName = resource;
                    manifest.clientModules[exportName] = {
                        id: modId,
                        name: '*',
                        chunks: requiredChunks,
                        async: isAsync
                    };
                    if (esmResource) {
                        const edgeExportName = esmResource;
                        manifest.clientModules[edgeExportName] = manifest.clientModules[exportName];
                    }
                }
                function addSSRIdMapping() {
                    const exportName = resource;
                    const moduleInfo = pluginState.ssrModules[ssrNamedModuleId];
                    if (moduleInfo) {
                        moduleIdMapping[modId] = moduleIdMapping[modId] || {};
                        moduleIdMapping[modId]['*'] = {
                            ...manifest.clientModules[exportName],
                            // During SSR, we don't have external chunks to load on the server
                            // side with our architecture of Webpack / Turbopack. We can keep
                            // this field empty to save some bytes.
                            chunks: [],
                            id: moduleInfo.moduleId,
                            async: moduleInfo.async
                        };
                    }
                    const edgeModuleInfo = pluginState.edgeSsrModules[ssrNamedModuleId];
                    if (edgeModuleInfo) {
                        edgeModuleIdMapping[modId] = edgeModuleIdMapping[modId] || {};
                        edgeModuleIdMapping[modId]['*'] = {
                            ...manifest.clientModules[exportName],
                            // During SSR, we don't have external chunks to load on the server
                            // side with our architecture of Webpack / Turbopack. We can keep
                            // this field empty to save some bytes.
                            chunks: [],
                            id: edgeModuleInfo.moduleId,
                            async: edgeModuleInfo.async
                        };
                    }
                }
                function addRSCIdMapping() {
                    const exportName = resource;
                    const moduleInfo = pluginState.rscModules[rscNamedModuleId];
                    if (moduleInfo) {
                        rscIdMapping[modId] = rscIdMapping[modId] || {};
                        rscIdMapping[modId]['*'] = {
                            ...manifest.clientModules[exportName],
                            // During SSR, we don't have external chunks to load on the server
                            // side with our architecture of Webpack / Turbopack. We can keep
                            // this field empty to save some bytes.
                            chunks: [],
                            id: moduleInfo.moduleId,
                            async: moduleInfo.async
                        };
                    }
                    const edgeModuleInfo = pluginState.ssrModules[rscNamedModuleId];
                    if (edgeModuleInfo) {
                        edgeRscIdMapping[modId] = edgeRscIdMapping[modId] || {};
                        edgeRscIdMapping[modId]['*'] = {
                            ...manifest.clientModules[exportName],
                            // During SSR, we don't have external chunks to load on the server
                            // side with our architecture of Webpack / Turbopack. We can keep
                            // this field empty to save some bytes.
                            chunks: [],
                            id: edgeModuleInfo.moduleId,
                            async: edgeModuleInfo.async
                        };
                    }
                }
                addClientReference();
                addSSRIdMapping();
                addRSCIdMapping();
                manifest.clientModules = moduleReferences;
                manifest.ssrModuleMapping = moduleIdMapping;
                manifest.edgeSSRModuleMapping = edgeModuleIdMapping;
                manifest.rscModuleMapping = rscIdMapping;
                manifest.edgeRscModuleMapping = edgeRscIdMapping;
            };
            const checkedChunkGroups = new Set();
            const checkedChunks = new Set();
            function recordChunkGroup(chunkGroup) {
                // Ensure recursion is stopped if we've already checked this chunk group.
                if (checkedChunkGroups.has(chunkGroup)) return;
                checkedChunkGroups.add(chunkGroup);
                // Only apply following logic to client module requests from client entry,
                // or if the module is marked as client module. That's because other
                // client modules don't need to be in the manifest at all as they're
                // never be referenced by the server/client boundary.
                // This saves a lot of bytes in the manifest.
                chunkGroup.chunks.forEach((chunk)=>{
                    // Ensure recursion is stopped if we've already checked this chunk.
                    if (checkedChunks.has(chunk)) return;
                    checkedChunks.add(chunk);
                    const entryMods = compilation.chunkGraph.getChunkEntryModulesIterable(chunk);
                    for (const mod of entryMods){
                        if (mod.layer !== _constants1.WEBPACK_LAYERS.appPagesBrowser) continue;
                        const request = mod.request;
                        if (!request || !request.includes('next-flight-client-entry-loader.js?')) {
                            continue;
                        }
                        const connections = (0, _utils.getModuleReferencesInOrder)(mod, compilation.moduleGraph);
                        for (const connection of connections){
                            const dependency = connection.dependency;
                            if (!dependency) continue;
                            const clientEntryMod = compilation.moduleGraph.getResolvedModule(dependency);
                            const modId = compilation.chunkGraph.getModuleId(clientEntryMod);
                            if (modId !== null) {
                                recordModule(modId, clientEntryMod);
                            } else {
                                var _connection_module;
                                // If this is a concatenation, register each child to the parent ID.
                                if (((_connection_module = connection.module) == null ? void 0 : _connection_module.constructor.name) === 'ConcatenatedModule') {
                                    const concatenatedMod = connection.module;
                                    const concatenatedModId = compilation.chunkGraph.getModuleId(concatenatedMod);
                                    if (concatenatedModId) {
                                        recordModule(concatenatedModId, clientEntryMod);
                                    }
                                }
                            }
                        }
                    }
                });
                // Walk through all children chunk groups too.
                for (const child of chunkGroup.childrenIterable){
                    recordChunkGroup(child);
                }
            }
            recordChunkGroup(entrypoint);
            // A page's entry name can have extensions. For example, these are both valid:
            // - app/foo/page
            // - app/foo/page.page
            if (/\/page(\.[^/]+)?$/.test(entryName)) {
                manifestEntryFiles.push(entryName.replace(/\/page(\.[^/]+)?$/, '/page'));
            }
            // We also need to create manifests for route handler entrypoints to
            // enable `'use cache'`.
            if (/\/route$/.test(entryName)) {
                manifestEntryFiles.push(entryName);
            }
            const groupName = entryNameToGroupName(entryName);
            if (!manifestsPerGroup.has(groupName)) {
                manifestsPerGroup.set(groupName, []);
            }
            manifestsPerGroup.get(groupName).push(manifest);
        }
        // Generate per-page manifests.
        for (const pageName of manifestEntryFiles){
            const mergedManifest = {
                moduleLoading: {
                    prefix,
                    crossOrigin: crossOriginMode
                },
                ssrModuleMapping: {},
                edgeSSRModuleMapping: {},
                clientModules: {},
                entryCSSFiles: {},
                rscModuleMapping: {},
                edgeRscModuleMapping: {}
            };
            const segments = [
                ...entryNameToGroupName(pageName).split('/'),
                'page'
            ];
            let group = '';
            for (const segment of segments){
                for (const manifest of manifestsPerGroup.get(group) || []){
                    mergeManifest(mergedManifest, manifest);
                }
                group += (group ? '/' : '') + segment;
            }
            const json = JSON.stringify(mergedManifest);
            const pagePath = pageName.replace(/%5F/g, '_');
            const pageBundlePath = (0, _normalizepagepath.normalizePagePath)(pagePath.slice('app'.length));
            compilation.emitAsset('server/app' + pageBundlePath + '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js', new _webpack.sources.RawSource(`globalThis.__RSC_MANIFEST=(globalThis.__RSC_MANIFEST||{});globalThis.__RSC_MANIFEST[${JSON.stringify(pagePath.slice('app'.length))}]=${json}`));
        }
    }
} //# sourceMappingURL=flight-manifest-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getAssumedSourceType: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return transformSource;
    },
    getAssumedSourceType: function() {
        return getAssumedSourceType;
    }
});
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-rsc] (ecmascript)");
const _getpagestaticinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/analysis/get-page-static-info.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const noopHeadPath = "[project]/node_modules/next/dist/client/components/noop-head.js [app-rsc] (ecmascript)";
// For edge runtime it will be aliased to esm version by webpack
const MODULE_PROXY_PATH = 'next/dist/build/webpack/loaders/next-flight-loader/module-proxy';
function getAssumedSourceType(mod, sourceType) {
    var _buildInfo_rsc, _buildInfo_rsc1;
    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod);
    const detectedClientEntryType = buildInfo == null ? void 0 : (_buildInfo_rsc = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc.clientEntryType;
    const clientRefs = (buildInfo == null ? void 0 : (_buildInfo_rsc1 = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc1.clientRefs) || [];
    // It's tricky to detect the type of a client boundary, but we should always
    // use the `module` type when we can, to support `export *` and `export from`
    // syntax in other modules that import this client boundary.
    if (sourceType === 'auto') {
        if (detectedClientEntryType === 'auto') {
            if (clientRefs.length === 0) {
                // If there's zero export detected in the client boundary, and it's the
                // `auto` type, we can safely assume it's a CJS module because it doesn't
                // have ESM exports.
                return 'commonjs';
            } else if (!clientRefs.includes('*')) {
                // Otherwise, we assume it's an ESM module.
                return 'module';
            }
        } else if (detectedClientEntryType === 'cjs') {
            return 'commonjs';
        }
    }
    return sourceType;
}
function transformSource(source, sourceMap) {
    var _module_matchResource, _buildInfo_rsc, _buildInfo_rsc1;
    // Avoid buffer to be consumed
    if (typeof source !== 'string') {
        throw Object.defineProperty(new Error('Expected source to have been transformed to a string.'), "__NEXT_ERROR_CODE", {
            value: "E429",
            enumerable: false,
            configurable: true
        });
    }
    const module1 = this._module;
    // Assign the RSC meta information to buildInfo.
    // Exclude next internal files which are not marked as client files
    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);
    buildInfo.rsc = (0, _getpagestaticinfo.getRSCModuleInformation)(source, true);
    let prefix = '';
    if (process.env.BUILTIN_FLIGHT_CLIENT_ENTRY_PLUGIN) {
        const rscModuleInformationJson = JSON.stringify(buildInfo.rsc);
        prefix = `/* __rspack_internal_rsc_module_information_do_not_use__ ${rscModuleInformationJson} */\n`;
        source = prefix + source;
    }
    // Resource key is the unique identifier for the resource. When RSC renders
    // a client module, that key is used to identify that module across all compiler
    // layers.
    //
    // Usually it's the module's file path + the export name (e.g. `foo.js#bar`).
    // But with Barrel Optimizations, one file can be splitted into multiple modules,
    // so when you import `foo.js#bar` and `foo.js#baz`, they are actually different
    // "foo.js" being created by the Barrel Loader (one only exports `bar`, the other
    // only exports `baz`).
    //
    // Because of that, we must add another query param to the resource key to
    // differentiate them.
    let resourceKey = this.resourcePath;
    if ((_module_matchResource = module1.matchResource) == null ? void 0 : _module_matchResource.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX)) {
        resourceKey = (0, _utils.formatBarrelOptimizedResource)(resourceKey, module1.matchResource);
    }
    // A client boundary.
    if (((_buildInfo_rsc = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc.type) === _constants1.RSC_MODULE_TYPES.client) {
        const assumedSourceType = getAssumedSourceType(module1, sourceTypeFromModule(module1));
        const clientRefs = buildInfo.rsc.clientRefs;
        const stringifiedResourceKey = JSON.stringify(resourceKey);
        if (assumedSourceType === 'module') {
            if (clientRefs.length === 0) {
                return this.callback(null, 'export {}');
            }
            if (clientRefs.includes('*')) {
                this.callback(Object.defineProperty(new Error(`It's currently unsupported to use "export *" in a client boundary. Please use named exports instead.`), "__NEXT_ERROR_CODE", {
                    value: "E46",
                    enumerable: false,
                    configurable: true
                }));
                return;
            }
            let esmSource = prefix + `\
import { registerClientReference } from "react-server-dom-webpack/server.edge";
`;
            for (const ref of clientRefs){
                if (ref === 'default') {
                    esmSource += `export default registerClientReference(
function() { throw new Error(${JSON.stringify(`Attempted to call the default \
export of ${stringifiedResourceKey} from the server, but it's on the client. \
It's not possible to invoke a client function from the server, it can only be \
rendered as a Component or passed to props of a Client Component.`)}); },
${stringifiedResourceKey},
"default",
);\n`;
                } else {
                    esmSource += `export const ${ref} = registerClientReference(
function() { throw new Error(${JSON.stringify(`Attempted to call ${ref}() from \
the server but ${ref} is on the client. It's not possible to invoke a client \
function from the server, it can only be rendered as a Component or passed to \
props of a Client Component.`)}); },
${stringifiedResourceKey},
${JSON.stringify(ref)},
);`;
                }
            }
            return this.callback(null, esmSource, sourceMap);
        } else if (assumedSourceType === 'commonjs') {
            let cjsSource = prefix + `\
const { createProxy } = require("${MODULE_PROXY_PATH}")

module.exports = createProxy(${stringifiedResourceKey})
`;
            return this.callback(null, cjsSource, sourceMap);
        }
    }
    if (((_buildInfo_rsc1 = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc1.type) !== _constants1.RSC_MODULE_TYPES.client) {
        if (noopHeadPath === this.resourcePath) {
            (0, _warnonce.warnOnce)(`Warning: You're using \`next/head\` inside the \`app\` directory, please migrate to the Metadata API. See https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration#step-3-migrating-nexthead for more details.`);
        }
    }
    const replacedSource = source.replace(_constants.RSC_MOD_REF_PROXY_ALIAS, MODULE_PROXY_PATH);
    this.callback(null, replacedSource, sourceMap);
}
function sourceTypeFromModule(module1) {
    const moduleType = module1.type;
    switch(moduleType){
        case 'javascript/auto':
            return 'auto';
        case 'javascript/dynamic':
            return 'script';
        case 'javascript/esm':
            return 'module';
        default:
            throw Object.defineProperty(new Error('Unexpected module type ' + moduleType), "__NEXT_ERROR_CODE", {
                value: "E651",
                enumerable: false,
                configurable: true
            });
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/flight-client-entry-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FlightClientEntryPlugin", {
    enumerable: true,
    get: function() {
        return FlightClientEntryPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _querystring = __turbopack_context__.r("[externals]/querystring [external] (querystring, cjs)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _ondemandentryhandler = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/on-demand-entry-handler.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _constants1 = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/utils.js [app-rsc] (ecmascript)");
const _utils1 = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
const _normalizepathsep = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js [app-rsc] (ecmascript)");
const _buildcontext = __turbopack_context__.r("[project]/node_modules/next/dist/build/build-context.js [app-rsc] (ecmascript)");
const _pagetypes = __turbopack_context__.r("[project]/node_modules/next/dist/lib/page-types.js [app-rsc] (ecmascript)");
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const _nextflightloader = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/index.js [app-rsc] (ecmascript)");
const _isapprouteroute = __turbopack_context__.r("[project]/node_modules/next/dist/lib/is-app-route-route.js [app-rsc] (ecmascript)");
const _ismetadataroute = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/is-metadata-route.js [app-rsc] (ecmascript)");
const _getwebpackbundler = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-webpack-bundler.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'FlightClientEntryPlugin';
const pluginState = (0, _buildcontext.getProxiedPluginState)({
    // A map to track "action" -> "list of bundles".
    serverActions: {},
    edgeServerActions: {},
    serverActionModules: {},
    edgeServerActionModules: {},
    ssrModules: {},
    edgeSsrModules: {},
    rscModules: {},
    edgeRscModules: {},
    injectedClientEntries: {}
});
function deduplicateCSSImportsForEntry(mergedCSSimports) {
    // If multiple entry module connections are having the same CSS import,
    // we only need to have one module to keep track of that CSS import.
    // It is based on the fact that if a page or a layout is rendered in the
    // given entry, all its parent layouts are always rendered too.
    // This can avoid duplicate CSS imports in the generated CSS manifest,
    // for example, if a page and its parent layout are both using the same
    // CSS import, we only need to have the layout to keep track of that CSS
    // import.
    // To achieve this, we need to first collect all the CSS imports from
    // every connection, and deduplicate them in the order of layers from
    // top to bottom. The implementation can be generally described as:
    // - Sort by number of `/` in the request path (the more `/`, the deeper)
    // - When in the same depth, sort by the filename (template < layout < page and others)
    // Sort the connections as described above.
    const sortedCSSImports = Object.entries(mergedCSSimports).sort((a, b)=>{
        const [aPath] = a;
        const [bPath] = b;
        const aDepth = aPath.split('/').length;
        const bDepth = bPath.split('/').length;
        if (aDepth !== bDepth) {
            return aDepth - bDepth;
        }
        const aName = _path.default.parse(aPath).name;
        const bName = _path.default.parse(bPath).name;
        const indexA = [
            'template',
            'layout'
        ].indexOf(aName);
        const indexB = [
            'template',
            'layout'
        ].indexOf(bName);
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
    });
    const dedupedCSSImports = {};
    const trackedCSSImports = new Set();
    for (const [entryName, cssImports] of sortedCSSImports){
        for (const cssImport of cssImports){
            if (trackedCSSImports.has(cssImport)) continue;
            // Only track CSS imports that are in files that can inherit CSS.
            const filename = _path.default.parse(entryName).name;
            if ([
                'template',
                'layout'
            ].includes(filename)) {
                trackedCSSImports.add(cssImport);
            }
            if (!dedupedCSSImports[entryName]) {
                dedupedCSSImports[entryName] = [];
            }
            dedupedCSSImports[entryName].push(cssImport);
        }
    }
    return dedupedCSSImports;
}
class FlightClientEntryPlugin {
    constructor(options){
        this.dev = options.dev;
        this.appDir = options.appDir;
        this.isEdgeServer = options.isEdgeServer;
        this.assetPrefix = !this.dev && !this.isEdgeServer ? '../' : '';
        this.encryptionKey = options.encryptionKey;
        this.webpackRuntime = this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK;
    }
    apply(compiler) {
        compiler.hooks.finishMake.tapPromise(PLUGIN_NAME, (compilation)=>this.createClientEntries(compiler, compilation));
        compiler.hooks.afterCompile.tap(PLUGIN_NAME, (compilation)=>{
            const recordModule = (modId, mod)=>{
                var _mod_resourceResolveData, _mod_resourceResolveData1;
                // Match Resource is undefined unless an import is using the inline match resource syntax
                // https://webpack.js.org/api/loaders/#inline-matchresource
                const modPath = mod.matchResource || ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path);
                const modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.query) || '';
                // query is already part of mod.resource
                // so it's only necessary to add it for matchResource or mod.resourceResolveData
                const modResource = modPath ? modPath.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX) ? (0, _utils1.formatBarrelOptimizedResource)(mod.resource, modPath) : modPath + modQuery : mod.resource;
                if (typeof modId !== 'undefined' && modResource) {
                    if (mod.layer === _constants.WEBPACK_LAYERS.reactServerComponents) {
                        const key = _path.default.relative(compiler.context, modResource).replace(/\/next\/dist\/esm\//, '/next/dist/');
                        const moduleInfo = {
                            moduleId: modId,
                            async: compilation.moduleGraph.isAsync(mod)
                        };
                        if (this.isEdgeServer) {
                            pluginState.edgeRscModules[key] = moduleInfo;
                        } else {
                            pluginState.rscModules[key] = moduleInfo;
                        }
                    }
                }
                if (mod.layer !== _constants.WEBPACK_LAYERS.serverSideRendering) {
                    return;
                }
                // Check mod resource to exclude the empty resource module like virtual module created by next-flight-client-entry-loader
                if (typeof modId !== 'undefined' && modResource) {
                    // Note that this isn't that reliable as webpack is still possible to assign
                    // additional queries to make sure there's no conflict even using the `named`
                    // module ID strategy.
                    let ssrNamedModuleId = _path.default.relative(compiler.context, modResource);
                    if (!ssrNamedModuleId.startsWith('.')) {
                        // TODO use getModuleId instead
                        ssrNamedModuleId = `./${(0, _normalizepathsep.normalizePathSep)(ssrNamedModuleId)}`;
                    }
                    const moduleInfo = {
                        moduleId: modId,
                        async: compilation.moduleGraph.isAsync(mod)
                    };
                    if (this.isEdgeServer) {
                        pluginState.edgeSsrModules[ssrNamedModuleId.replace(/\/next\/dist\/esm\//, '/next/dist/')] = moduleInfo;
                    } else {
                        pluginState.ssrModules[ssrNamedModuleId] = moduleInfo;
                    }
                }
            };
            (0, _utils1.traverseModules)(compilation, (mod, _chunk, _chunkGroup, modId)=>{
                if (modId) recordModule(modId, mod);
            });
        });
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH
            }, ()=>this.createActionAssets(compilation));
        });
    }
    async createClientEntries(compiler, compilation) {
        const addClientEntryAndSSRModulesList = [];
        const createdSSRDependenciesForEntry = {};
        const addActionEntryList = [];
        const actionMapsPerEntry = {};
        const createdActionIds = new Set();
        // For each SC server compilation entry, we need to create its corresponding
        // client component entry.
        (0, _utils1.forEachEntryModule)(compilation, ({ name, entryModule })=>{
            const internalClientComponentEntryImports = {};
            const actionEntryImports = new Map();
            const clientEntriesToInject = [];
            const mergedCSSimports = {};
            for (const connection of (0, _utils1.getModuleReferencesInOrder)(entryModule, compilation.moduleGraph)){
                // Entry can be any user defined entry files such as layout, page, error, loading, etc.
                let entryRequest = connection.dependency.request;
                if (entryRequest.endsWith(_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute)) {
                    const { filePath, isDynamicRouteExtension } = getMetadataRouteResource(entryRequest);
                    if (isDynamicRouteExtension === '1') {
                        entryRequest = filePath;
                    }
                }
                const { clientComponentImports, actionImports, cssImports } = this.collectComponentInfoFromServerEntryDependency({
                    entryRequest,
                    compilation,
                    resolvedModule: connection.resolvedModule
                });
                actionImports.forEach(([dep, actions])=>actionEntryImports.set(dep, actions));
                const isAbsoluteRequest = _path.default.isAbsolute(entryRequest);
                // Next.js internals are put into a separate entry.
                if (!isAbsoluteRequest) {
                    Object.keys(clientComponentImports).forEach((value)=>internalClientComponentEntryImports[value] = new Set());
                    continue;
                }
                // TODO-APP: Enable these lines. This ensures no entrypoint is created for layout/page when there are no client components.
                // Currently disabled because it causes test failures in CI.
                // if (clientImports.length === 0 && actionImports.length === 0) {
                //   continue
                // }
                const relativeRequest = isAbsoluteRequest ? _path.default.relative(compilation.options.context, entryRequest) : entryRequest;
                // Replace file suffix as `.js` will be added.
                // bundlePath will have app/ prefix but not src/.
                // e.g. src/app/foo/page.js -> app/foo/page
                let bundlePath = (0, _normalizepathsep.normalizePathSep)(relativeRequest.replace(/\.[^.\\/]+$/, '').replace(/^src[\\/]/, ''));
                // For metadata routes, the entry name can be used as the bundle path,
                // as it has been normalized already.
                // e.g.
                // When `relativeRequest` is 'src/app/sitemap.js',
                // `appDirRelativeRequest` will be '/sitemap.js'
                // then `isMetadataEntryFile` will be `true`
                const appDirRelativeRequest = relativeRequest.replace(/^src[\\/]/, '').replace(/^app[\\/]/, '/');
                const isMetadataEntryFile = (0, _ismetadataroute.isMetadataRouteFile)(appDirRelativeRequest, _ismetadataroute.DEFAULT_METADATA_ROUTE_EXTENSIONS, true);
                if (isMetadataEntryFile) {
                    bundlePath = name;
                }
                Object.assign(mergedCSSimports, cssImports);
                clientEntriesToInject.push({
                    compiler,
                    compilation,
                    entryName: name,
                    clientComponentImports,
                    bundlePath,
                    absolutePagePath: entryRequest
                });
                // The webpack implementation of writing the client reference manifest relies on all entrypoints writing a page.js even when there is no client components in the page.
                // It needs the file in order to write the reference manifest for the path in the `.next/server` folder.
                // TODO-APP: This could be better handled, however Turbopack does not have the same problem as we resolve client components in a single graph.
                if (name === `app${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}` && bundlePath === 'app/not-found') {
                    clientEntriesToInject.push({
                        compiler,
                        compilation,
                        entryName: name,
                        clientComponentImports: {},
                        bundlePath: `app${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}`,
                        absolutePagePath: entryRequest
                    });
                }
            }
            // Make sure CSS imports are deduplicated before injecting the client entry
            // and SSR modules.
            const dedupedCSSImports = deduplicateCSSImportsForEntry(mergedCSSimports);
            for (const clientEntryToInject of clientEntriesToInject){
                const injected = this.injectClientEntryAndSSRModules({
                    ...clientEntryToInject,
                    clientImports: {
                        ...clientEntryToInject.clientComponentImports,
                        ...(dedupedCSSImports[clientEntryToInject.absolutePagePath] || []).reduce((res, curr)=>{
                            res[curr] = new Set();
                            return res;
                        }, {})
                    }
                });
                // Track all created SSR dependencies for each entry from the server layer.
                if (!createdSSRDependenciesForEntry[clientEntryToInject.entryName]) {
                    createdSSRDependenciesForEntry[clientEntryToInject.entryName] = [];
                }
                createdSSRDependenciesForEntry[clientEntryToInject.entryName].push(injected[3]);
                addClientEntryAndSSRModulesList.push(injected);
            }
            if (!(0, _isapprouteroute.isAppRouteRoute)(name)) {
                // Create internal app
                addClientEntryAndSSRModulesList.push(this.injectClientEntryAndSSRModules({
                    compiler,
                    compilation,
                    entryName: name,
                    clientImports: {
                        ...internalClientComponentEntryImports
                    },
                    bundlePath: _constants1.APP_CLIENT_INTERNALS
                }));
            }
            if (actionEntryImports.size > 0) {
                if (!actionMapsPerEntry[name]) {
                    actionMapsPerEntry[name] = new Map();
                }
                actionMapsPerEntry[name] = new Map([
                    ...actionMapsPerEntry[name],
                    ...actionEntryImports
                ]);
            }
        });
        for (const [name, actionEntryImports] of Object.entries(actionMapsPerEntry)){
            addActionEntryList.push(this.injectActionEntry({
                compiler,
                compilation,
                actions: actionEntryImports,
                entryName: name,
                bundlePath: name,
                createdActionIds
            }));
        }
        // Invalidate in development to trigger recompilation
        const invalidator = (0, _ondemandentryhandler.getInvalidator)(compiler.outputPath);
        // Check if any of the entry injections need an invalidation
        if (invalidator && addClientEntryAndSSRModulesList.some(([shouldInvalidate])=>shouldInvalidate === true)) {
            invalidator.invalidate([
                _constants1.COMPILER_NAMES.client
            ]);
        }
        // Client compiler is invalidated before awaiting the compilation of the SSR
        // and RSC client component entries so that the client compiler is running
        // in parallel to the server compiler.
        await Promise.all(addClientEntryAndSSRModulesList.flatMap((addClientEntryAndSSRModules)=>[
                addClientEntryAndSSRModules[1],
                addClientEntryAndSSRModules[2]
            ]));
        // Wait for action entries to be added.
        await Promise.all(addActionEntryList);
        const addedClientActionEntryList = [];
        const actionMapsPerClientEntry = {};
        // We need to create extra action entries that are created from the
        // client layer.
        // Start from each entry's created SSR dependency from our previous step.
        for (const [name, ssrEntryDependencies] of Object.entries(createdSSRDependenciesForEntry)){
            // Collect from all entries, e.g. layout.js, page.js, loading.js, ...
            // add aggregate them.
            const actionEntryImports = this.collectClientActionsFromDependencies({
                compilation,
                dependencies: ssrEntryDependencies
            });
            if (actionEntryImports.size > 0) {
                if (!actionMapsPerClientEntry[name]) {
                    actionMapsPerClientEntry[name] = new Map();
                }
                actionMapsPerClientEntry[name] = new Map([
                    ...actionMapsPerClientEntry[name],
                    ...actionEntryImports
                ]);
            }
        }
        for (const [entryName, actionEntryImports] of Object.entries(actionMapsPerClientEntry)){
            // If an action method is already created in the server layer, we don't
            // need to create it again in the action layer.
            // This is to avoid duplicate action instances and make sure the module
            // state is shared.
            let remainingClientImportedActions = false;
            const remainingActionEntryImports = new Map();
            for (const [dep, actions] of actionEntryImports){
                const remainingActionNames = [];
                for (const action of actions){
                    if (!createdActionIds.has(entryName + '@' + action.id)) {
                        remainingActionNames.push(action);
                    }
                }
                if (remainingActionNames.length > 0) {
                    remainingActionEntryImports.set(dep, remainingActionNames);
                    remainingClientImportedActions = true;
                }
            }
            if (remainingClientImportedActions) {
                addedClientActionEntryList.push(this.injectActionEntry({
                    compiler,
                    compilation,
                    actions: remainingActionEntryImports,
                    entryName,
                    bundlePath: entryName,
                    fromClient: true,
                    createdActionIds
                }));
            }
        }
        await Promise.all(addedClientActionEntryList);
    }
    collectClientActionsFromDependencies({ compilation, dependencies }) {
        // action file path -> action names
        const collectedActions = new Map();
        // Keep track of checked modules to avoid infinite loops with recursive imports.
        const visitedModule = new Set();
        const visitedEntry = new Set();
        const collectActions = ({ entryRequest, resolvedModule })=>{
            const collectActionsInDep = (mod)=>{
                var _getModuleBuildInfo_rsc;
                if (!mod) return;
                const modResource = getModuleResource(mod);
                if (!modResource) return;
                if (visitedModule.has(modResource)) return;
                visitedModule.add(modResource);
                const actionIds = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.actionIds;
                if (actionIds) {
                    collectedActions.set(modResource, Object.entries(actionIds).map(([id, exportedName])=>({
                            id,
                            exportedName
                        })));
                }
                // Collect used exported actions transversely.
                (0, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=>{
                    collectActionsInDep(connection.resolvedModule);
                });
            };
            // Don't traverse the module graph anymore once hitting the action layer.
            if (entryRequest && !entryRequest.includes('next-flight-action-entry-loader')) {
                // Traverse the module graph to find all client components.
                collectActionsInDep(resolvedModule);
            }
        };
        for (const entryDependency of dependencies){
            const ssrEntryModule = compilation.moduleGraph.getResolvedModule(entryDependency);
            for (const connection of (0, _utils1.getModuleReferencesInOrder)(ssrEntryModule, compilation.moduleGraph)){
                const depModule = connection.dependency;
                const request = depModule.request;
                // It is possible that the same entry is added multiple times in the
                // connection graph. We can just skip these to speed up the process.
                if (visitedEntry.has(request)) continue;
                visitedEntry.add(request);
                collectActions({
                    entryRequest: request,
                    resolvedModule: connection.resolvedModule
                });
            }
        }
        return collectedActions;
    }
    collectComponentInfoFromServerEntryDependency({ entryRequest, compilation, resolvedModule }) {
        // Keep track of checked modules to avoid infinite loops with recursive imports.
        const visitedOfClientComponentsTraverse = new Set();
        // Info to collect.
        const clientComponentImports = {};
        const actionImports = [];
        const CSSImports = new Set();
        const filterClientComponents = (mod, importedIdentifiers)=>{
            var _getModuleBuildInfo_rsc;
            if (!mod) return;
            const modResource = getModuleResource(mod);
            if (!modResource) return;
            if (visitedOfClientComponentsTraverse.has(modResource)) {
                if (clientComponentImports[modResource]) {
                    addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, false);
                }
                return;
            }
            visitedOfClientComponentsTraverse.add(modResource);
            const actionIds = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.actionIds;
            if (actionIds) {
                actionImports.push([
                    modResource,
                    Object.entries(actionIds).map(([id, exportedName])=>({
                            id,
                            exportedName
                        }))
                ]);
            }
            if ((0, _utils.isCSSMod)(mod)) {
                const sideEffectFree = mod.factoryMeta && mod.factoryMeta.sideEffectFree;
                if (sideEffectFree) {
                    const unused = !compilation.moduleGraph.getExportsInfo(mod).isModuleUsed(this.webpackRuntime);
                    if (unused) return;
                }
                CSSImports.add(modResource);
            } else if ((0, _utils.isClientComponentEntryModule)(mod)) {
                if (!clientComponentImports[modResource]) {
                    clientComponentImports[modResource] = new Set();
                }
                addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, true);
                return;
            }
            (0, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=>{
                var _connection_dependency;
                let dependencyIds = [];
                // `ids` are the identifiers that are imported from the dependency,
                // if it's present, it's an array of strings.
                if ((_connection_dependency = connection.dependency) == null ? void 0 : _connection_dependency.ids) {
                    dependencyIds.push(...connection.dependency.ids);
                } else {
                    dependencyIds = [
                        '*'
                    ];
                }
                filterClientComponents(connection.resolvedModule, dependencyIds);
            });
        };
        // Traverse the module graph to find all client components.
        filterClientComponents(resolvedModule, []);
        return {
            clientComponentImports,
            cssImports: CSSImports.size ? {
                [entryRequest]: Array.from(CSSImports)
            } : {},
            actionImports
        };
    }
    injectClientEntryAndSSRModules({ compiler, compilation, entryName, clientImports, bundlePath, absolutePagePath }) {
        const bundler = (0, _getwebpackbundler.default)();
        let shouldInvalidate = false;
        const modules = Object.keys(clientImports).sort((a, b)=>_utils.regexCSS.test(b) ? 1 : a.localeCompare(b)).map((clientImportPath)=>({
                request: clientImportPath,
                ids: [
                    ...clientImports[clientImportPath]
                ]
            }));
        // For the client entry, we always use the CJS build of Next.js. If the
        // server is using the ESM build (when using the Edge runtime), we need to
        // replace them.
        const clientBrowserLoader = `next-flight-client-entry-loader?${(0, _querystring.stringify)({
            modules: (this.isEdgeServer ? modules.map(({ request, ids })=>({
                    request: request.replace(/[\\/]next[\\/]dist[\\/]esm[\\/]/, '/next/dist/'.replace(/\//g, _path.default.sep)),
                    ids
                })) : modules).map((x)=>JSON.stringify(x)),
            server: false
        })}!`;
        const clientServerLoader = `next-flight-client-entry-loader?${(0, _querystring.stringify)({
            modules: modules.map((x)=>JSON.stringify(x)),
            server: true
        })}!`;
        // Add for the client compilation
        // Inject the entry to the client compiler.
        if (this.dev) {
            const entries = (0, _ondemandentryhandler.getEntries)(compiler.outputPath);
            const pageKey = (0, _ondemandentryhandler.getEntryKey)(_constants1.COMPILER_NAMES.client, _pagetypes.PAGE_TYPES.APP, bundlePath);
            if (!entries[pageKey]) {
                entries[pageKey] = {
                    type: _ondemandentryhandler.EntryTypes.CHILD_ENTRY,
                    parentEntries: new Set([
                        entryName
                    ]),
                    absoluteEntryFilePath: absolutePagePath,
                    bundlePath,
                    request: clientBrowserLoader,
                    dispose: false,
                    lastActiveTime: Date.now()
                };
                shouldInvalidate = true;
            } else {
                const entryData = entries[pageKey];
                // New version of the client loader
                if (entryData.request !== clientBrowserLoader) {
                    entryData.request = clientBrowserLoader;
                    shouldInvalidate = true;
                }
                if (entryData.type === _ondemandentryhandler.EntryTypes.CHILD_ENTRY) {
                    entryData.parentEntries.add(entryName);
                }
                entryData.dispose = false;
                entryData.lastActiveTime = Date.now();
            }
        } else {
            pluginState.injectedClientEntries[bundlePath] = clientBrowserLoader;
        }
        const clientComponentSSREntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {
            name: bundlePath
        });
        const clientComponentRSCEntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {
            name: bundlePath
        });
        return [
            shouldInvalidate,
            // Add the entries to the server compiler for the SSR and RSC layers. The
            // promises are awaited later using `Promise.all` in order to parallelize
            // adding the entries.
            this.addEntry(compilation, compiler.context, clientComponentSSREntryDep, {
                name: entryName,
                layer: _constants.WEBPACK_LAYERS.serverSideRendering
            }),
            this.addEntry(compilation, compiler.context, clientComponentRSCEntryDep, {
                name: entryName,
                layer: _constants.WEBPACK_LAYERS.reactServerComponents
            }),
            clientComponentSSREntryDep
        ];
    }
    injectActionEntry({ compiler, compilation, actions, entryName, bundlePath, fromClient, createdActionIds }) {
        const bundler = (0, _getwebpackbundler.default)();
        const actionsArray = Array.from(actions.entries());
        for (const [, actionsFromModule] of actions){
            for (const { id } of actionsFromModule){
                createdActionIds.add(entryName + '@' + id);
            }
        }
        if (actionsArray.length === 0) {
            return Promise.resolve();
        }
        const actionLoader = `next-flight-action-entry-loader?${(0, _querystring.stringify)({
            actions: JSON.stringify(actionsArray),
            __client_imported__: fromClient
        })}!`;
        const currentCompilerServerActions = this.isEdgeServer ? pluginState.edgeServerActions : pluginState.serverActions;
        for (const [, actionsFromModule] of actionsArray){
            for (const { id } of actionsFromModule){
                if (typeof currentCompilerServerActions[id] === 'undefined') {
                    currentCompilerServerActions[id] = {
                        workers: {},
                        layer: {}
                    };
                }
                currentCompilerServerActions[id].workers[bundlePath] = {
                    moduleId: '',
                    async: false
                };
                currentCompilerServerActions[id].layer[bundlePath] = fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents;
            }
        }
        // Inject the entry to the server compiler
        const actionEntryDep = bundler.EntryPlugin.createDependency(actionLoader, {
            name: bundlePath
        });
        return this.addEntry(compilation, compiler.context, actionEntryDep, {
            name: entryName,
            layer: fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents
        });
    }
    addEntry(compilation, context, dependency, options) /* Promise<module> */ {
        return new Promise((resolve, reject)=>{
            if ('rspack' in compilation.compiler) {
                compilation.addInclude(context, dependency, options, (err, module)=>{
                    if (err) {
                        return reject(err);
                    }
                    compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);
                    return resolve(module);
                });
            } else {
                const entry = compilation.entries.get(options.name);
                entry.includeDependencies.push(dependency);
                compilation.hooks.addEntry.call(entry, options);
                compilation.addModuleTree({
                    context,
                    dependency,
                    contextInfo: {
                        issuerLayer: options.layer
                    }
                }, (err, module)=>{
                    if (err) {
                        compilation.hooks.failedEntry.call(dependency, options, err);
                        return reject(err);
                    }
                    compilation.hooks.succeedEntry.call(dependency, options, module);
                    compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);
                    return resolve(module);
                });
            }
        });
    }
    async createActionAssets(compilation) {
        const serverActions = {};
        const edgeServerActions = {};
        (0, _utils1.traverseModules)(compilation, (mod, _chunk, chunkGroup, modId)=>{
            // Go through all action entries and record the module ID for each entry.
            if (chunkGroup.name && mod.request && modId && /next-flight-action-entry-loader/.test(mod.request)) {
                const fromClient = /&__client_imported__=true/.test(mod.request);
                const mapping = this.isEdgeServer ? pluginState.edgeServerActionModules : pluginState.serverActionModules;
                if (!mapping[chunkGroup.name]) {
                    mapping[chunkGroup.name] = {};
                }
                mapping[chunkGroup.name][fromClient ? 'client' : 'server'] = {
                    moduleId: modId,
                    async: compilation.moduleGraph.isAsync(mod)
                };
            }
        });
        for(let id in pluginState.serverActions){
            const action = pluginState.serverActions[id];
            for(let name in action.workers){
                const modId = pluginState.serverActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? 'client' : 'server'];
                action.workers[name] = modId;
            }
            serverActions[id] = action;
        }
        for(let id in pluginState.edgeServerActions){
            const action = pluginState.edgeServerActions[id];
            for(let name in action.workers){
                const modId = pluginState.edgeServerActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? 'client' : 'server'];
                action.workers[name] = modId;
            }
            edgeServerActions[id] = action;
        }
        const serverManifest = {
            node: serverActions,
            edge: edgeServerActions,
            encryptionKey: this.encryptionKey
        };
        const edgeServerManifest = {
            ...serverManifest,
            encryptionKey: 'process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY'
        };
        const json = JSON.stringify(serverManifest, null, this.dev ? 2 : undefined);
        const edgeJson = JSON.stringify(edgeServerManifest, null, this.dev ? 2 : undefined);
        compilation.emitAsset(`${this.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__RSC_SERVER_MANIFEST=${JSON.stringify(edgeJson)}`));
        compilation.emitAsset(`${this.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}.json`, new _webpack.sources.RawSource(json));
    }
}
function addClientImport(mod, modRequest, clientComponentImports, importedIdentifiers, isFirstVisitModule) {
    var _getModuleBuildInfo_rsc;
    const clientEntryType = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.clientEntryType;
    const isCjsModule = clientEntryType === 'cjs';
    const assumedSourceType = (0, _nextflightloader.getAssumedSourceType)(mod, isCjsModule ? 'commonjs' : 'auto');
    const clientImportsSet = clientComponentImports[modRequest];
    if (importedIdentifiers[0] === '*') {
        // If there's collected import path with named import identifiers,
        // or there's nothing in collected imports are empty.
        // we should include the whole module.
        if (!isFirstVisitModule && [
            ...clientImportsSet
        ][0] !== '*') {
            clientComponentImports[modRequest] = new Set([
                '*'
            ]);
        }
    } else {
        const isAutoModuleSourceType = assumedSourceType === 'auto';
        if (isAutoModuleSourceType) {
            clientComponentImports[modRequest] = new Set([
                '*'
            ]);
        } else {
            // If it's not analyzed as named ESM exports, e.g. if it's mixing `export *` with named exports,
            // We'll include all modules since it's not able to do tree-shaking.
            for (const name of importedIdentifiers){
                // For cjs module default import, we include the whole module since
                const isCjsDefaultImport = isCjsModule && name === 'default';
                // Always include __esModule along with cjs module default export,
                // to make sure it work with client module proxy from React.
                if (isCjsDefaultImport) {
                    clientComponentImports[modRequest].add('__esModule');
                }
                clientComponentImports[modRequest].add(name);
            }
        }
    }
}
function getModuleResource(mod) {
    var _mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;
    const modPath = ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path) || '';
    const modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.query) || '';
    // We have to always use the resolved request here to make sure the
    // server and client are using the same module path (required by RSC), as
    // the server compiler and client compiler have different resolve configs.
    let modResource = modPath + modQuery;
    // Context modules don't have a resource path, we use the identifier instead.
    if (mod.constructor.name === 'ContextModule') {
        modResource = mod.identifier();
    }
    // For the barrel optimization, we need to use the match resource instead
    // because there will be 2 modules for the same file (same resource path)
    // but they're different modules and can't be deduped via `visitedModule`.
    // The first module is a virtual re-export module created by the loader.
    if ((_mod_matchResource = mod.matchResource) == null ? void 0 : _mod_matchResource.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX)) {
        modResource = mod.matchResource + ':' + modResource;
    }
    if (mod.resource === `?${_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute}`) {
        return getMetadataRouteResource(mod.rawRequest).filePath;
    }
    return modResource;
}
function getMetadataRouteResource(request) {
    // e.g. next-metadata-route-loader?filePath=<some-url-encoded-path>&isDynamicRouteExtension=1!?__next_metadata_route__
    const query = request.split('!')[0].split('next-metadata-route-loader?')[1];
    return (0, _querystring.parse)(query);
} //# sourceMappingURL=flight-client-entry-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/rspack-flight-client-entry-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RspackFlightClientEntryPlugin", {
    enumerable: true,
    get: function() {
        return RspackFlightClientEntryPlugin;
    }
});
const _ondemandentryhandler = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/on-demand-entry-handler.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _buildcontext = __turbopack_context__.r("[project]/node_modules/next/dist/build/build-context.js [app-rsc] (ecmascript)");
const _pagetypes = __turbopack_context__.r("[project]/node_modules/next/dist/lib/page-types.js [app-rsc] (ecmascript)");
const _getrspack = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-rspack.js [app-rsc] (ecmascript)");
const pluginState = (0, _buildcontext.getProxiedPluginState)({
    // A map to track "action" -> "list of bundles".
    serverActions: {},
    edgeServerActions: {},
    serverActionModules: {},
    edgeServerActionModules: {},
    ssrModules: {},
    edgeSsrModules: {},
    rscModules: {},
    edgeRscModules: {},
    injectedClientEntries: {}
});
class RspackFlightClientEntryPlugin {
    constructor(options){
        const { FlightClientEntryPlugin } = (0, _getrspack.getRspackCore)();
        this.plugin = new FlightClientEntryPlugin({
            ...options,
            builtinAppLoader: !!process.env.BUILTIN_SWC_LOADER,
            shouldInvalidateCb: ({ bundlePath, entryName, absolutePagePath, clientBrowserLoader })=>{
                let shouldInvalidate = false;
                const compiler = this.compiler;
                const entries = (0, _ondemandentryhandler.getEntries)(compiler.outputPath);
                const pageKey = (0, _ondemandentryhandler.getEntryKey)(_constants.COMPILER_NAMES.client, _pagetypes.PAGE_TYPES.APP, bundlePath);
                if (!entries[pageKey]) {
                    entries[pageKey] = {
                        type: _ondemandentryhandler.EntryTypes.CHILD_ENTRY,
                        parentEntries: new Set([
                            entryName
                        ]),
                        absoluteEntryFilePath: absolutePagePath,
                        bundlePath,
                        request: clientBrowserLoader,
                        dispose: false,
                        lastActiveTime: Date.now()
                    };
                    shouldInvalidate = true;
                } else {
                    const entryData = entries[pageKey];
                    // New version of the client loader
                    if (entryData.request !== clientBrowserLoader) {
                        entryData.request = clientBrowserLoader;
                        shouldInvalidate = true;
                    }
                    if (entryData.type === _ondemandentryhandler.EntryTypes.CHILD_ENTRY) {
                        entryData.parentEntries.add(entryName);
                    }
                    entryData.dispose = false;
                    entryData.lastActiveTime = Date.now();
                }
                return shouldInvalidate;
            },
            invalidateCb: ()=>{
                const compiler = this.compiler;
                // Invalidate in development to trigger recompilation
                const invalidator = (0, _ondemandentryhandler.getInvalidator)(compiler.outputPath);
                // Check if any of the entry injections need an invalidation
                if (invalidator) {
                    invalidator.invalidate([
                        _constants.COMPILER_NAMES.client
                    ]);
                }
            },
            stateCb: (state)=>{
                Object.assign(pluginState.serverActions, state.serverActions);
                Object.assign(pluginState.edgeServerActions, state.edgeServerActions);
                Object.assign(pluginState.serverActionModules, state.serverActionModules);
                Object.assign(pluginState.edgeServerActionModules, state.edgeServerActionModules);
                Object.assign(pluginState.ssrModules, state.ssrModules);
                Object.assign(pluginState.edgeSsrModules, state.edgeSsrModules);
                Object.assign(pluginState.rscModules, state.rscModules);
                Object.assign(pluginState.edgeRscModules, state.edgeRscModules);
                Object.assign(pluginState.injectedClientEntries, state.injectedClientEntries);
            }
        });
    }
    apply(compiler) {
        this.compiler = compiler;
        this.plugin.apply(compiler);
    }
} //# sourceMappingURL=rspack-flight-client-entry-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/next-types-plugin/shared.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// TODO: Eliminate this singleton in the future.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "devPageFiles", {
    enumerable: true,
    get: function() {
        return devPageFiles;
    }
});
const devPageFiles = new Set(); //# sourceMappingURL=shared.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/next-types-plugin/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NextTypesPlugin", {
    enumerable: true,
    get: function() {
        return NextTypesPlugin;
    }
});
const _promises = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _pathtoregexp = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-to-regexp/index.js [app-rsc] (ecmascript)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/constants.js [app-rsc] (ecmascript)");
const _denormalizepagepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js [app-rsc] (ecmascript)");
const _ensureleadingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-rsc] (ecmascript)");
const _normalizepathsep = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js [app-rsc] (ecmascript)");
const _http = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/http.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/index.js [app-rsc] (ecmascript)");
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)");
const _entries = __turbopack_context__.r("[project]/node_modules/next/dist/build/entries.js [app-rsc] (ecmascript)");
const _shared = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/next-types-plugin/shared.js [app-rsc] (ecmascript)");
const _buildcontext = __turbopack_context__.r("[project]/node_modules/next/dist/build/build-context.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'NextTypesPlugin';
function createTypeGuardFile(fullPath, relativePath, options) {
    return `// File: ${fullPath}
import * as entry from '${relativePath}.js'
${options.type === 'route' ? `import type { NextRequest } from 'next/server.js'` : `import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'`}

type TEntry = typeof import('${relativePath}.js')

type SegmentParams<T extends Object = any> = T extends Record<string, any>
  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
  : T

// Check that the entry is a valid entry
checkFields<Diff<{
  ${options.type === 'route' ? _http.HTTP_METHODS.map((method)=>`${method}?: Function`).join('\n  ') : 'default: Function'}
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  ${options.type === 'route' ? '' : `
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  experimental_ppr?: boolean
  `}
}, TEntry, ''>>()

${options.type === 'route' ? `type RouteContext = { params: Promise<SegmentParams> }` : ''}
${options.type === 'route' ? _http.HTTP_METHODS.map((method)=>`// Check the prop type of the entry function
if ('${method}' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: '${method}'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, '${method}'>>
      },
      '${method}'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<RouteContext>,
      {
        __tag__: '${method}'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, '${method}'>>
      },
      '${method}'
    >
  >()
  ${''}
  checkFields<
    Diff<
      {
        __tag__: '${method}',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: '${method}',
        __return_type__: ReturnType<MaybeField<TEntry, '${method}'>>
      },
      '${method}'
    >
  >()
}
`).join('') : `// Check the prop type of the entry function
checkFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}
`}
// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

export interface PageProps {
  params?: Promise<SegmentParams>
  searchParams?: Promise<any>
}
export interface LayoutProps {
  children?: React.ReactNode
${options.slots ? options.slots.map((slot)=>`  ${slot}: React.ReactNode`).join('\n') : ''}
  params?: Promise<SegmentParams>
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

${options.type === 'route' ? `type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}` : ''}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : \`\${T}\` extends \`-\${string}\` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'
`;
}
async function collectNamedSlots(layoutPath) {
    const layoutDir = _path.default.dirname(layoutPath);
    const items = await _promises.default.readdir(layoutDir, {
        withFileTypes: true
    });
    const slots = [];
    for (const item of items){
        if (item.isDirectory() && item.name.startsWith('@') && // `@children slots are matched to the children prop, and should not be handled separately for type-checking
        item.name !== '@children') {
            slots.push(item.name.slice(1));
        }
    }
    return slots;
}
// By exposing the static route types separately as string literals,
// editors can provide autocompletion for them. However it's currently not
// possible to provide the same experience for dynamic routes.
const pluginState = (0, _buildcontext.getProxiedPluginState)({
    collectedRootParams: {},
    routeTypes: {
        edge: {
            static: '',
            dynamic: ''
        },
        node: {
            static: '',
            dynamic: ''
        },
        extra: {
            static: '',
            dynamic: ''
        }
    }
});
function formatRouteToRouteType(route) {
    const isDynamic = (0, _utils.isDynamicRoute)(route);
    if (isDynamic) {
        route = route.split('/').map((part)=>{
            if (part.startsWith('[') && part.endsWith(']')) {
                if (part.startsWith('[...')) {
                    // /[...slug]
                    return `\${CatchAllSlug<T>}`;
                } else if (part.startsWith('[[...') && part.endsWith(']]')) {
                    // /[[...slug]]
                    return `\${OptionalCatchAllSlug<T>}`;
                }
                // /[slug]
                return `\${SafeSlug<T>}`;
            }
            return part;
        }).join('/');
    }
    return {
        isDynamic,
        routeType: `\n    | \`${route}\``
    };
}
// Whether redirects and rewrites have been converted into routeTypes or not.
let redirectsRewritesTypesProcessed = false;
// Convert redirects and rewrites into routeTypes.
function addRedirectsRewritesRouteTypes(rewrites, redirects) {
    function addExtraRoute(source) {
        let tokens;
        try {
            tokens = (0, _pathtoregexp.parse)(source);
        } catch  {
        // Ignore invalid routes - they will be handled by other checks.
        }
        if (Array.isArray(tokens)) {
            const possibleNormalizedRoutes = [
                ''
            ];
            let slugCnt = 1;
            function append(suffix) {
                for(let i = 0; i < possibleNormalizedRoutes.length; i++){
                    possibleNormalizedRoutes[i] += suffix;
                }
            }
            function fork(suffix) {
                const currentLength = possibleNormalizedRoutes.length;
                for(let i = 0; i < currentLength; i++){
                    possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix);
                }
            }
            for (const token of tokens){
                if (typeof token === 'object') {
                    // Make sure the slug is always named.
                    const slug = token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`);
                    if (token.modifier === '*') {
                        append(`${token.prefix}[[...${slug}]]`);
                    } else if (token.modifier === '+') {
                        append(`${token.prefix}[...${slug}]`);
                    } else if (token.modifier === '') {
                        if (token.pattern === '[^\\/#\\?]+?') {
                            // A safe slug
                            append(`${token.prefix}[${slug}]`);
                        } else if (token.pattern === '.*') {
                            // An optional catch-all slug
                            append(`${token.prefix}[[...${slug}]]`);
                        } else if (token.pattern === '.+') {
                            // A catch-all slug
                            append(`${token.prefix}[...${slug}]`);
                        } else {
                            // Other regex patterns are not supported. Skip this route.
                            return;
                        }
                    } else if (token.modifier === '?') {
                        if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {
                            // An optional slug with plain text only, fork the route.
                            append(token.prefix);
                            fork(token.pattern);
                        } else {
                            // Optional modifier `?` and regex patterns are not supported.
                            return;
                        }
                    }
                } else if (typeof token === 'string') {
                    append(token);
                }
            }
            for (const normalizedRoute of possibleNormalizedRoutes){
                const { isDynamic, routeType } = formatRouteToRouteType(normalizedRoute);
                pluginState.routeTypes.extra[isDynamic ? 'dynamic' : 'static'] += routeType;
            }
        }
    }
    if (rewrites) {
        for (const rewrite of rewrites.beforeFiles){
            addExtraRoute(rewrite.source);
        }
        for (const rewrite of rewrites.afterFiles){
            addExtraRoute(rewrite.source);
        }
        for (const rewrite of rewrites.fallback){
            addExtraRoute(rewrite.source);
        }
    }
    if (redirects) {
        for (const redirect of redirects){
            // Skip internal redirects
            // https://github.com/vercel/next.js/blob/8ff3d7ff57836c24088474175d595b4d50b3f857/packages/next/src/lib/load-custom-routes.ts#L704-L710
            if (!('internal' in redirect)) {
                addExtraRoute(redirect.source);
            }
        }
    }
}
function createRouteDefinitions() {
    let staticRouteTypes = '';
    let dynamicRouteTypes = '';
    for (const type of [
        'edge',
        'node',
        'extra'
    ]){
        staticRouteTypes += pluginState.routeTypes[type].static;
        dynamicRouteTypes += pluginState.routeTypes[type].dynamic;
    }
    // If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string & {}'.
    const routeTypesFallback = !staticRouteTypes && !dynamicRouteTypes ? 'string & {}' : '';
    return `// Type definitions for Next.js routes

/**
 * Internal types used by the Next.js router and Link component.
 * These types are not meant to be used directly.
 * @internal
 */
declare namespace __next_route_internal_types__ {
  type SearchOrHash = \`?\${string}\` | \`#\${string}\`
  type WithProtocol = \`\${string}:\${string}\`

  type Suffix = '' | SearchOrHash

  type SafeSlug<S extends string> = S extends \`\${string}/\${string}\`
    ? never
    : S extends \`\${string}\${SearchOrHash}\`
    ? never
    : S extends ''
    ? never
    : S

  type CatchAllSlug<S extends string> = S extends \`\${string}\${SearchOrHash}\`
    ? never
    : S extends ''
    ? never
    : S

  type OptionalCatchAllSlug<S extends string> =
    S extends \`\${string}\${SearchOrHash}\` ? never : S

  type StaticRoutes = ${staticRouteTypes || 'never'}
  type DynamicRoutes<T extends string = string> = ${dynamicRouteTypes || 'never'}

  type RouteImpl<T> = ${routeTypesFallback || `
    ${'| StaticRoutes'}
    | SearchOrHash
    | WithProtocol
    | \`\${StaticRoutes}\${SearchOrHash}\`
    | (T extends \`\${DynamicRoutes<infer _>}\${Suffix}\` ? T : never)
    `}
}

declare module 'next' {
  export { default } from 'next/types.js'
  export * from 'next/types.js'

  export type Route<T extends string = string> =
    __next_route_internal_types__.RouteImpl<T>
}

declare module 'next/link' {
  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'
  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'
  import type { UrlObject } from 'url'

  type LinkRestProps = Omit<
    Omit<
      DetailedHTMLProps<
        AnchorHTMLAttributes<HTMLAnchorElement>,
        HTMLAnchorElement
      >,
      keyof OriginalLinkProps
    > &
      OriginalLinkProps,
    'href'
  >

  export type LinkProps<RouteInferType> = LinkRestProps & {
    /**
     * The path or URL to navigate to. This is the only required prop. It can also be an object.
     * @see https://nextjs.org/docs/api-reference/next/link
     */
    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject
  }

  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element
}

declare module 'next/navigation' {
  export * from 'next/dist/client/components/navigation.js'

  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'
  interface AppRouterInstance extends OriginalAppRouterInstance {
    /**
     * Navigate to the provided href.
     * Pushes a new history entry.
     */
    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void
    /**
     * Navigate to the provided href.
     * Replaces the current history entry.
     */
    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void
    /**
     * Prefetch the provided href.
     */
    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void
  }

  export function useRouter(): AppRouterInstance;
}

declare module 'next/form' {
  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'

  type FormRestProps = Omit<OriginalFormProps, 'action'>

  export type FormProps<RouteInferType> = {
    /**
     * \`action\` can be either a \`string\` or a function.
     * - If \`action\` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.
     *   The path will be prefetched when the form becomes visible.
     * - If \`action\` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.
     */
    action: __next_route_internal_types__.RouteImpl<RouteInferType> | ((formData: FormData) => void)
  } & FormRestProps

  export default function Form<RouteType>(props: FormProps<RouteType>): JSX.Element
}
`;
}
function formatTimespan(seconds) {
    if (seconds > 0) {
        if (seconds === 18748800) {
            return '1 month';
        }
        if (seconds === 18144000) {
            return '1 month';
        }
        if (seconds === 604800) {
            return '1 week';
        }
        if (seconds === 86400) {
            return '1 day';
        }
        if (seconds === 3600) {
            return '1 hour';
        }
        if (seconds === 60) {
            return '1 minute';
        }
        if (seconds % 18748800 === 0) {
            return seconds / 18748800 + ' months';
        }
        if (seconds % 18144000 === 0) {
            return seconds / 18144000 + ' months';
        }
        if (seconds % 604800 === 0) {
            return seconds / 604800 + ' weeks';
        }
        if (seconds % 86400 === 0) {
            return seconds / 86400 + ' days';
        }
        if (seconds % 3600 === 0) {
            return seconds / 3600 + ' hours';
        }
        if (seconds % 60 === 0) {
            return seconds / 60 + ' minutes';
        }
    }
    return seconds + ' seconds';
}
function formatTimespanWithSeconds(seconds) {
    if (seconds === undefined) {
        return 'default';
    }
    if (seconds >= 0xfffffffe) {
        return 'never';
    }
    const text = seconds + ' seconds';
    const descriptive = formatTimespan(seconds);
    if (descriptive === text) {
        return text;
    }
    return text + ' (' + descriptive + ')';
}
function getRootParamsFromLayouts(layouts) {
    // Sort layouts by depth (descending)
    const sortedLayouts = Object.entries(layouts).sort((a, b)=>b[0].split('/').length - a[0].split('/').length);
    if (!sortedLayouts.length) {
        return [];
    }
    // we assume the shorted layout path is the root layout
    let rootLayout = sortedLayouts[sortedLayouts.length - 1][0];
    let rootParams = new Set();
    let isMultipleRootLayouts = false;
    for (const [layoutPath, params] of sortedLayouts){
        const allSegmentsAreDynamic = layoutPath.split('/').slice(1, -1) // match dynamic params but not catch-all or optional catch-all
        .every((segment)=>/^\[[^[.\]]+\]$/.test(segment));
        if (allSegmentsAreDynamic) {
            if (isSubpath(rootLayout, layoutPath)) {
                // Current path is a subpath of the root layout, update root
                rootLayout = layoutPath;
                rootParams = new Set(params);
            } else {
                // Found another potential root layout
                isMultipleRootLayouts = true;
                // Add any new params
                for (const param of params){
                    rootParams.add(param);
                }
            }
        }
    }
    // Create result array
    const result = Array.from(rootParams).map((param)=>({
            param,
            optional: isMultipleRootLayouts
        }));
    return result;
}
function isSubpath(parentLayoutPath, potentialChildLayoutPath) {
    // we strip off the `layout` part of the path as those will always conflict with being a subpath
    const parentSegments = parentLayoutPath.split('/').slice(1, -1);
    const childSegments = potentialChildLayoutPath.split('/').slice(1, -1);
    // child segments should be shorter or equal to parent segments to be a subpath
    if (childSegments.length > parentSegments.length || !childSegments.length) return false;
    // Verify all segment values are equal
    return childSegments.every((childSegment, index)=>childSegment === parentSegments[index]);
}
function createServerDefinitions(rootParams) {
    return `
  declare module 'next/server' {

    import type { AsyncLocalStorage as NodeAsyncLocalStorage } from 'async_hooks'
    declare global {
      var AsyncLocalStorage: typeof NodeAsyncLocalStorage
    }
    export { NextFetchEvent } from 'next/dist/server/web/spec-extension/fetch-event'
    export { NextRequest } from 'next/dist/server/web/spec-extension/request'
    export { NextResponse } from 'next/dist/server/web/spec-extension/response'
    export { NextMiddleware, MiddlewareConfig } from 'next/dist/server/web/types'
    export { userAgentFromString } from 'next/dist/server/web/spec-extension/user-agent'
    export { userAgent } from 'next/dist/server/web/spec-extension/user-agent'
    export { URLPattern } from 'next/dist/compiled/@edge-runtime/primitives/url'
    export { ImageResponse } from 'next/dist/server/web/spec-extension/image-response'
    export type { ImageResponseOptions } from 'next/dist/compiled/@vercel/og/types'
    export { after } from 'next/dist/server/after'
    export { connection } from 'next/dist/server/request/connection'
    export type { UnsafeUnwrappedSearchParams } from 'next/dist/server/request/search-params'
    export type { UnsafeUnwrappedParams } from 'next/dist/server/request/params'
    export function unstable_rootParams(): Promise<{ ${rootParams.map(({ param, optional })=>`${param.includes('-') ? `'${param}'` : param}${optional ? '?' : ''}: string`).join(', ')} }>
  }
  `;
}
function createCustomCacheLifeDefinitions(cacheLife) {
    let overloads = '';
    const profileNames = Object.keys(cacheLife);
    for(let i = 0; i < profileNames.length; i++){
        const profileName = profileNames[i];
        const profile = cacheLife[profileName];
        if (typeof profile !== 'object' || profile === null) {
            continue;
        }
        let description = '';
        if (profile.stale === undefined) {
            description += `
     * This cache may be stale on clients for the default stale time of the scope before checking with the server.`;
        } else if (profile.stale >= 0xfffffffe) {
            description += `
     * This cache may be stale on clients indefinitely before checking with the server.`;
        } else {
            description += `
     * This cache may be stale on clients for ${formatTimespan(profile.stale)} before checking with the server.`;
        }
        if (profile.revalidate !== undefined && profile.expire !== undefined && profile.revalidate >= profile.expire) {
            description += `
     * This cache will expire after ${formatTimespan(profile.expire)}. The next request will recompute it.`;
        } else {
            if (profile.revalidate === undefined) {
                description += `
     * It will inherit the default revalidate time of its scope since it does not define its own.`;
            } else if (profile.revalidate >= 0xfffffffe) {
            // Nothing to mention.
            } else {
                description += `
     * If the server receives a new request after ${formatTimespan(profile.revalidate)}, start revalidating new values in the background.`;
            }
            if (profile.expire === undefined) {
                description += `
     * It will inherit the default expiration time of its scope since it does not define its own.`;
            } else if (profile.expire >= 0xfffffffe) {
                description += `
     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.`;
            } else {
                description += `
     * If this entry has no traffic for ${formatTimespan(profile.expire)} it will expire. The next request will recompute it.`;
            }
        }
        overloads += `
    /**
     * Cache this \`"use cache"\` for a timespan defined by the \`${JSON.stringify(profileName)}\` profile.
     * \`\`\`
     *   stale:      ${formatTimespanWithSeconds(profile.stale)}
     *   revalidate: ${formatTimespanWithSeconds(profile.revalidate)}
     *   expire:     ${formatTimespanWithSeconds(profile.expire)}
     * \`\`\`
     * ${description}
     */
    export function unstable_cacheLife(profile: ${JSON.stringify(profileName)}): void
    `;
    }
    overloads += `
    /**
     * Cache this \`"use cache"\` using a custom timespan.
     * \`\`\`
     *   stale: ... // seconds
     *   revalidate: ... // seconds
     *   expire: ... // seconds
     * \`\`\`
     *
     * This is similar to Cache-Control: max-age=\`stale\`,s-max-age=\`revalidate\`,stale-while-revalidate=\`expire-revalidate\`
     *
     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.
     */
    export function unstable_cacheLife(profile: {
      /**
       * This cache may be stale on clients for ... seconds before checking with the server.
       */
      stale?: number,
      /**
       * If the server receives a new request after ... seconds, start revalidating new values in the background.
       */
      revalidate?: number,
      /**
       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.
       */
      expire?: number
    }): void
  `;
    // Redefine the cacheLife() accepted arguments.
    return `// Type definitions for Next.js cacheLife configs

declare module 'next/cache' {
  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'
  export {
    revalidateTag,
    revalidatePath,
    unstable_expireTag,
    unstable_expirePath,
  } from 'next/dist/server/web/spec-extension/revalidate'
  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'

  ${overloads}

  export { cacheTag as unstable_cacheTag } from 'next/dist/server/use-cache/cache-tag'
}
`;
}
const appTypesBasePath = _path.default.join('types', 'app');
class NextTypesPlugin {
    constructor(options){
        this.dir = options.dir;
        this.distDir = options.distDir;
        this.appDir = options.appDir;
        this.dev = options.dev;
        this.isEdgeServer = options.isEdgeServer;
        this.pageExtensions = options.pageExtensions;
        this.pagesDir = _path.default.join(this.appDir, '..', 'pages');
        this.typedRoutes = options.typedRoutes;
        this.cacheLifeConfig = options.cacheLifeConfig;
        this.distDirAbsolutePath = _path.default.join(this.dir, this.distDir);
        if (this.typedRoutes && !redirectsRewritesTypesProcessed) {
            redirectsRewritesTypesProcessed = true;
            addRedirectsRewritesRouteTypes(options.originalRewrites, options.originalRedirects);
        }
    }
    getRelativePathFromAppTypesDir(moduleRelativePathToAppDir) {
        const moduleAbsolutePath = _path.default.join(this.appDir, moduleRelativePathToAppDir);
        const moduleInAppTypesAbsolutePath = _path.default.join(this.distDirAbsolutePath, appTypesBasePath, moduleRelativePathToAppDir);
        return _path.default.relative(moduleInAppTypesAbsolutePath + '/..', moduleAbsolutePath);
    }
    collectPage(filePath) {
        if (!this.typedRoutes) return;
        const isApp = filePath.startsWith(this.appDir + _path.default.sep);
        const isPages = !isApp && filePath.startsWith(this.pagesDir + _path.default.sep);
        if (!isApp && !isPages) {
            return;
        }
        // Filter out non-page and non-route files in app dir
        if (isApp && !/[/\\](?:page|route)\.[^.]+$/.test(filePath)) {
            return;
        }
        // Filter out non-page files in pages dir
        if (isPages && /[/\\](?:_app|_document|_error|404|500)\.[^.]+$/.test(filePath)) {
            return;
        }
        let route = (isApp ? _apppaths.normalizeAppPath : _denormalizepagepath.denormalizePagePath)((0, _ensureleadingslash.ensureLeadingSlash)((0, _entries.getPageFromPath)(_path.default.relative(isApp ? this.appDir : this.pagesDir, filePath), this.pageExtensions)));
        const { isDynamic, routeType } = formatRouteToRouteType(route);
        pluginState.routeTypes[this.isEdgeServer ? 'edge' : 'node'][isDynamic ? 'dynamic' : 'static'] += routeType;
    }
    apply(compiler) {
        // From asset root to dist root
        const assetDirRelative = this.dev ? '..' : this.isEdgeServer ? '..' : '../..';
        const handleModule = async (mod, compilation)=>{
            if (!mod.resource) return;
            const pageExtensionsRegex = new RegExp(`\\.(${this.pageExtensions.join('|')})$`);
            if (!pageExtensionsRegex.test(mod.resource)) return;
            if (!mod.resource.startsWith(this.appDir + _path.default.sep)) {
                if (!this.dev) {
                    if (mod.resource.startsWith(this.pagesDir + _path.default.sep)) {
                        this.collectPage(mod.resource);
                    }
                }
                return;
            }
            if (mod.layer !== _constants.WEBPACK_LAYERS.reactServerComponents) return;
            // skip for /app/_private dir convention
            // matches <app-dir>/**/_*
            const IS_PRIVATE = /(?:\/[^/]+)*\/_.*$/.test(mod.resource.replace(this.appDir, ''));
            if (IS_PRIVATE) return;
            const IS_LAYOUT = /[/\\]layout\.[^./\\]+$/.test(mod.resource);
            const IS_PAGE = !IS_LAYOUT && /[/\\]page\.[^.]+$/.test(mod.resource);
            const IS_ROUTE = !IS_PAGE && /[/\\]route\.[^.]+$/.test(mod.resource);
            const IS_IMPORTABLE = /\.(js|jsx|ts|tsx|mjs|cjs)$/.test(mod.resource);
            const relativePathToApp = _path.default.relative(this.appDir, mod.resource);
            if (!this.dev) {
                if (IS_PAGE || IS_ROUTE) {
                    this.collectPage(mod.resource);
                }
            }
            const typePath = _path.default.join(appTypesBasePath, relativePathToApp.replace(pageExtensionsRegex, '.ts'));
            const relativeImportPath = (0, _normalizepathsep.normalizePathSep)(_path.default.join(this.getRelativePathFromAppTypesDir(relativePathToApp)).replace(pageExtensionsRegex, ''));
            const assetPath = _path.default.join(assetDirRelative, typePath);
            // Typescript won’t allow relative-importing (for example) a .mdx file using the .js extension
            // so for now we only generate “type guard files” for files that typescript can transform
            if (!IS_IMPORTABLE) return;
            if (IS_LAYOUT) {
                const rootLayoutPath = (0, _apppaths.normalizeAppPath)((0, _ensureleadingslash.ensureLeadingSlash)((0, _entries.getPageFromPath)(_path.default.relative(this.appDir, mod.resource), this.pageExtensions)));
                const foundParams = Array.from(rootLayoutPath.matchAll(/\[(.*?)\]/g), (match)=>match[1]);
                pluginState.collectedRootParams[rootLayoutPath] = foundParams;
                const slots = await collectNamedSlots(mod.resource);
                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {
                    type: 'layout',
                    slots
                })));
            } else if (IS_PAGE) {
                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {
                    type: 'page'
                })));
            } else if (IS_ROUTE) {
                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {
                    type: 'route'
                })));
            }
        };
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tapAsync({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH
            }, async (_, callback)=>{
                const promises = [];
                // Clear routes
                if (this.isEdgeServer) {
                    pluginState.routeTypes.edge.dynamic = '';
                    pluginState.routeTypes.edge.static = '';
                } else {
                    pluginState.routeTypes.node.dynamic = '';
                    pluginState.routeTypes.node.static = '';
                }
                compilation.chunkGroups.forEach((chunkGroup)=>{
                    chunkGroup.chunks.forEach((chunk)=>{
                        if (!chunk.name) return;
                        // Here we only track page and route chunks.
                        if (!chunk.name.startsWith('pages/') && !(chunk.name.startsWith('app/') && (chunk.name.endsWith('/page') || chunk.name.endsWith('/route')))) {
                            return;
                        }
                        const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);
                        for (const mod of chunkModules){
                            promises.push(handleModule(mod, compilation));
                            // If this is a concatenation, register each child to the parent ID.
                            const anyModule = mod;
                            if (anyModule.modules) {
                                anyModule.modules.forEach((concatenatedMod)=>{
                                    promises.push(handleModule(concatenatedMod, compilation));
                                });
                            }
                        }
                    });
                });
                await Promise.all(promises);
                const rootParams = getRootParamsFromLayouts(pluginState.collectedRootParams);
                // If we discovered rootParams, we'll override the `next/server` types
                // since we're able to determine the root params at build time.
                if (rootParams.length > 0) {
                    const serverTypesPath = _path.default.join(assetDirRelative, 'types/server.d.ts');
                    compilation.emitAsset(serverTypesPath, new _webpack.sources.RawSource(createServerDefinitions(rootParams)));
                }
                // Support `"moduleResolution": "Node16" | "NodeNext"` with `"type": "module"`
                const packageJsonAssetPath = _path.default.join(assetDirRelative, 'types/package.json');
                compilation.emitAsset(packageJsonAssetPath, new _webpack.sources.RawSource('{"type": "module"}'));
                if (this.typedRoutes) {
                    if (this.dev && !this.isEdgeServer) {
                        _shared.devPageFiles.forEach((file)=>{
                            this.collectPage(file);
                        });
                    }
                    const linkAssetPath = _path.default.join(assetDirRelative, 'types/link.d.ts');
                    compilation.emitAsset(linkAssetPath, new _webpack.sources.RawSource(createRouteDefinitions()));
                }
                if (this.cacheLifeConfig) {
                    const cacheLifeAssetPath = _path.default.join(assetDirRelative, 'types/cache-life.d.ts');
                    compilation.emitAsset(cacheLifeAssetPath, new _webpack.sources.RawSource(createCustomCacheLifeDefinitions(this.cacheLifeConfig)));
                }
                callback();
            });
        });
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/app-build-manifest-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppBuildManifestPlugin", {
    enumerable: true,
    get: function() {
        return AppBuildManifestPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _buildmanifestplugin = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js [app-rsc] (ecmascript)");
const _getapproutefromentrypoint = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/get-app-route-from-entrypoint.js [app-rsc] (ecmascript)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'AppBuildManifestPlugin';
class AppBuildManifestPlugin {
    constructor(options){
        this.dev = options.dev;
    }
    apply(compiler) {
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>this.createAsset(compilation));
        });
    }
    createAsset(compilation) {
        const manifest = {
            pages: {}
        };
        const mainFiles = new Set((0, _buildmanifestplugin.getEntrypointFiles)(compilation.entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)));
        for (const entrypoint of compilation.entrypoints.values()){
            if (!entrypoint.name) {
                continue;
            }
            if (_constants.SYSTEM_ENTRYPOINTS.has(entrypoint.name)) {
                continue;
            }
            const pagePath = (0, _getapproutefromentrypoint.default)(entrypoint.name);
            if (!pagePath) {
                continue;
            }
            const filesForPage = (0, _buildmanifestplugin.getEntrypointFiles)(entrypoint);
            manifest.pages[pagePath] = [
                ...new Set([
                    ...mainFiles,
                    ...filesForPage
                ])
            ];
        }
        const json = JSON.stringify(manifest, null, 2);
        compilation.emitAsset(_constants.APP_BUILD_MANIFEST, new _webpack.sources.RawSource(json));
    }
} //# sourceMappingURL=app-build-manifest-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/subresource-integrity-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SubresourceIntegrityPlugin", {
    enumerable: true,
    get: function() {
        return SubresourceIntegrityPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _crypto = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'SubresourceIntegrityPlugin';
class SubresourceIntegrityPlugin {
    constructor(algorithm){
        this.algorithm = algorithm;
    }
    apply(compiler) {
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.afterProcessAssets.tap({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>{
                // Collect all the assets.
                let files = new Set();
                for (const asset of compilation.getAssets()){
                    files.add(asset.name);
                }
                // For each file, deduped, calculate the file hash.
                const hashes = {};
                for (const file of files.values()){
                    // Get the buffer for the asset.
                    const asset = compilation.getAsset(file);
                    if (!asset) {
                        throw Object.defineProperty(new Error(`could not get asset: ${file}`), "__NEXT_ERROR_CODE", {
                            value: "E349",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    // Get the buffer for the asset.
                    const buffer = asset.source.buffer();
                    // Create the hash for the content.
                    const hash = _crypto.default.createHash(this.algorithm).update(buffer).digest().toString('base64');
                    hashes[file] = `${this.algorithm}-${hash}`;
                }
                const json = JSON.stringify(hashes, null, 2);
                const file = 'server/' + _constants.SUBRESOURCE_INTEGRITY_MANIFEST;
                compilation.emitAsset(file + '.js', new _webpack.sources.RawSource(`self.__SUBRESOURCE_INTEGRITY_MANIFEST=${JSON.stringify(json)}`));
                compilation.emitAsset(file + '.json', new _webpack.sources.RawSource(json));
            });
        });
    }
} //# sourceMappingURL=subresource-integrity-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/next-font-manifest-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NextFontManifestPlugin", {
    enumerable: true,
    get: function() {
        return NextFontManifestPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/server/get-route-from-entrypoint.js [app-rsc] (ecmascript)"));
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'NextFontManifestPlugin';
/**
 * When calling font functions with next/font, you can specify if you'd like the font to be preloaded (true by default).
 * e.g.: const inter = Inter({ subsets: ['latin'], preload: true })
 *
 * In that case, next-font-loader will emit the font file as [name].p.[ext] instead of [name].[ext]
 * This function returns those files from an array that can include both preloaded and non-preloaded files.
 */ function getPreloadedFontFiles(fontFiles) {
    return fontFiles.filter((file)=>/\.p\.(woff|woff2|eot|ttf|otf)$/.test(file));
}
/**
 * Similarly to getPreloadedFontFiles, but returns true if some of the files includes -s in the name.
 * This means that a font is using size adjust in its fallback font.
 * This was added to enable adding data-size-adjust="true" to the dom, used by the Google Aurora team to collect statistics.
 */ function getPageIsUsingSizeAdjust(fontFiles) {
    return fontFiles.some((file)=>file.includes('-s'));
}
class NextFontManifestPlugin {
    constructor(options){
        this.appDir = options.appDir;
    }
    apply(compiler) {
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            // In this stage the font files are emitted and we can collect all files emitted by each chunkGroup (entry).
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, ()=>{
                const nextFontManifest = {
                    pages: {},
                    app: {},
                    appUsingSizeAdjust: false,
                    pagesUsingSizeAdjust: false
                };
                if (this.appDir) {
                    const appDirBase = _path.default.dirname(this.appDir) + _path.default.sep;
                    // After all modules are created, we collect the modules that was created by next-font-loader.
                    (0, _utils.traverseModules)(compilation, (mod, _chunk, chunkGroup)=>{
                        var _mod_request;
                        if (mod == null ? void 0 : (_mod_request = mod.request) == null ? void 0 : _mod_request.includes('/next-font-loader/index.js?')) {
                            var _mod_buildInfo;
                            if (!((_mod_buildInfo = mod.buildInfo) == null ? void 0 : _mod_buildInfo.assets)) return;
                            const chunkEntryName = (appDirBase + chunkGroup.name).replace(/[\\/]/g, _path.default.sep);
                            const modAssets = Object.keys(mod.buildInfo.assets);
                            const fontFiles = modAssets.filter((file)=>/\.(woff|woff2|eot|ttf|otf)$/.test(file));
                            // Look if size-adjust fallback font is being used
                            if (!nextFontManifest.appUsingSizeAdjust) {
                                nextFontManifest.appUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);
                            }
                            const preloadedFontFiles = getPreloadedFontFiles(fontFiles);
                            // Add an entry of the module's font files in the manifest.
                            // We'll add an entry even if no files should preload.
                            // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.
                            if (fontFiles.length > 0) {
                                if (!nextFontManifest.app[chunkEntryName]) {
                                    nextFontManifest.app[chunkEntryName] = [];
                                }
                                nextFontManifest.app[chunkEntryName].push(...preloadedFontFiles);
                            }
                        }
                    }, (chunkGroup)=>{
                        var _chunkGroup_name;
                        // Only loop through entrypoints that are under app/.
                        return !!((_chunkGroup_name = chunkGroup.name) == null ? void 0 : _chunkGroup_name.startsWith('app/'));
                    });
                }
                // Look at all the entrypoints created for pages/.
                for (const entrypoint of compilation.entrypoints.values()){
                    const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name);
                    if (!pagePath) {
                        continue;
                    }
                    // Get font files from the chunks included in the entrypoint.
                    const fontFiles = entrypoint.chunks.flatMap((chunk)=>[
                            ...chunk.auxiliaryFiles
                        ]).filter((file)=>/\.(woff|woff2|eot|ttf|otf)$/.test(file));
                    // Look if size-adjust fallback font is being used
                    if (!nextFontManifest.pagesUsingSizeAdjust) {
                        nextFontManifest.pagesUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);
                    }
                    const preloadedFontFiles = getPreloadedFontFiles(fontFiles);
                    // Add an entry of the route's font files in the manifest.
                    // We'll add an entry even if no files should preload.
                    // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.
                    if (fontFiles.length > 0) {
                        nextFontManifest.pages[pagePath] = preloadedFontFiles;
                    }
                }
                const manifest = JSON.stringify(nextFontManifest, null);
                // Create manifest for edge
                compilation.emitAsset(`server/${_constants.NEXT_FONT_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__NEXT_FONT_MANIFEST=${JSON.stringify(manifest)}`));
                // Create manifest for server
                compilation.emitAsset(`server/${_constants.NEXT_FONT_MANIFEST}.json`, new _webpack.sources.RawSource(manifest));
            });
        });
        return;
    }
} //# sourceMappingURL=next-font-manifest-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/memory-with-gc-cache-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
This plugin is based on the internal one in webpack but heavily modified to use a different caching heuristic.
https://github.com/webpack/webpack/blob/853bfda35a0080605c09e1bdeb0103bcb9367a10/lib/cache/MemoryWithGcCachePlugin.js#L15

https://github.com/webpack/webpack/blob/main/LICENSE
Copyright JS Foundation and other contributors

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ /*
The change in this plugin compared to the built-in one in webpack is that this plugin always cleans up after 5 compilations.
The built-in plugin only cleans up "total modules / max generations".
The default for max generations is 5, so 1/5th of the modules would be marked for deletion.
This plugin instead always checks the cache and decreases the time to live of all entries. That way memory is cleaned up earlier.
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MemoryWithGcCachePlugin", {
    enumerable: true,
    get: function() {
        return MemoryWithGcCachePlugin;
    }
});
// Used to hook into the memory stage of the webpack caching
const CACHE_STAGE_MEMORY = -10 // TODO: Somehow webpack.Cache.STAGE_MEMORY doesn't work.
;
const PLUGIN_NAME = 'NextJsMemoryWithGcCachePlugin';
class MemoryWithGcCachePlugin {
    constructor({ maxGenerations }){
        this.maxGenerations = maxGenerations;
    }
    apply(compiler) {
        const maxGenerations = this.maxGenerations;
        /**
     * The memory cache
     */ const cache = new Map();
        /**
     * Cache cleanup implementation
     */ function decreaseTTLAndEvict() {
            for (const [identifier, entry] of cache){
                // Decrease item time to live
                entry.ttl--;
                // if ttl is 0 or below, evict entry from the cache
                if (entry.ttl <= 0) {
                    cache.delete(identifier);
                }
            }
        }
        compiler.hooks.afterDone.tap(PLUGIN_NAME, decreaseTTLAndEvict);
        compiler.cache.hooks.store.tap({
            name: PLUGIN_NAME,
            stage: CACHE_STAGE_MEMORY
        }, (identifier, etag, data)=>{
            cache.set(identifier, {
                etag,
                data,
                ttl: maxGenerations
            });
        });
        compiler.cache.hooks.get.tap({
            name: PLUGIN_NAME,
            stage: CACHE_STAGE_MEMORY
        }, (identifier, etag, gotHandlers)=>{
            const cacheEntry = cache.get(identifier);
            // Item found
            if (cacheEntry !== undefined) {
                // When cache entry is hit we reset the counter.
                cacheEntry.ttl = maxGenerations;
                // Handles `null` separately as it doesn't have an etag.
                if (cacheEntry.data === null) {
                    return null;
                }
                return cacheEntry.etag === etag ? cacheEntry.data : null;
            }
            // Handle case where other cache does have the identifier, puts it into the memory cache
            gotHandlers.push((result, callback)=>{
                cache.set(identifier, {
                    // Handles `null` separately as it doesn't have an etag.
                    etag: result === null ? null : etag,
                    data: result,
                    ttl: maxGenerations
                });
                return callback();
            });
            // No item found
            return undefined;
        });
        compiler.cache.hooks.shutdown.tap({
            name: PLUGIN_NAME,
            stage: CACHE_STAGE_MEMORY
        }, ()=>{
            cache.clear();
        });
    }
} //# sourceMappingURL=memory-with-gc-cache-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/optional-peer-dependency-resolve-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "OptionalPeerDependencyResolverPlugin", {
    enumerable: true,
    get: function() {
        return OptionalPeerDependencyResolverPlugin;
    }
});
const pluginSymbol = Symbol('OptionalPeerDependencyResolverPlugin');
class OptionalPeerDependencyResolverPlugin {
    apply(resolver) {
        const target = resolver.ensureHook('raw-module');
        target.tapAsync('OptionalPeerDependencyResolverPlugin', (request, resolveContext, callback)=>{
            var _resolveContext_stack;
            // if we've already recursed into this plugin, we want to skip it
            if (request[pluginSymbol]) {
                return callback();
            }
            (_resolveContext_stack = resolveContext.stack) == null ? void 0 : _resolveContext_stack.delete(Array.from(resolveContext.stack).pop());
            resolver.doResolve(target, // recurse into this plugin again
            {
                ...request,
                [pluginSymbol]: true
            }, null, resolveContext, (err, result)=>{
                var _request_descriptionFileData;
                if (!result && (request == null ? void 0 : (_request_descriptionFileData = request.descriptionFileData) == null ? void 0 : _request_descriptionFileData.peerDependenciesMeta) && request.request) {
                    const peerDependenciesMeta = request.descriptionFileData.peerDependenciesMeta;
                    const isOptional = peerDependenciesMeta && peerDependenciesMeta[request.request] && peerDependenciesMeta[request.request].optional;
                    if (isOptional) {
                        return callback(null, {
                            path: false
                        });
                    }
                }
                return callback(err, result);
            });
        });
    }
} //# sourceMappingURL=optional-peer-dependency-resolve-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/css-chunking-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CssChunkingPlugin", {
    enumerable: true,
    get: function() {
        return CssChunkingPlugin;
    }
});
const PLUGIN_NAME = 'CssChunkingPlugin';
/**
 * Merge chunks until they are bigger than the target size.
 */ const MIN_CSS_CHUNK_SIZE = 30 * 1024;
/**
 * Avoid merging chunks when they would be bigger than this size.
 */ const MAX_CSS_CHUNK_SIZE = 100 * 1024;
function isGlobalCss(module) {
    return !/\.module\.(css|scss|sass)$/.test(module.nameForCondition() || '');
}
class CssChunkingPlugin {
    constructor(strict){
        this.strict = strict;
    }
    apply(compiler) {
        const strict = this.strict;
        const summary = !!process.env.CSS_CHUNKING_SUMMARY;
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{
            let once = false;
            compilation.hooks.optimizeChunks.tap({
                name: PLUGIN_NAME,
                stage: 5
            }, ()=>{
                if (once) {
                    return;
                }
                once = true;
                const chunkGraph = compilation.chunkGraph;
                let changed = undefined;
                const chunkStates = new Map();
                const chunkStatesByModule = new Map();
                // Collect all css modules in chunks and the execpted order of them
                for (const chunk of compilation.chunks){
                    var _chunk_name;
                    if ((_chunk_name = chunk.name) == null ? void 0 : _chunk_name.startsWith('pages/')) continue;
                    const modules = [];
                    for (const module of chunkGraph.getChunkModulesIterable(chunk)){
                        var _module_type;
                        if (!((_module_type = module.type) == null ? void 0 : _module_type.startsWith('css'))) continue;
                        modules.push(module);
                    }
                    if (!modules.length) continue;
                    const chunkState = {
                        chunk,
                        modules,
                        order: 0,
                        requests: modules.length
                    };
                    chunkStates.set(chunk, chunkState);
                    for(let i = 0; i < modules.length; i++){
                        const module = modules[i];
                        let moduleChunkStates = chunkStatesByModule.get(module);
                        if (!moduleChunkStates) {
                            moduleChunkStates = new Map();
                            chunkStatesByModule.set(module, moduleChunkStates);
                        }
                        moduleChunkStates.set(chunkState, i);
                        chunkStatesByModule.set(module, moduleChunkStates);
                    }
                }
                // Sort modules by their index sum
                const orderedModules = [];
                for (const [module, moduleChunkStates] of chunkStatesByModule){
                    let sum = 0;
                    for (const i of moduleChunkStates.values()){
                        sum += i;
                    }
                    orderedModules.push({
                        module,
                        sum
                    });
                }
                orderedModules.sort((a, b)=>a.sum - b.sum);
                // A queue of modules that still need to be processed
                const remainingModules = new Set(orderedModules.map(({ module })=>module));
                // In loose mode we guess the dependents of modules from the order
                // assuming that when a module is a dependency of another module
                // it will always appear before it in every chunk.
                const allDependents = new Map();
                if (!this.strict) {
                    for (const b of remainingModules){
                        const dependent = new Set();
                        loop: for (const a of remainingModules){
                            if (a === b) continue;
                            // check if a depends on b
                            for (const [chunkState, ia] of chunkStatesByModule.get(a)){
                                const bChunkStates = chunkStatesByModule.get(b);
                                const ib = bChunkStates.get(chunkState);
                                if (ib === undefined) {
                                    continue loop;
                                }
                                if (ib > ia) {
                                    continue loop;
                                }
                            }
                            dependent.add(a);
                        }
                        if (dependent.size > 0) allDependents.set(b, dependent);
                    }
                }
                // Stores the new chunk for every module
                const newChunksByModule = new Map();
                // Process through all modules
                for (const startModule of remainingModules){
                    let globalCssMode = isGlobalCss(startModule);
                    // The current position of processing in all selected chunks
                    let allChunkStates = new Map(chunkStatesByModule.get(startModule));
                    // The list of modules that goes into the new chunk
                    const newChunkModules = new Set([
                        startModule
                    ]);
                    // The current size of the new chunk
                    let currentSize = startModule.size();
                    // A pool of potential modules where the next module is selected from.
                    // It's filled from the next module of the selected modules in every chunk.
                    // It also keeps some metadata to improve performance [size, chunkStates].
                    const potentialNextModules = new Map();
                    for (const [chunkState, i] of allChunkStates){
                        const nextModule = chunkState.modules[i + 1];
                        if (nextModule && remainingModules.has(nextModule)) {
                            potentialNextModules.set(nextModule, [
                                nextModule.size(),
                                chunkStatesByModule.get(nextModule)
                            ]);
                        }
                    }
                    // Try to add modules to the chunk until a break condition is met
                    let cont;
                    do {
                        cont = false;
                        // We try to select a module that reduces request count and
                        // has the highest number of requests
                        const orderedPotentialNextModules = [];
                        for (const [nextModule, [size, nextChunkStates]] of potentialNextModules){
                            let maxRequests = 0;
                            for (const chunkState of nextChunkStates.keys()){
                                // There is always some overlap
                                if (allChunkStates.has(chunkState)) {
                                    maxRequests = Math.max(maxRequests, chunkState.requests);
                                }
                            }
                            orderedPotentialNextModules.push([
                                nextModule,
                                size,
                                nextChunkStates,
                                maxRequests
                            ]);
                        }
                        orderedPotentialNextModules.sort((a, b)=>b[3] - a[3] || (a[0].identifier() < b[0].identifier() ? -1 : 1));
                        // Try every potential module
                        loop: for (const [nextModule, size, nextChunkStates] of orderedPotentialNextModules){
                            if (currentSize + size > MAX_CSS_CHUNK_SIZE) {
                                continue;
                            }
                            if (!strict) {
                                // In loose mode we only check if the dependencies are not violated
                                const dependent = allDependents.get(nextModule);
                                if (dependent) {
                                    for (const dep of dependent){
                                        if (newChunkModules.has(dep)) {
                                            continue loop;
                                        }
                                    }
                                }
                            } else {
                                // In strict mode we check that none of the order in any chunk is changed by adding the module
                                for (const [chunkState, i] of nextChunkStates){
                                    const prevState = allChunkStates.get(chunkState);
                                    if (prevState === undefined) {
                                        // New chunk group, can add it, but should we?
                                        // We only add that if below min size
                                        if (currentSize < MIN_CSS_CHUNK_SIZE) {
                                            continue;
                                        } else {
                                            continue loop;
                                        }
                                    } else if (prevState + 1 === i) {
                                        continue;
                                    } else {
                                        continue loop;
                                    }
                                }
                            }
                            // Global CSS must not leak into unrelated chunks
                            const nextIsGlobalCss = isGlobalCss(nextModule);
                            if (nextIsGlobalCss && globalCssMode) {
                                if (allChunkStates.size !== nextChunkStates.size) {
                                    continue;
                                }
                            }
                            if (globalCssMode) {
                                for (const chunkState of nextChunkStates.keys()){
                                    if (!allChunkStates.has(chunkState)) {
                                        continue loop;
                                    }
                                }
                            }
                            if (nextIsGlobalCss) {
                                for (const chunkState of allChunkStates.keys()){
                                    if (!nextChunkStates.has(chunkState)) {
                                        continue loop;
                                    }
                                }
                            }
                            potentialNextModules.delete(nextModule);
                            currentSize += size;
                            if (nextIsGlobalCss) {
                                globalCssMode = true;
                            }
                            for (const [chunkState, i] of nextChunkStates){
                                if (allChunkStates.has(chunkState)) {
                                    // This reduces the request count of the chunk group
                                    chunkState.requests--;
                                }
                                allChunkStates.set(chunkState, i);
                                const newNextModule = chunkState.modules[i + 1];
                                if (newNextModule && remainingModules.has(newNextModule) && !newChunkModules.has(newNextModule)) {
                                    potentialNextModules.set(newNextModule, [
                                        newNextModule.size(),
                                        chunkStatesByModule.get(newNextModule)
                                    ]);
                                }
                            }
                            newChunkModules.add(nextModule);
                            cont = true;
                            break;
                        }
                    }while (cont)
                    const newChunk = compilation.addChunk();
                    newChunk.preventIntegration = true;
                    newChunk.idNameHints.add('css');
                    for (const module of newChunkModules){
                        remainingModules.delete(module);
                        chunkGraph.connectChunkAndModule(newChunk, module);
                        newChunksByModule.set(module, newChunk);
                    }
                    changed = true;
                }
                for (const { chunk, modules } of chunkStates.values()){
                    const chunks = new Set();
                    for (const module of modules){
                        const newChunk = newChunksByModule.get(module);
                        if (newChunk) {
                            chunkGraph.disconnectChunkAndModule(chunk, module);
                            if (chunks.has(newChunk)) continue;
                            chunks.add(newChunk);
                            chunk.split(newChunk);
                        }
                    }
                }
                if (summary) {
                    console.log('Top 20 chunks by request count:');
                    const orderedChunkStates = [
                        ...chunkStates.values()
                    ];
                    orderedChunkStates.sort((a, b)=>b.requests - a.requests);
                    for (const { chunk, modules, requests } of orderedChunkStates.slice(0, 20)){
                        console.log(`- ${requests} requests for ${chunk.name} (has ${modules.length} modules)`);
                    }
                }
                return changed;
            });
        });
    }
} //# sourceMappingURL=css-chunking-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/telemetry-plugin/use-cache-tracker-utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createUseCacheTracker: null,
    mergeUseCacheTrackers: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createUseCacheTracker: function() {
        return createUseCacheTracker;
    },
    mergeUseCacheTrackers: function() {
        return mergeUseCacheTrackers;
    }
});
const createUseCacheTracker = ()=>new Map();
const mergeUseCacheTrackers = (tracker1, tracker2)=>{
    const mergedTracker = {
        ...tracker1
    };
    if (tracker2) {
        for(const key in tracker2){
            if (Object.prototype.hasOwnProperty.call(tracker2, key)) {
                const typedKey = key;
                if (mergedTracker[typedKey] !== undefined) {
                    mergedTracker[typedKey] += tracker2[typedKey];
                } else {
                    mergedTracker[typedKey] = tracker2[typedKey];
                }
            }
        }
    }
    return mergedTracker;
}; //# sourceMappingURL=use-cache-tracker-utils.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/telemetry-plugin/telemetry-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "TelemetryPlugin", {
    enumerable: true,
    get: function() {
        return TelemetryPlugin;
    }
});
const _usecachetrackerutils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/plugins/telemetry-plugin/use-cache-tracker-utils.js [app-rsc] (ecmascript)");
// Map of a feature module to the file it belongs in the next package.
const FEATURE_MODULE_MAP = new Map([
    [
        'next/image',
        '/next/image.js'
    ],
    [
        'next/future/image',
        '/next/future/image.js'
    ],
    [
        'next/legacy/image',
        '/next/legacy/image.js'
    ],
    [
        'next/script',
        '/next/script.js'
    ],
    [
        'next/dynamic',
        '/next/dynamic.js'
    ]
]);
const FEATURE_MODULE_REGEXP_MAP = new Map([
    [
        '@next/font/google',
        /\/@next\/font\/google\/target.css?.+$/
    ],
    [
        '@next/font/local',
        /\/@next\/font\/local\/target.css?.+$/
    ],
    [
        'next/font/google',
        /\/next\/font\/google\/target.css?.+$/
    ],
    [
        'next/font/local',
        /\/next\/font\/local\/target.css?.+$/
    ]
]);
// List of build features used in webpack configuration
const BUILD_FEATURES = [
    'swcLoader',
    'swcRelay',
    'swcStyledComponents',
    'swcReactRemoveProperties',
    'swcExperimentalDecorators',
    'swcRemoveConsole',
    'swcImportSource',
    'swcEmotion',
    'swc/target/x86_64-apple-darwin',
    'swc/target/x86_64-unknown-linux-gnu',
    'swc/target/x86_64-pc-windows-msvc',
    'swc/target/i686-pc-windows-msvc',
    'swc/target/aarch64-unknown-linux-gnu',
    'swc/target/armv7-unknown-linux-gnueabihf',
    'swc/target/aarch64-apple-darwin',
    'swc/target/aarch64-linux-android',
    'swc/target/arm-linux-androideabi',
    'swc/target/x86_64-unknown-freebsd',
    'swc/target/x86_64-unknown-linux-musl',
    'swc/target/aarch64-unknown-linux-musl',
    'swc/target/aarch64-pc-windows-msvc',
    'turbotrace',
    'transpilePackages',
    'skipMiddlewareUrlNormalize',
    'skipTrailingSlashRedirect',
    'modularizeImports',
    'esmExternals',
    'webpackPlugins'
];
const eliminatedPackages = new Set();
const useCacheTracker = (0, _usecachetrackerutils.createUseCacheTracker)();
/**
 * Determine if there is a feature of interest in the specified 'module'.
 */ function findFeatureInModule(module) {
    if (module.type !== 'javascript/auto') {
        return;
    }
    for (const [feature, path] of FEATURE_MODULE_MAP){
        var _module_resource;
        // imports like "http" will be undefined resource in rspack
        if ((_module_resource = module.resource) == null ? void 0 : _module_resource.endsWith(path)) {
            return feature;
        }
    }
    const normalizedIdentifier = module.identifier().replace(/\\/g, '/');
    for (const [feature, regexp] of FEATURE_MODULE_REGEXP_MAP){
        if (regexp.test(normalizedIdentifier)) {
            return feature;
        }
    }
}
/**
 * Find unique origin modules in the specified 'connections', which possibly
 * contains more than one connection for a module due to different types of
 * dependency.
 */ function findUniqueOriginModulesInConnections(connections, originModule) {
    const originModules = new Set();
    for (const connection of connections){
        if (!originModules.has(connection.originModule) && connection.originModule !== originModule) {
            originModules.add(connection.originModule);
        }
    }
    return originModules;
}
class TelemetryPlugin {
    // Build feature usage is on/off and is known before the build starts
    constructor(buildFeaturesMap){
        this.usageTracker = new Map();
        for (const featureName of BUILD_FEATURES){
            this.usageTracker.set(featureName, {
                featureName,
                invocationCount: buildFeaturesMap.get(featureName) ? 1 : 0
            });
        }
        for (const featureName of FEATURE_MODULE_MAP.keys()){
            this.usageTracker.set(featureName, {
                featureName,
                invocationCount: 0
            });
        }
        for (const featureName of FEATURE_MODULE_REGEXP_MAP.keys()){
            this.usageTracker.set(featureName, {
                featureName,
                invocationCount: 0
            });
        }
    }
    addUsage(featureName, invocationCount) {
        this.usageTracker.set(featureName, {
            featureName,
            invocationCount
        });
    }
    apply(compiler) {
        compiler.hooks.make.tapAsync(TelemetryPlugin.name, async (compilation, callback)=>{
            compilation.hooks.finishModules.tapAsync(TelemetryPlugin.name, async (modules, modulesFinish)=>{
                for (const module of modules){
                    const feature = findFeatureInModule(module);
                    if (!feature) {
                        continue;
                    }
                    const connections = compilation.moduleGraph.getIncomingConnections(module);
                    const originModules = findUniqueOriginModulesInConnections(connections, module);
                    this.usageTracker.get(feature).invocationCount = originModules.size;
                }
                modulesFinish();
            });
            callback();
        });
        if (compiler.options.mode === 'production' && !compiler.watchMode) {
            compiler.hooks.thisCompilation.tap(TelemetryPlugin.name, (compilation)=>{
                const moduleHooks = compiler.webpack.NormalModule.getCompilationHooks(compilation);
                moduleHooks.loader.tap(TelemetryPlugin.name, (loaderContext)=>{
                    ;
                    loaderContext.eliminatedPackages = eliminatedPackages;
                    loaderContext.useCacheTracker = useCacheTracker;
                });
            });
        }
    }
    usages() {
        return [
            ...this.usageTracker.values()
        ];
    }
    packagesUsedInServerSideProps() {
        return Array.from(eliminatedPackages);
    }
    getUseCacheTracker() {
        return Object.fromEntries(useCacheTracker);
    }
} //# sourceMappingURL=telemetry-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/minify-webpack-plugin/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MinifyPlugin", {
    enumerable: true,
    get: function() {
        return MinifyPlugin;
    }
});
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _plimit = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/p-limit/index.js [app-rsc] (ecmascript)"));
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function buildError(error, file) {
    if (error.line) {
        return new _webpack.WebpackError(`${file} from Minifier\n${error.message} [${file}:${error.line},${error.col}]${error.stack ? `\n${error.stack.split('\n').slice(1).join('\n')}` : ''}`);
    }
    if (error.stack) {
        return new _webpack.WebpackError(`${file} from Minifier\n${error.message}\n${error.stack}`);
    }
    return new _webpack.WebpackError(`${file} from Minifier\n${error.message}`);
}
const debugMinify = process.env.NEXT_DEBUG_MINIFY;
class MinifyPlugin {
    constructor(options){
        this.options = options;
    }
    async optimize(compiler, compilation, assets, cache, { SourceMapSource, RawSource }) {
        const mangle = !this.options.noMangling;
        const compilationSpan = (0, _utils.getCompilationSpan)(compilation) || (0, _utils.getCompilationSpan)(compiler);
        const MinifierSpan = compilationSpan.traceChild('minify-webpack-plugin-optimize');
        if (compilation.name) {
            MinifierSpan.setAttribute('compilationName', compilation.name);
        }
        MinifierSpan.setAttribute('mangle', String(mangle));
        return MinifierSpan.traceAsyncFn(async ()=>{
            const assetsList = Object.keys(assets);
            const assetsForMinify = await Promise.all(assetsList.filter((name)=>{
                if (!_webpack.ModuleFilenameHelpers.matchObject.bind(undefined, {
                    test: /\.[cm]?js(\?.*)?$/i
                })(name)) {
                    return false;
                }
                const res = compilation.getAsset(name);
                if (!res) {
                    console.log(name);
                    return false;
                }
                const { info } = res;
                // Skip double minimize assets from child compilation
                if (info.minimized) {
                    return false;
                }
                return true;
            }).map(async (name)=>{
                const { info, source } = compilation.getAsset(name);
                const eTag = cache.mergeEtags(cache.getLazyHashedEtag(source), JSON.stringify(this.options));
                const output = await cache.getPromise(name, eTag);
                if (debugMinify && debugMinify === '1') {
                    console.log(JSON.stringify({
                        name,
                        source: source.source().toString()
                    }), {
                        breakLength: Infinity,
                        maxStringLength: Infinity
                    });
                }
                return {
                    name,
                    info,
                    inputSource: source,
                    output,
                    eTag
                };
            }));
            let initializedWorker;
            // eslint-disable-next-line consistent-return
            const getWorker = ()=>{
                return {
                    minify: async (options)=>{
                        const result = await __turbopack_context__.r("[project]/node_modules/next/dist/build/swc/index.js [app-rsc] (ecmascript)").minify(options.input, {
                            ...options.inputSourceMap ? {
                                sourceMap: {
                                    content: JSON.stringify(options.inputSourceMap)
                                }
                            } : {},
                            // Compress options are defined in crates/napi/src/minify.rs.
                            compress: false,
                            // Mangle options may be amended in crates/napi/src/minify.rs.
                            mangle,
                            module: 'unknown',
                            output: {
                                comments: false
                            }
                        });
                        return result;
                    }
                };
            };
            // The limit in the SWC minifier will be handled by Node.js
            const limit = (0, _plimit.default)(Infinity);
            const scheduledTasks = [];
            for (const asset of assetsForMinify){
                scheduledTasks.push(limit(async ()=>{
                    const { name, inputSource, eTag } = asset;
                    let { output } = asset;
                    const minifySpan = MinifierSpan.traceChild('minify-js');
                    minifySpan.setAttribute('name', name);
                    minifySpan.setAttribute('cache', typeof output === 'undefined' ? 'MISS' : 'HIT');
                    return minifySpan.traceAsyncFn(async ()=>{
                        if (!output) {
                            const { source: sourceFromInputSource, map: inputSourceMap } = inputSource.sourceAndMap();
                            const input = Buffer.isBuffer(sourceFromInputSource) ? sourceFromInputSource.toString() : sourceFromInputSource;
                            let minifiedOutput;
                            try {
                                minifiedOutput = await getWorker().minify({
                                    input,
                                    inputSourceMap
                                });
                            } catch (error) {
                                compilation.errors.push(buildError(error, name));
                                return;
                            }
                            const source = minifiedOutput.map ? new SourceMapSource(minifiedOutput.code, name, minifiedOutput.map, input, inputSourceMap, true) : new RawSource(minifiedOutput.code);
                            await cache.storePromise(name, eTag, {
                                source
                            });
                            output = {
                                source
                            };
                        }
                        const newInfo = {
                            minimized: true
                        };
                        compilation.updateAsset(name, output.source, newInfo);
                    });
                }));
            }
            await Promise.all(scheduledTasks);
            if (initializedWorker) {
                await initializedWorker.end();
            }
        });
    }
    apply(compiler) {
        var _compiler_webpack;
        const { SourceMapSource, RawSource } = (compiler == null ? void 0 : (_compiler_webpack = compiler.webpack) == null ? void 0 : _compiler_webpack.sources) || _webpack.sources;
        const pluginName = this.constructor.name;
        compiler.hooks.thisCompilation.tap(pluginName, (compilation)=>{
            const cache = compilation.getCache('MinifierWebpackPlugin');
            const handleHashForChunk = (hash, _chunk)=>{
                // increment 'c' to invalidate cache
                hash.update('c');
            };
            const JSModulesHooks = _webpack.webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);
            JSModulesHooks.chunkHash.tap(pluginName, (chunk, hash)=>{
                if (!chunk.hasRuntime()) return;
                return handleHashForChunk(hash, chunk);
            });
            compilation.hooks.processAssets.tapPromise({
                name: pluginName,
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE
            }, (assets)=>this.optimize(compiler, compilation, assets, cache, {
                    SourceMapSource,
                    RawSource
                }));
            compilation.hooks.statsPrinter.tap(pluginName, (stats)=>{
                stats.hooks.print.for('asset.info.minimized').tap('minify-webpack-plugin', (minimized, { green, formatFlag })=>minimized ? green(formatFlag('minimized')) : undefined);
            });
        });
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/css-minimizer-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CssMinimizerPlugin", {
    enumerable: true,
    get: function() {
        return CssMinimizerPlugin;
    }
});
const _cssnanosimple = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/cssnano-simple/index.js [app-rsc] (ecmascript)"));
const _postcssscss = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/postcss-scss/scss-syntax.js [app-rsc] (ecmascript)"));
const _postcss = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/node_modules/postcss/lib/postcss.js [app-rsc] (ecmascript)"));
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// https://github.com/NMFR/optimize-css-assets-webpack-plugin/blob/0a410a9bf28c7b0e81a3470a13748e68ca2f50aa/src/index.js#L20
const CSS_REGEX = /\.css(\?.*)?$/i;
class CssMinimizerPlugin {
    constructor(options){
        this.__next_css_remove = true;
        this.options = options;
    }
    optimizeAsset(file, asset) {
        const postcssOptions = {
            ...this.options.postcssOptions,
            to: file,
            from: file,
            // We don't actually add this parser to support Sass. It can also be used
            // for inline comment support. See the README:
            // https://github.com/postcss/postcss-scss/blob/master/README.md#2-inline-comments-for-postcss
            parser: _postcssscss.default
        };
        let input;
        if (postcssOptions.map && asset.sourceAndMap) {
            const { source, map } = asset.sourceAndMap();
            input = source;
            postcssOptions.map.prev = map ? map : false;
        } else {
            input = asset.source();
        }
        return (0, _postcss.default)([
            (0, _cssnanosimple.default)({
                colormin: false
            }, _postcss.default)
        ]).process(input, postcssOptions).then((res)=>{
            if (res.map) {
                return new _webpack.sources.SourceMapSource(res.css, file, res.map.toJSON());
            } else {
                return new _webpack.sources.RawSource(res.css);
            }
        });
    }
    apply(compiler) {
        compiler.hooks.compilation.tap('CssMinimizerPlugin', (compilation)=>{
            const cache = compilation.getCache('CssMinimizerPlugin');
            compilation.hooks.processAssets.tapPromise({
                name: 'CssMinimizerPlugin',
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE
            }, async (assets)=>{
                const compilationSpan = (0, _utils.getCompilationSpan)(compilation) || (0, _utils.getCompilationSpan)(compiler);
                const cssMinimizerSpan = compilationSpan.traceChild('css-minimizer-plugin');
                return cssMinimizerSpan.traceAsyncFn(async ()=>{
                    const files = Object.keys(assets);
                    await Promise.all(files.filter((file)=>CSS_REGEX.test(file)).map(async (file)=>{
                        const assetSpan = cssMinimizerSpan.traceChild('minify-css');
                        assetSpan.setAttribute('file', file);
                        return assetSpan.traceAsyncFn(async ()=>{
                            const assetSource = compilation.getAsset(file).source;
                            const etag = cache.getLazyHashedEtag(assetSource);
                            const cachedResult = await cache.getPromise(file, etag);
                            assetSpan.setAttribute('cache', cachedResult ? 'HIT' : 'MISS');
                            if (cachedResult) {
                                compilation.updateAsset(file, cachedResult);
                                return;
                            }
                            const result = await this.optimizeAsset(file, assetSource);
                            await cache.storePromise(file, etag, result);
                            compilation.updateAsset(file, result);
                        });
                    }));
                });
            });
        });
    }
} //# sourceMappingURL=css-minimizer-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/next-trace-entrypoints-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    TRACE_IGNORES: null,
    TraceEntryPointsPlugin: null,
    getFilesMapFromReasons: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    TRACE_IGNORES: function() {
        return TRACE_IGNORES;
    },
    TraceEntryPointsPlugin: function() {
        return TraceEntryPointsPlugin;
    },
    getFilesMapFromReasons: function() {
        return getFilesMapFromReasons;
    }
});
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const _iserror = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-rsc] (ecmascript)"));
const _nft = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/@vercel/nft/index.js [app-rsc] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/constants.js [app-rsc] (ecmascript)");
const _webpack = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)");
const _webpackconfig = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack-config.js [app-rsc] (ecmascript)");
const _picomatch = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-rsc] (ecmascript)"));
const _getmodulebuildinfo = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/loaders/get-module-build-info.js [app-rsc] (ecmascript)");
const _entries = __turbopack_context__.r("[project]/node_modules/next/dist/build/entries.js [app-rsc] (ecmascript)");
const _handleexternals = __turbopack_context__.r("[project]/node_modules/next/dist/build/handle-externals.js [app-rsc] (ecmascript)");
const _ismetadataroute = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/is-metadata-route.js [app-rsc] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/build/webpack/utils.js [app-rsc] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PLUGIN_NAME = 'TraceEntryPointsPlugin';
const TRACE_IGNORES = [
    '**/*/next/dist/server/next.js',
    '**/*/next/dist/bin/next'
];
const NOT_TRACEABLE = [
    '.wasm',
    '.png',
    '.jpg',
    '.jpeg',
    '.gif',
    '.webp',
    '.avif',
    '.ico',
    '.bmp',
    '.svg'
];
function getModuleFromDependency(compilation, dep) {
    return compilation.moduleGraph.getModule(dep);
}
function getFilesMapFromReasons(fileList, reasons, ignoreFn) {
    // this uses the reasons tree to collect files specific to a
    // certain parent allowing us to not have to trace each parent
    // separately
    const parentFilesMap = new Map();
    function propagateToParents(parents, file, seen = new Set()) {
        for (const parent of parents || []){
            if (!seen.has(parent)) {
                seen.add(parent);
                let parentFiles = parentFilesMap.get(parent);
                if (!parentFiles) {
                    parentFiles = new Map();
                    parentFilesMap.set(parent, parentFiles);
                }
                const ignored = Boolean(ignoreFn == null ? void 0 : ignoreFn(file, parent));
                parentFiles.set(file, {
                    ignored
                });
                const parentReason = reasons.get(parent);
                if (parentReason == null ? void 0 : parentReason.parents) {
                    propagateToParents(parentReason.parents, file, seen);
                }
            }
        }
    }
    for (const file of fileList){
        const reason = reasons.get(file);
        const isInitial = (reason == null ? void 0 : reason.type.length) === 1 && reason.type.includes('initial');
        if (!reason || !reason.parents || isInitial && reason.parents.size === 0) {
            continue;
        }
        propagateToParents(reason.parents, file);
    }
    return parentFilesMap;
}
class TraceEntryPointsPlugin {
    constructor({ rootDir, appDir, pagesDir, compilerType, appDirEnabled, traceIgnores, esmExternals, outputFileTracingRoot }){
        this.buildTraceContext = {};
        this.rootDir = rootDir;
        this.appDir = appDir;
        this.pagesDir = pagesDir;
        this.entryTraces = new Map();
        this.esmExternals = esmExternals;
        this.appDirEnabled = appDirEnabled;
        this.traceIgnores = traceIgnores || [];
        this.tracingRoot = outputFileTracingRoot || rootDir;
        this.compilerType = compilerType;
    }
    // Here we output all traced assets and webpack chunks to a
    // ${page}.js.nft.json file
    async createTraceAssets(compilation, span) {
        const outputPath = compilation.outputOptions.path || '';
        await span.traceChild('create-trace-assets').traceAsyncFn(async ()=>{
            const entryFilesMap = new Map();
            const chunksToTrace = new Set();
            const entryNameFilesMap = new Map();
            const isTraceable = (file)=>!NOT_TRACEABLE.some((suffix)=>{
                    return file.endsWith(suffix);
                });
            for (const entrypoint of compilation.entrypoints.values()){
                const entryFiles = new Set();
                for (const chunk of entrypoint.getEntrypointChunk().getAllReferencedChunks()){
                    for (const file of chunk.files){
                        if (isTraceable(file)) {
                            const filePath = _path.default.join(outputPath, file);
                            chunksToTrace.add(filePath);
                            entryFiles.add(filePath);
                        }
                    }
                    for (const file of chunk.auxiliaryFiles){
                        if (isTraceable(file)) {
                            const filePath = _path.default.join(outputPath, file);
                            chunksToTrace.add(filePath);
                            entryFiles.add(filePath);
                        }
                    }
                }
                entryFilesMap.set(entrypoint, entryFiles);
                entryNameFilesMap.set(entrypoint.name || '', [
                    ...entryFiles
                ]);
            }
            // startTrace existed and callable
            this.buildTraceContext.chunksTrace = {
                action: {
                    action: 'annotate',
                    input: [
                        ...chunksToTrace
                    ],
                    contextDirectory: this.tracingRoot,
                    processCwd: this.rootDir
                },
                outputPath,
                entryNameFilesMap: Object.fromEntries(entryNameFilesMap)
            };
            // server compiler outputs to `server/chunks` so we traverse up
            // one, but edge-server does not so don't for that one
            const outputPrefix = this.compilerType === 'server' ? '../' : '';
            for (const [entrypoint, entryFiles] of entryFilesMap){
                var _this_entryTraces_get;
                const traceOutputName = `${outputPrefix}${entrypoint.name}.js.nft.json`;
                const traceOutputPath = _path.default.dirname(_path.default.join(outputPath, traceOutputName));
                // don't include the entry itself in the trace
                entryFiles.delete(_path.default.join(outputPath, `${outputPrefix}${entrypoint.name}.js`));
                if (entrypoint.name.startsWith('app/') && this.appDir) {
                    var _this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name, _this_buildTraceContext_entriesTrace;
                    const appDirRelativeEntryPath = (_this_buildTraceContext_entriesTrace = this.buildTraceContext.entriesTrace) == null ? void 0 : (_this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name = _this_buildTraceContext_entriesTrace.absolutePathByEntryName[entrypoint.name]) == null ? void 0 : _this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name.replace(this.appDir, '');
                    const entryIsStaticMetadataRoute = appDirRelativeEntryPath && (0, _ismetadataroute.isMetadataRouteFile)(appDirRelativeEntryPath, [], true);
                    // Include the client reference manifest in the trace, but not for
                    // static metadata routes, for which we don't generate those.
                    if (!entryIsStaticMetadataRoute) {
                        entryFiles.add(_path.default.join(outputPath, outputPrefix, entrypoint.name.replace(/%5F/g, '_') + '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js'));
                    }
                }
                const finalFiles = [];
                await Promise.all([
                    ...new Set([
                        ...entryFiles,
                        ...((_this_entryTraces_get = this.entryTraces.get(entrypoint.name)) == null ? void 0 : _this_entryTraces_get.keys()) || []
                    ])
                ].map(async (file)=>{
                    var _this_entryTraces_get;
                    const fileInfo = (_this_entryTraces_get = this.entryTraces.get(entrypoint.name)) == null ? void 0 : _this_entryTraces_get.get(file);
                    const relativeFile = _path.default.relative(traceOutputPath, file).replace(/\\/g, '/');
                    if (file) {
                        if (!(fileInfo == null ? void 0 : fileInfo.bundled)) {
                            finalFiles.push(relativeFile);
                        }
                    }
                }));
                compilation.emitAsset(traceOutputName, new _webpack.sources.RawSource(JSON.stringify({
                    version: _constants.TRACE_OUTPUT_VERSION,
                    files: finalFiles
                })));
            }
        });
    }
    tapfinishModules(compilation, traceEntrypointsPluginSpan, doResolve, readlink, stat) {
        compilation.hooks.finishModules.tapAsync(PLUGIN_NAME, async (_stats, callback)=>{
            const finishModulesSpan = traceEntrypointsPluginSpan.traceChild('finish-modules');
            await finishModulesSpan.traceAsyncFn(async ()=>{
                // we create entry -> module maps so that we can
                // look them up faster instead of having to iterate
                // over the compilation modules list
                const entryNameMap = new Map();
                const entryModMap = new Map();
                const additionalEntries = new Map();
                const absolutePathByEntryName = new Map();
                const depModMap = new Map();
                await finishModulesSpan.traceChild('get-entries').traceAsyncFn(async ()=>{
                    for (const [name, entry] of compilation.entries.entries()){
                        const normalizedName = name == null ? void 0 : name.replace(/\\/g, '/');
                        const isPage = normalizedName.startsWith('pages/');
                        const isApp = this.appDirEnabled && normalizedName.startsWith('app/');
                        if (isApp || isPage) {
                            for (const dep of entry.dependencies){
                                if (!dep) continue;
                                const entryMod = getModuleFromDependency(compilation, dep);
                                // Handle case where entry is a loader coming from Next.js.
                                // For example edge-loader or app-loader.
                                if (entryMod && entryMod.resource === '') {
                                    const moduleBuildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(entryMod);
                                    // All loaders that are used to create entries have a `route` property on the buildInfo.
                                    if (moduleBuildInfo.route) {
                                        const absolutePath = (0, _entries.getPageFilePath)({
                                            absolutePagePath: moduleBuildInfo.route.absolutePagePath,
                                            rootDir: this.rootDir,
                                            appDir: this.appDir,
                                            pagesDir: this.pagesDir
                                        });
                                        // Ensures we don't handle non-pages.
                                        if (this.pagesDir && absolutePath.startsWith(this.pagesDir) || this.appDir && absolutePath.startsWith(this.appDir)) {
                                            entryModMap.set(absolutePath, entryMod);
                                            entryNameMap.set(absolutePath, name);
                                            absolutePathByEntryName.set(name, absolutePath);
                                        }
                                    }
                                    // If there was no `route` property, we can assume that it was something custom instead.
                                    // In order to trace these we add them to the additionalEntries map.
                                    if (entryMod.request) {
                                        let curMap = additionalEntries.get(name);
                                        if (!curMap) {
                                            curMap = new Map();
                                            additionalEntries.set(name, curMap);
                                        }
                                        depModMap.set(entryMod.request, entryMod);
                                        curMap.set(entryMod.resource, entryMod);
                                    }
                                }
                                if (entryMod && entryMod.resource) {
                                    entryNameMap.set(entryMod.resource, name);
                                    entryModMap.set(entryMod.resource, entryMod);
                                    let curMap = additionalEntries.get(name);
                                    if (!curMap) {
                                        curMap = new Map();
                                        additionalEntries.set(name, curMap);
                                    }
                                    depModMap.set(entryMod.resource, entryMod);
                                    curMap.set(entryMod.resource, entryMod);
                                }
                            }
                        }
                    }
                });
                const readFile = async (path)=>{
                    var _mod_originalSource, _mod_originalSource1;
                    const mod = depModMap.get(path) || entryModMap.get(path);
                    // map the transpiled source when available to avoid
                    // parse errors in node-file-trace
                    let source = mod == null ? void 0 : (_mod_originalSource1 = mod.originalSource) == null ? void 0 : (_mod_originalSource = _mod_originalSource1.call(mod)) == null ? void 0 : _mod_originalSource.buffer();
                    return source || '';
                };
                const entryPaths = Array.from(entryModMap.keys());
                const collectDependencies = async (mod, parent)=>{
                    if (!mod || !mod.dependencies) return;
                    for (const dep of mod.dependencies){
                        const depMod = getModuleFromDependency(compilation, dep);
                        if ((depMod == null ? void 0 : depMod.resource) && !depModMap.get(depMod.resource)) {
                            depModMap.set(depMod.resource, depMod);
                            await collectDependencies(depMod, parent);
                        }
                    }
                };
                const entriesToTrace = [
                    ...entryPaths
                ];
                for (const entry of entryPaths){
                    await collectDependencies(entryModMap.get(entry), entry);
                    const entryName = entryNameMap.get(entry);
                    const curExtraEntries = additionalEntries.get(entryName);
                    if (curExtraEntries) {
                        entriesToTrace.push(...curExtraEntries.keys());
                    }
                }
                const contextDirectory = this.tracingRoot;
                const chunks = [
                    ...entriesToTrace
                ];
                this.buildTraceContext.entriesTrace = {
                    action: {
                        action: 'print',
                        input: chunks,
                        contextDirectory,
                        processCwd: this.rootDir
                    },
                    appDir: this.rootDir,
                    depModArray: Array.from(depModMap.keys()),
                    entryNameMap: Object.fromEntries(entryNameMap),
                    absolutePathByEntryName: Object.fromEntries(absolutePathByEntryName),
                    outputPath: compilation.outputOptions.path
                };
                let fileList;
                let reasons;
                const ignores = [
                    ...TRACE_IGNORES,
                    ...this.traceIgnores,
                    '**/node_modules/**'
                ];
                // pre-compile the ignore matcher to avoid repeating on every ignoreFn call
                const isIgnoreMatcher = (0, _picomatch.default)(ignores, {
                    contains: true,
                    dot: true
                });
                const ignoreFn = (path)=>{
                    return isIgnoreMatcher(path);
                };
                await finishModulesSpan.traceChild('node-file-trace-plugin', {
                    traceEntryCount: entriesToTrace.length + ''
                }).traceAsyncFn(async ()=>{
                    const result = await (0, _nft.nodeFileTrace)(entriesToTrace, {
                        base: this.tracingRoot,
                        processCwd: this.rootDir,
                        readFile,
                        readlink,
                        stat,
                        resolve: doResolve ? async (id, parent, job, isCjs)=>{
                            return doResolve(id, parent, job, !isCjs);
                        } : undefined,
                        ignore: ignoreFn,
                        mixedModules: true
                    });
                    // @ts-ignore
                    fileList = result.fileList;
                    result.esmFileList.forEach((file)=>fileList.add(file));
                    reasons = result.reasons;
                });
                await finishModulesSpan.traceChild('collect-traced-files').traceAsyncFn(()=>{
                    const parentFilesMap = getFilesMapFromReasons(fileList, reasons, (file)=>{
                        var _reasons_get;
                        // if a file was imported and a loader handled it
                        // we don't include it in the trace e.g.
                        // static image imports, CSS imports
                        file = _path.default.join(this.tracingRoot, file);
                        const depMod = depModMap.get(file);
                        const isAsset = (_reasons_get = reasons.get(_path.default.relative(this.tracingRoot, file))) == null ? void 0 : _reasons_get.type.includes('asset');
                        return !isAsset && Array.isArray(depMod == null ? void 0 : depMod.loaders) && depMod.loaders.length > 0;
                    });
                    for (const entry of entryPaths){
                        var _parentFilesMap_get;
                        const entryName = entryNameMap.get(entry);
                        const normalizedEntry = _path.default.relative(this.tracingRoot, entry);
                        const curExtraEntries = additionalEntries.get(entryName);
                        const finalDeps = new Map();
                        // ensure we include entry source file as well for
                        // hash comparison
                        finalDeps.set(entry, {
                            bundled: true
                        });
                        for (const [dep, info] of ((_parentFilesMap_get = parentFilesMap.get(normalizedEntry)) == null ? void 0 : _parentFilesMap_get.entries()) || []){
                            finalDeps.set(_path.default.join(this.tracingRoot, dep), {
                                bundled: info.ignored
                            });
                        }
                        if (curExtraEntries) {
                            for (const extraEntry of curExtraEntries.keys()){
                                var _parentFilesMap_get1;
                                const normalizedExtraEntry = _path.default.relative(this.tracingRoot, extraEntry);
                                finalDeps.set(extraEntry, {
                                    bundled: false
                                });
                                for (const [dep, info] of ((_parentFilesMap_get1 = parentFilesMap.get(normalizedExtraEntry)) == null ? void 0 : _parentFilesMap_get1.entries()) || []){
                                    finalDeps.set(_path.default.join(this.tracingRoot, dep), {
                                        bundled: info.ignored
                                    });
                                }
                            }
                        }
                        this.entryTraces.set(entryName, finalDeps);
                    }
                });
            }).then(()=>callback(), (err)=>callback(err));
        });
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
            const compilationSpan = (0, _utils.getCompilationSpan)(compilation) || (0, _utils.getCompilationSpan)(compiler);
            const traceEntrypointsPluginSpan = compilationSpan.traceChild('next-trace-entrypoint-plugin');
            const readlink = async (path)=>{
                try {
                    return await new Promise((resolve, reject)=>{
                        ;
                        compilation.inputFileSystem.readlink(path, (err, link)=>{
                            if (err) return reject(err);
                            resolve(link);
                        });
                    });
                } catch (e) {
                    if ((0, _iserror.default)(e) && (e.code === 'EINVAL' || e.code === 'ENOENT' || e.code === 'UNKNOWN')) {
                        return null;
                    }
                    throw e;
                }
            };
            const stat = async (path)=>{
                try {
                    return await new Promise((resolve, reject)=>{
                        ;
                        compilation.inputFileSystem.stat(path, (err, stats)=>{
                            if (err) return reject(err);
                            resolve(stats);
                        });
                    });
                } catch (e) {
                    if ((0, _iserror.default)(e) && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {
                        return null;
                    }
                    throw e;
                }
            };
            traceEntrypointsPluginSpan.traceFn(()=>{
                compilation.hooks.processAssets.tapAsync({
                    name: PLUGIN_NAME,
                    stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
                }, (_, callback)=>{
                    this.createTraceAssets(compilation, traceEntrypointsPluginSpan).then(()=>callback()).catch((err)=>callback(err));
                });
                let resolver = compilation.resolverFactory.get('normal');
                function getPkgName(name) {
                    const segments = name.split('/');
                    if (name[0] === '@' && segments.length > 1) return segments.length > 1 ? segments.slice(0, 2).join('/') : null;
                    return segments.length ? segments[0] : null;
                }
                const getResolve = (options)=>{
                    const curResolver = resolver.withOptions(options);
                    return (parent, request, job)=>new Promise((resolve, reject)=>{
                            const context = _path.default.dirname(parent);
                            curResolver.resolve({}, context, request, {
                                fileDependencies: compilation.fileDependencies,
                                missingDependencies: compilation.missingDependencies,
                                contextDependencies: compilation.contextDependencies
                            }, async (err, result, resContext)=>{
                                if (err) return reject(err);
                                if (!result) {
                                    return reject(Object.defineProperty(new Error('module not found'), "__NEXT_ERROR_CODE", {
                                        value: "E512",
                                        enumerable: false,
                                        configurable: true
                                    }));
                                }
                                // webpack resolver doesn't strip loader query info
                                // from the result so use path instead
                                if (result.includes('?') || result.includes('!')) {
                                    result = (resContext == null ? void 0 : resContext.path) || result;
                                }
                                try {
                                    // we need to collect all parent package.json's used
                                    // as webpack's resolve doesn't expose this and parent
                                    // package.json could be needed for resolving e.g. stylis
                                    // stylis/package.json -> stylis/dist/umd/package.json
                                    if (result.includes('node_modules')) {
                                        let requestPath = result.replace(/\\/g, '/').replace(/\0/g, '');
                                        if (!_path.default.isAbsolute(request) && request.includes('/') && (resContext == null ? void 0 : resContext.descriptionFileRoot)) {
                                            var _getPkgName;
                                            requestPath = (resContext.descriptionFileRoot + request.slice(((_getPkgName = getPkgName(request)) == null ? void 0 : _getPkgName.length) || 0) + _path.default.sep + 'package.json').replace(/\\/g, '/').replace(/\0/g, '');
                                        }
                                        const rootSeparatorIndex = requestPath.indexOf('/');
                                        let separatorIndex;
                                        while((separatorIndex = requestPath.lastIndexOf('/')) > rootSeparatorIndex){
                                            requestPath = requestPath.slice(0, separatorIndex);
                                            const curPackageJsonPath = `${requestPath}/package.json`;
                                            if (await job.isFile(curPackageJsonPath)) {
                                                await job.emitFile(await job.realpath(curPackageJsonPath), 'resolve', parent);
                                            }
                                        }
                                    }
                                } catch (_err) {
                                // we failed to resolve the package.json boundary,
                                // we don't block emitting the initial asset from this
                                }
                                resolve([
                                    result,
                                    options.dependencyType === 'esm'
                                ]);
                            });
                        });
                };
                const CJS_RESOLVE_OPTIONS = {
                    ..._webpackconfig.NODE_RESOLVE_OPTIONS,
                    fullySpecified: undefined,
                    modules: undefined,
                    extensions: undefined
                };
                const BASE_CJS_RESOLVE_OPTIONS = {
                    ...CJS_RESOLVE_OPTIONS,
                    alias: false
                };
                const ESM_RESOLVE_OPTIONS = {
                    ..._webpackconfig.NODE_ESM_RESOLVE_OPTIONS,
                    fullySpecified: undefined,
                    modules: undefined,
                    extensions: undefined
                };
                const BASE_ESM_RESOLVE_OPTIONS = {
                    ...ESM_RESOLVE_OPTIONS,
                    alias: false
                };
                const doResolve = async (request, parent, job, isEsmRequested)=>{
                    const context = _path.default.dirname(parent);
                    // When in esm externals mode, and using import, we resolve with
                    // ESM resolving options.
                    const { res } = await (0, _handleexternals.resolveExternal)(this.rootDir, this.esmExternals, context, request, isEsmRequested, (options)=>(_, resRequest)=>{
                            return getResolve(options)(parent, resRequest, job);
                        }, undefined, undefined, ESM_RESOLVE_OPTIONS, CJS_RESOLVE_OPTIONS, BASE_ESM_RESOLVE_OPTIONS, BASE_CJS_RESOLVE_OPTIONS);
                    if (!res) {
                        throw Object.defineProperty(new Error(`failed to resolve ${request} from ${parent}`), "__NEXT_ERROR_CODE", {
                            value: "E361",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    return res.replace(/\0/g, '');
                };
                this.tapfinishModules(compilation, traceEntrypointsPluginSpan, doResolve, readlink, stat);
            });
        });
    }
} //# sourceMappingURL=next-trace-entrypoints-plugin.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/nextjs-require-cache-hot-reloader.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NextJsRequireCacheHotReloader", {
    enumerable: true,
    get: function() {
        return NextJsRequireCacheHotReloader;
    }
});
const _requirecache = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/require-cache.js [app-rsc] (ecmascript)");
const _sandbox = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/sandbox/index.js [app-rsc] (ecmascript)");
const _path = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const RUNTIME_NAMES = [
    'webpack-runtime',
    'webpack-api-runtime'
];
const PLUGIN_NAME = 'NextJsRequireCacheHotReloader';
class NextJsRequireCacheHotReloader {
    constructor(opts){
        this.prevAssets = null;
        this.serverComponents = opts.serverComponents;
    }
    apply(compiler) {
        compiler.hooks.assetEmitted.tap(PLUGIN_NAME, (_file, { targetPath })=>{
            // Clear module context in this process
            (0, _sandbox.clearModuleContext)(targetPath);
            (0, _requirecache.deleteCache)(targetPath);
        });
        compiler.hooks.afterEmit.tapPromise(PLUGIN_NAME, async (compilation)=>{
            for (const name of RUNTIME_NAMES){
                const runtimeChunkPath = _path.default.join(compilation.outputOptions.path, `${name}.js`);
                (0, _requirecache.deleteCache)(runtimeChunkPath);
            }
            // we need to make sure to clear all server entries from cache
            // since they can have a stale webpack-runtime cache
            // which needs to always be in-sync
            const entries = [
                ...compilation.entrypoints.keys()
            ].filter((entry)=>{
                const isAppPath = entry.toString().startsWith('app/');
                return entry.toString().startsWith('pages/') || isAppPath;
            });
            for (const page of entries){
                const outputPath = _path.default.join(compilation.outputOptions.path, page + '.js');
                (0, _requirecache.deleteCache)(outputPath);
            }
        });
    }
} //# sourceMappingURL=nextjs-require-cache-hot-reloader.js.map
}}),
"[project]/node_modules/next/dist/build/webpack/plugins/slow-module-detection-plugin.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SlowModuleDetectionPlugin;
    }
});
const _picocolors = __turbopack_context__.r("[project]/node_modules/next/dist/lib/picocolors.js [app-rsc] (ecmascript)");
const PLUGIN_NAME = 'SlowModuleDetectionPlugin';
const TreeSymbols = {
    VERTICAL_LINE: '│  ',
    BRANCH: '├─ '
};
const PATH_TRUNCATION_LENGTH = 120;
// Matches node_modules paths, including pnpm-style paths
const NODE_MODULES_PATH_PATTERN = /node_modules(?:\/\.pnpm)?\/(.*)/;
const getModuleIdentifier = (module)=>{
    const debugId = module.debugId;
    return String(debugId);
};
const getModuleDisplayName = (module)=>{
    const resourcePath = 'resource' in module && typeof module.resource === 'string' ? module.resource : undefined;
    if (!resourcePath) {
        return undefined;
    }
    let displayPath = resourcePath.replace(process.cwd(), '.');
    const nodeModulesMatch = displayPath.match(NODE_MODULES_PATH_PATTERN);
    if (nodeModulesMatch) {
        return nodeModulesMatch[1];
    }
    return displayPath;
};
/**
 * Truncates a path to a maximum length. If the path exceeds this length,
 * it will be truncated in the middle and replaced with '...'.
 */ function truncatePath(path, maxLength) {
    // If the path length is within the limit, return it as is
    if (path.length <= maxLength) return path;
    // Calculate the available length for the start and end segments after accounting for '...'
    const availableLength = maxLength - 3;
    const startSegmentLength = Math.ceil(availableLength / 2);
    const endSegmentLength = Math.floor(availableLength / 2);
    // Extract the start and end segments of the path
    const startSegment = path.slice(0, startSegmentLength);
    const endSegment = path.slice(-endSegmentLength);
    // Return the truncated path with '...' in the middle
    return `${startSegment}...${endSegment}`;
}
class ModuleBuildTimeAnalyzer {
    constructor(options){
        this.options = options;
        this.pendingModules = [];
        this.modules = new Map();
        this.moduleParents = new Map();
        this.moduleChildren = new Map();
        this.isFinalized = false;
        this.moduleBuildTimes = new WeakMap();
        this.buildTimeThresholdMs = options.buildTimeThresholdMs;
    }
    recordModuleBuildTime(module, duration) {
        // Webpack guarantees that no more modules will be built after finishModules hook is called,
        // where we generate the report. This check is just a defensive measure.
        if (this.isFinalized) {
            throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Module is recorded after the report is generated. This is a Next.js internal bug.`), "__NEXT_ERROR_CODE", {
                value: "E630",
                enumerable: false,
                configurable: true
            });
        }
        if (duration < this.buildTimeThresholdMs) {
            return; // Skip fast modules
        }
        this.moduleBuildTimes.set(module, duration);
        this.pendingModules.push(module);
    }
    /**
   * For each slow module, traverses up the dependency chain to find all ancestor modules.
   * Builds a directed graph where:
   * 1. Each slow module and its ancestors become nodes
   * 2. Edges represent "imported by" relationships
   * 3. Root nodes are entry points with no parents
   *
   * The resulting graph allows us to visualize the import chains that led to slow builds.
   */ prepareReport(compilation) {
        for (const module of this.pendingModules){
            const chain = new Set();
            // Walk up the module graph until we hit a root module (no issuer) to populate the chain
            {
                let currentModule = module;
                chain.add(currentModule);
                while(true){
                    const issuerModule = compilation.moduleGraph.getIssuer(currentModule);
                    if (!issuerModule) break;
                    if (chain.has(issuerModule)) {
                        throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Circular dependency detected in module graph. This is a Next.js internal bug.`), "__NEXT_ERROR_CODE", {
                            value: "E631",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    chain.add(issuerModule);
                    currentModule = issuerModule;
                }
            }
            // Add all visited modules to our graph and create parent-child relationships
            let previousModule = null;
            for (const currentModule of chain){
                const moduleId = getModuleIdentifier(currentModule);
                if (!this.modules.has(moduleId)) {
                    this.modules.set(moduleId, currentModule);
                }
                if (previousModule) {
                    this.moduleParents.set(previousModule, currentModule);
                    let parentChildren = this.moduleChildren.get(currentModule);
                    if (!parentChildren) {
                        parentChildren = new Map();
                        this.moduleChildren.set(currentModule, parentChildren);
                    }
                    parentChildren.set(getModuleIdentifier(previousModule), previousModule);
                }
                previousModule = currentModule;
            }
        }
        this.isFinalized = true;
    }
    generateReport(compilation) {
        if (!this.isFinalized) {
            this.prepareReport(compilation);
        }
        // Find root modules (those with no parents)
        const rootModules = [
            ...this.modules.values()
        ].filter((node)=>!this.moduleParents.has(node));
        const formatModuleNode = (node, depth)=>{
            const moduleName = getModuleDisplayName(node) || '';
            if (!moduleName) {
                return formatChildModules(node, depth);
            }
            const prefix = ' ' + TreeSymbols.VERTICAL_LINE.repeat(depth) + TreeSymbols.BRANCH;
            const moduleText = (0, _picocolors.blue)(truncatePath(moduleName, PATH_TRUNCATION_LENGTH - prefix.length));
            const buildTimeMs = this.moduleBuildTimes.get(node);
            const duration = buildTimeMs ? (0, _picocolors.yellow)(` (${Math.ceil(buildTimeMs)}ms)`) : '';
            return prefix + moduleText + duration + '\n' + formatChildModules(node, depth + 1);
        };
        const formatChildModules = (node, depth)=>{
            const children = this.moduleChildren.get(node);
            if (!children) return '';
            return [
                ...children
            ].map(([_, child])=>formatModuleNode(child, depth)).join('');
        };
        const report = rootModules.map((root)=>formatModuleNode(root, 0)).join('');
        if (report) {
            console.log((0, _picocolors.green)(`🐌 Detected slow modules while compiling ${this.options.compilerType}:`) + '\n' + report);
        }
    }
}
class SlowModuleDetectionPlugin {
    constructor(options){
        this.options = options;
        this.apply = (compiler)=>{
            compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{
                const analyzer = new ModuleBuildTimeAnalyzer(this.options);
                const moduleBuildStartTimes = new WeakMap();
                compilation.hooks.buildModule.tap(PLUGIN_NAME, (module)=>{
                    moduleBuildStartTimes.set(module, performance.now());
                });
                compilation.hooks.succeedModule.tap(PLUGIN_NAME, (module)=>{
                    const startTime = moduleBuildStartTimes.get(module);
                    if (!startTime) {
                        throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Unable to find the start time for a module build. This is a Next.js internal bug.`), "__NEXT_ERROR_CODE", {
                            value: "E629",
                            enumerable: false,
                            configurable: true
                        });
                    }
                    analyzer.recordModuleBuildTime(module, performance.now() - startTime);
                });
                compilation.hooks.finishModules.tap(PLUGIN_NAME, ()=>{
                    analyzer.generateReport(compilation);
                });
            });
        };
    }
} //# sourceMappingURL=slow-module-detection-plugin.js.map
}}),

};

//# sourceMappingURL=node_modules_next_dist_build_webpack_d487ec00._.js.map